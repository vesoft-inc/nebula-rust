// @generated by Thrift. This file is probably not the place you want to edit!

#![recursion_limit = "100000000"]
#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals, unused_crate_dependencies)]

pub use self::errors::*;
pub use self::types::*;

pub mod types {
    #![allow(clippy::redundant_closure)]


    pub type SchemaVer = ::std::primitive::i64;

    pub type ClusterID = ::std::primitive::i64;

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum ID {
        space_id(common::types::GraphSpaceID),
        tag_id(common::types::TagID),
        edge_type(common::types::EdgeType),
        index_id(common::types::IndexID),
        cluster_id(crate::types::ClusterID),
        UnknownField(::std::primitive::i32),
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct ColumnTypeDef {
        pub type_: crate::types::PropertyType,
        pub type_length: ::std::option::Option<::std::primitive::i16>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct ColumnDef {
        pub name: ::std::vec::Vec<::std::primitive::u8>,
        pub type_: crate::types::ColumnTypeDef,
        pub default_value: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
        pub nullable: ::std::option::Option<::std::primitive::bool>,
        pub comment: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct SchemaProp {
        pub ttl_duration: ::std::option::Option<::std::primitive::i64>,
        pub ttl_col: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
        pub comment: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct Schema {
        pub columns: ::std::vec::Vec<crate::types::ColumnDef>,
        pub schema_prop: crate::types::SchemaProp,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct IdName {
        pub id: crate::types::ID,
        pub name: ::std::vec::Vec<::std::primitive::u8>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct SpaceDesc {
        pub space_name: ::std::vec::Vec<::std::primitive::u8>,
        pub partition_num: ::std::primitive::i32,
        pub replica_factor: ::std::primitive::i32,
        pub charset_name: ::std::vec::Vec<::std::primitive::u8>,
        pub collate_name: ::std::vec::Vec<::std::primitive::u8>,
        pub vid_type: crate::types::ColumnTypeDef,
        pub group_name: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
        pub isolation_level: ::std::option::Option<crate::types::IsolationLevel>,
        pub comment: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct SpaceItem {
        pub space_id: common::types::GraphSpaceID,
        pub properties: crate::types::SpaceDesc,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct TagItem {
        pub tag_id: common::types::TagID,
        pub tag_name: ::std::vec::Vec<::std::primitive::u8>,
        pub version: crate::types::SchemaVer,
        pub schema: crate::types::Schema,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct AlterSchemaItem {
        pub op: crate::types::AlterSchemaOp,
        pub schema: crate::types::Schema,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct EdgeItem {
        pub edge_type: common::types::EdgeType,
        pub edge_name: ::std::vec::Vec<::std::primitive::u8>,
        pub version: crate::types::SchemaVer,
        pub schema: crate::types::Schema,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum SchemaID {
        tag_id(common::types::TagID),
        edge_type(common::types::EdgeType),
        UnknownField(::std::primitive::i32),
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct IndexItem {
        pub index_id: common::types::IndexID,
        pub index_name: ::std::vec::Vec<::std::primitive::u8>,
        pub schema_id: crate::types::SchemaID,
        pub schema_name: ::std::vec::Vec<::std::primitive::u8>,
        pub fields: ::std::vec::Vec<crate::types::ColumnDef>,
        pub comment: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct HostItem {
        pub hostAddr: common::types::HostAddr,
        pub status: crate::types::HostStatus,
        pub leader_parts: ::std::collections::BTreeMap<::std::vec::Vec<::std::primitive::u8>, ::std::vec::Vec<common::types::PartitionID>>,
        pub all_parts: ::std::collections::BTreeMap<::std::vec::Vec<::std::primitive::u8>, ::std::vec::Vec<common::types::PartitionID>>,
        pub role: crate::types::HostRole,
        pub git_info_sha: ::std::vec::Vec<::std::primitive::u8>,
        pub zone_name: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct UserItem {
        pub account: ::std::vec::Vec<::std::primitive::u8>,
        pub is_lock: ::std::primitive::bool,
        pub max_queries_per_hour: ::std::primitive::i32,
        pub max_updates_per_hour: ::std::primitive::i32,
        pub max_connections_per_hour: ::std::primitive::i32,
        pub max_user_connections: ::std::primitive::i32,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct RoleItem {
        pub user_id: ::std::vec::Vec<::std::primitive::u8>,
        pub space_id: common::types::GraphSpaceID,
        pub role_type: crate::types::RoleType,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct ExecResp {
        pub code: crate::types::ErrorCode,
        pub id: crate::types::ID,
        pub leader: common::types::HostAddr,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct AdminJobReq {
        pub op: crate::types::AdminJobOp,
        pub cmd: crate::types::AdminCmd,
        pub paras: ::std::vec::Vec<::std::vec::Vec<::std::primitive::u8>>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct JobDesc {
        pub id: ::std::primitive::i32,
        pub cmd: crate::types::AdminCmd,
        pub paras: ::std::vec::Vec<::std::string::String>,
        pub status: crate::types::JobStatus,
        pub start_time: ::std::primitive::i64,
        pub stop_time: ::std::primitive::i64,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct TaskDesc {
        pub task_id: ::std::primitive::i32,
        pub host: common::types::HostAddr,
        pub status: crate::types::JobStatus,
        pub start_time: ::std::primitive::i64,
        pub stop_time: ::std::primitive::i64,
        pub job_id: ::std::primitive::i32,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct AdminJobResult {
        pub job_id: ::std::option::Option<::std::primitive::i32>,
        pub job_desc: ::std::option::Option<::std::vec::Vec<crate::types::JobDesc>>,
        pub task_desc: ::std::option::Option<::std::vec::Vec<crate::types::TaskDesc>>,
        pub recovered_job_num: ::std::option::Option<::std::primitive::i32>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct AdminJobResp {
        pub code: crate::types::ErrorCode,
        pub leader: common::types::HostAddr,
        pub result: crate::types::AdminJobResult,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct Correlativity {
        pub part_id: common::types::PartitionID,
        pub proportion: ::std::primitive::f64,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct StatisItem {
        pub tag_vertices: ::std::collections::BTreeMap<::std::vec::Vec<::std::primitive::u8>, ::std::primitive::i64>,
        pub edges: ::std::collections::BTreeMap<::std::vec::Vec<::std::primitive::u8>, ::std::primitive::i64>,
        pub space_vertices: ::std::primitive::i64,
        pub space_edges: ::std::primitive::i64,
        pub positive_part_correlativity: ::std::collections::BTreeMap<common::types::PartitionID, ::std::vec::Vec<crate::types::Correlativity>>,
        pub negative_part_correlativity: ::std::collections::BTreeMap<common::types::PartitionID, ::std::vec::Vec<crate::types::Correlativity>>,
        pub status: crate::types::JobStatus,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct CreateSpaceReq {
        pub properties: crate::types::SpaceDesc,
        pub if_not_exists: ::std::primitive::bool,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct DropSpaceReq {
        pub space_name: ::std::vec::Vec<::std::primitive::u8>,
        pub if_exists: ::std::primitive::bool,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct ListSpacesReq {
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct ListSpacesResp {
        pub code: crate::types::ErrorCode,
        pub leader: common::types::HostAddr,
        pub spaces: ::std::vec::Vec<crate::types::IdName>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct GetSpaceReq {
        pub space_name: ::std::vec::Vec<::std::primitive::u8>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct GetSpaceResp {
        pub code: crate::types::ErrorCode,
        pub leader: common::types::HostAddr,
        pub item: crate::types::SpaceItem,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct CreateTagReq {
        pub space_id: common::types::GraphSpaceID,
        pub tag_name: ::std::vec::Vec<::std::primitive::u8>,
        pub schema: crate::types::Schema,
        pub if_not_exists: ::std::primitive::bool,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct AlterTagReq {
        pub space_id: common::types::GraphSpaceID,
        pub tag_name: ::std::vec::Vec<::std::primitive::u8>,
        pub tag_items: ::std::vec::Vec<crate::types::AlterSchemaItem>,
        pub schema_prop: crate::types::SchemaProp,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct DropTagReq {
        pub space_id: common::types::GraphSpaceID,
        pub tag_name: ::std::vec::Vec<::std::primitive::u8>,
        pub if_exists: ::std::primitive::bool,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct ListTagsReq {
        pub space_id: common::types::GraphSpaceID,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct ListTagsResp {
        pub code: crate::types::ErrorCode,
        pub leader: common::types::HostAddr,
        pub tags: ::std::vec::Vec<crate::types::TagItem>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct GetTagReq {
        pub space_id: common::types::GraphSpaceID,
        pub tag_name: ::std::vec::Vec<::std::primitive::u8>,
        pub version: crate::types::SchemaVer,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct GetTagResp {
        pub code: crate::types::ErrorCode,
        pub leader: common::types::HostAddr,
        pub schema: crate::types::Schema,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct CreateEdgeReq {
        pub space_id: common::types::GraphSpaceID,
        pub edge_name: ::std::vec::Vec<::std::primitive::u8>,
        pub schema: crate::types::Schema,
        pub if_not_exists: ::std::primitive::bool,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct AlterEdgeReq {
        pub space_id: common::types::GraphSpaceID,
        pub edge_name: ::std::vec::Vec<::std::primitive::u8>,
        pub edge_items: ::std::vec::Vec<crate::types::AlterSchemaItem>,
        pub schema_prop: crate::types::SchemaProp,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct GetEdgeReq {
        pub space_id: common::types::GraphSpaceID,
        pub edge_name: ::std::vec::Vec<::std::primitive::u8>,
        pub version: crate::types::SchemaVer,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct GetEdgeResp {
        pub code: crate::types::ErrorCode,
        pub leader: common::types::HostAddr,
        pub schema: crate::types::Schema,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct DropEdgeReq {
        pub space_id: common::types::GraphSpaceID,
        pub edge_name: ::std::vec::Vec<::std::primitive::u8>,
        pub if_exists: ::std::primitive::bool,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct ListEdgesReq {
        pub space_id: common::types::GraphSpaceID,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct ListEdgesResp {
        pub code: crate::types::ErrorCode,
        pub leader: common::types::HostAddr,
        pub edges: ::std::vec::Vec<crate::types::EdgeItem>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct ListHostsReq {
        pub type_: crate::types::ListHostType,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct ListHostsResp {
        pub code: crate::types::ErrorCode,
        pub leader: common::types::HostAddr,
        pub hosts: ::std::vec::Vec<crate::types::HostItem>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct PartItem {
        pub part_id: common::types::PartitionID,
        pub leader: ::std::option::Option<common::types::HostAddr>,
        pub peers: ::std::vec::Vec<common::types::HostAddr>,
        pub losts: ::std::vec::Vec<common::types::HostAddr>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct ListPartsReq {
        pub space_id: common::types::GraphSpaceID,
        pub part_ids: ::std::vec::Vec<common::types::PartitionID>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct ListPartsResp {
        pub code: crate::types::ErrorCode,
        pub leader: common::types::HostAddr,
        pub parts: ::std::vec::Vec<crate::types::PartItem>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct GetPartsAllocReq {
        pub space_id: common::types::GraphSpaceID,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct GetPartsAllocResp {
        pub code: crate::types::ErrorCode,
        pub leader: common::types::HostAddr,
        pub parts: ::std::collections::BTreeMap<common::types::PartitionID, ::std::vec::Vec<common::types::HostAddr>>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct MultiPutReq {
        pub segment: ::std::vec::Vec<::std::primitive::u8>,
        pub pairs: ::std::vec::Vec<common::types::KeyValue>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct GetReq {
        pub segment: ::std::vec::Vec<::std::primitive::u8>,
        pub key: ::std::vec::Vec<::std::primitive::u8>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct GetResp {
        pub code: crate::types::ErrorCode,
        pub leader: common::types::HostAddr,
        pub value: ::std::vec::Vec<::std::primitive::u8>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct MultiGetReq {
        pub segment: ::std::vec::Vec<::std::primitive::u8>,
        pub keys: ::std::vec::Vec<::std::vec::Vec<::std::primitive::u8>>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct MultiGetResp {
        pub code: crate::types::ErrorCode,
        pub leader: common::types::HostAddr,
        pub values: ::std::vec::Vec<::std::vec::Vec<::std::primitive::u8>>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct RemoveReq {
        pub segment: ::std::vec::Vec<::std::primitive::u8>,
        pub key: ::std::vec::Vec<::std::primitive::u8>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct RemoveRangeReq {
        pub segment: ::std::vec::Vec<::std::primitive::u8>,
        pub start: ::std::vec::Vec<::std::primitive::u8>,
        pub end: ::std::vec::Vec<::std::primitive::u8>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct ScanReq {
        pub segment: ::std::vec::Vec<::std::primitive::u8>,
        pub start: ::std::vec::Vec<::std::primitive::u8>,
        pub end: ::std::vec::Vec<::std::primitive::u8>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct ScanResp {
        pub code: crate::types::ErrorCode,
        pub leader: common::types::HostAddr,
        pub values: ::std::vec::Vec<::std::vec::Vec<::std::primitive::u8>>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct HBResp {
        pub code: crate::types::ErrorCode,
        pub leader: common::types::HostAddr,
        pub cluster_id: crate::types::ClusterID,
        pub last_update_time_in_ms: ::std::primitive::i64,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct LeaderInfo {
        pub part_id: common::types::PartitionID,
        pub term: ::std::primitive::i64,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct HBReq {
        pub role: crate::types::HostRole,
        pub host: common::types::HostAddr,
        pub cluster_id: crate::types::ClusterID,
        pub leader_partIds: ::std::option::Option<::std::collections::BTreeMap<common::types::GraphSpaceID, ::std::vec::Vec<crate::types::LeaderInfo>>>,
        pub git_info_sha: ::std::vec::Vec<::std::primitive::u8>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct IndexFieldDef {
        pub name: ::std::vec::Vec<::std::primitive::u8>,
        pub type_length: ::std::option::Option<::std::primitive::i16>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct CreateTagIndexReq {
        pub space_id: common::types::GraphSpaceID,
        pub index_name: ::std::vec::Vec<::std::primitive::u8>,
        pub tag_name: ::std::vec::Vec<::std::primitive::u8>,
        pub fields: ::std::vec::Vec<crate::types::IndexFieldDef>,
        pub if_not_exists: ::std::primitive::bool,
        pub comment: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct DropTagIndexReq {
        pub space_id: common::types::GraphSpaceID,
        pub index_name: ::std::vec::Vec<::std::primitive::u8>,
        pub if_exists: ::std::primitive::bool,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct GetTagIndexReq {
        pub space_id: common::types::GraphSpaceID,
        pub index_name: ::std::vec::Vec<::std::primitive::u8>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct GetTagIndexResp {
        pub code: crate::types::ErrorCode,
        pub leader: common::types::HostAddr,
        pub item: crate::types::IndexItem,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct ListTagIndexesReq {
        pub space_id: common::types::GraphSpaceID,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct ListTagIndexesResp {
        pub code: crate::types::ErrorCode,
        pub leader: common::types::HostAddr,
        pub items: ::std::vec::Vec<crate::types::IndexItem>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct CreateEdgeIndexReq {
        pub space_id: common::types::GraphSpaceID,
        pub index_name: ::std::vec::Vec<::std::primitive::u8>,
        pub edge_name: ::std::vec::Vec<::std::primitive::u8>,
        pub fields: ::std::vec::Vec<crate::types::IndexFieldDef>,
        pub if_not_exists: ::std::primitive::bool,
        pub comment: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct DropEdgeIndexReq {
        pub space_id: common::types::GraphSpaceID,
        pub index_name: ::std::vec::Vec<::std::primitive::u8>,
        pub if_exists: ::std::primitive::bool,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct GetEdgeIndexReq {
        pub space_id: common::types::GraphSpaceID,
        pub index_name: ::std::vec::Vec<::std::primitive::u8>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct GetEdgeIndexResp {
        pub code: crate::types::ErrorCode,
        pub leader: common::types::HostAddr,
        pub item: crate::types::IndexItem,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct ListEdgeIndexesReq {
        pub space_id: common::types::GraphSpaceID,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct ListEdgeIndexesResp {
        pub code: crate::types::ErrorCode,
        pub leader: common::types::HostAddr,
        pub items: ::std::vec::Vec<crate::types::IndexItem>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct RebuildIndexReq {
        pub space_id: common::types::GraphSpaceID,
        pub index_name: ::std::vec::Vec<::std::primitive::u8>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct CreateUserReq {
        pub account: ::std::vec::Vec<::std::primitive::u8>,
        pub encoded_pwd: ::std::vec::Vec<::std::primitive::u8>,
        pub if_not_exists: ::std::primitive::bool,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct DropUserReq {
        pub account: ::std::vec::Vec<::std::primitive::u8>,
        pub if_exists: ::std::primitive::bool,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct AlterUserReq {
        pub account: ::std::vec::Vec<::std::primitive::u8>,
        pub encoded_pwd: ::std::vec::Vec<::std::primitive::u8>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct GrantRoleReq {
        pub role_item: crate::types::RoleItem,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct RevokeRoleReq {
        pub role_item: crate::types::RoleItem,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct ListUsersReq {
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct ListUsersResp {
        pub code: crate::types::ErrorCode,
        pub leader: common::types::HostAddr,
        pub users: ::std::collections::BTreeMap<::std::vec::Vec<::std::primitive::u8>, ::std::vec::Vec<::std::primitive::u8>>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct ListRolesReq {
        pub space_id: common::types::GraphSpaceID,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct ListRolesResp {
        pub code: crate::types::ErrorCode,
        pub leader: common::types::HostAddr,
        pub roles: ::std::vec::Vec<crate::types::RoleItem>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct GetUserRolesReq {
        pub account: ::std::vec::Vec<::std::primitive::u8>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct ChangePasswordReq {
        pub account: ::std::vec::Vec<::std::primitive::u8>,
        pub new_encoded_pwd: ::std::vec::Vec<::std::primitive::u8>,
        pub old_encoded_pwd: ::std::vec::Vec<::std::primitive::u8>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct BalanceReq {
        pub space_id: ::std::option::Option<common::types::GraphSpaceID>,
        pub id: ::std::option::Option<::std::primitive::i64>,
        pub host_del: ::std::option::Option<::std::vec::Vec<common::types::HostAddr>>,
        pub stop: ::std::option::Option<::std::primitive::bool>,
        pub reset: ::std::option::Option<::std::primitive::bool>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct BalanceTask {
        pub id: ::std::vec::Vec<::std::primitive::u8>,
        pub result: crate::types::TaskResult,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct BalanceResp {
        pub code: crate::types::ErrorCode,
        pub id: ::std::primitive::i64,
        pub leader: common::types::HostAddr,
        pub tasks: ::std::vec::Vec<crate::types::BalanceTask>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct LeaderBalanceReq {
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct ConfigItem {
        pub module: crate::types::ConfigModule,
        pub name: ::std::vec::Vec<::std::primitive::u8>,
        pub mode: crate::types::ConfigMode,
        pub value: common::types::Value,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct RegConfigReq {
        pub items: ::std::vec::Vec<crate::types::ConfigItem>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct GetConfigReq {
        pub item: crate::types::ConfigItem,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct GetConfigResp {
        pub code: crate::types::ErrorCode,
        pub leader: common::types::HostAddr,
        pub items: ::std::vec::Vec<crate::types::ConfigItem>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct SetConfigReq {
        pub item: crate::types::ConfigItem,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct ListConfigsReq {
        pub space: ::std::vec::Vec<::std::primitive::u8>,
        pub module: crate::types::ConfigModule,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct ListConfigsResp {
        pub code: crate::types::ErrorCode,
        pub leader: common::types::HostAddr,
        pub items: ::std::vec::Vec<crate::types::ConfigItem>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct CreateSnapshotReq {
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct DropSnapshotReq {
        pub name: ::std::vec::Vec<::std::primitive::u8>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct ListSnapshotsReq {
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct Snapshot {
        pub name: ::std::vec::Vec<::std::primitive::u8>,
        pub status: crate::types::SnapshotStatus,
        pub hosts: ::std::vec::Vec<::std::primitive::u8>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct ListSnapshotsResp {
        pub code: crate::types::ErrorCode,
        pub leader: common::types::HostAddr,
        pub snapshots: ::std::vec::Vec<crate::types::Snapshot>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct ListIndexStatusReq {
        pub space_id: common::types::GraphSpaceID,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct IndexStatus {
        pub name: ::std::vec::Vec<::std::primitive::u8>,
        pub status: ::std::vec::Vec<::std::primitive::u8>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct ListIndexStatusResp {
        pub code: crate::types::ErrorCode,
        pub leader: common::types::HostAddr,
        pub statuses: ::std::vec::Vec<crate::types::IndexStatus>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct AddZoneReq {
        pub zone_name: ::std::vec::Vec<::std::primitive::u8>,
        pub nodes: ::std::vec::Vec<common::types::HostAddr>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct DropZoneReq {
        pub zone_name: ::std::vec::Vec<::std::primitive::u8>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct AddHostIntoZoneReq {
        pub node: common::types::HostAddr,
        pub zone_name: ::std::vec::Vec<::std::primitive::u8>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct DropHostFromZoneReq {
        pub node: common::types::HostAddr,
        pub zone_name: ::std::vec::Vec<::std::primitive::u8>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct GetZoneReq {
        pub zone_name: ::std::vec::Vec<::std::primitive::u8>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct GetZoneResp {
        pub code: crate::types::ErrorCode,
        pub leader: common::types::HostAddr,
        pub hosts: ::std::vec::Vec<common::types::HostAddr>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct ListZonesReq {
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct Zone {
        pub zone_name: ::std::vec::Vec<::std::primitive::u8>,
        pub nodes: ::std::vec::Vec<common::types::HostAddr>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct ListZonesResp {
        pub code: crate::types::ErrorCode,
        pub leader: common::types::HostAddr,
        pub zones: ::std::vec::Vec<crate::types::Zone>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct AddGroupReq {
        pub group_name: ::std::vec::Vec<::std::primitive::u8>,
        pub zone_names: ::std::vec::Vec<::std::vec::Vec<::std::primitive::u8>>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct DropGroupReq {
        pub group_name: ::std::vec::Vec<::std::primitive::u8>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct AddZoneIntoGroupReq {
        pub zone_name: ::std::vec::Vec<::std::primitive::u8>,
        pub group_name: ::std::vec::Vec<::std::primitive::u8>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct DropZoneFromGroupReq {
        pub zone_name: ::std::vec::Vec<::std::primitive::u8>,
        pub group_name: ::std::vec::Vec<::std::primitive::u8>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct GetGroupReq {
        pub group_name: ::std::vec::Vec<::std::primitive::u8>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct GetGroupResp {
        pub code: crate::types::ErrorCode,
        pub leader: common::types::HostAddr,
        pub zone_names: ::std::vec::Vec<::std::vec::Vec<::std::primitive::u8>>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct ListGroupsReq {
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct Group {
        pub group_name: ::std::vec::Vec<::std::primitive::u8>,
        pub zone_names: ::std::vec::Vec<::std::vec::Vec<::std::primitive::u8>>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct ListGroupsResp {
        pub code: crate::types::ErrorCode,
        pub leader: common::types::HostAddr,
        pub groups: ::std::vec::Vec<crate::types::Group>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct AddListenerReq {
        pub space_id: common::types::GraphSpaceID,
        pub type_: crate::types::ListenerType,
        pub hosts: ::std::vec::Vec<common::types::HostAddr>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct RemoveListenerReq {
        pub space_id: common::types::GraphSpaceID,
        pub type_: crate::types::ListenerType,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct ListListenerReq {
        pub space_id: common::types::GraphSpaceID,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct ListenerInfo {
        pub type_: crate::types::ListenerType,
        pub host: common::types::HostAddr,
        pub part_id: common::types::PartitionID,
        pub status: crate::types::HostStatus,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct ListListenerResp {
        pub code: crate::types::ErrorCode,
        pub leader: common::types::HostAddr,
        pub listeners: ::std::vec::Vec<crate::types::ListenerInfo>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct GetStatisReq {
        pub space_id: common::types::GraphSpaceID,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct GetStatisResp {
        pub code: crate::types::ErrorCode,
        pub leader: common::types::HostAddr,
        pub statis: crate::types::StatisItem,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct CheckpointInfo {
        pub host: common::types::HostAddr,
        pub checkpoint_dir: ::std::vec::Vec<::std::primitive::u8>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct SpaceBackupInfo {
        pub space: crate::types::SpaceDesc,
        pub partition_info: common::types::PartitionBackupInfo,
        pub cp_dirs: ::std::vec::Vec<crate::types::CheckpointInfo>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct BackupMeta {
        pub backup_info: ::std::collections::BTreeMap<common::types::GraphSpaceID, crate::types::SpaceBackupInfo>,
        pub meta_files: ::std::vec::Vec<::std::vec::Vec<::std::primitive::u8>>,
        pub backup_name: ::std::vec::Vec<::std::primitive::u8>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct CreateBackupReq {
        pub spaces: ::std::option::Option<::std::vec::Vec<::std::vec::Vec<::std::primitive::u8>>>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct CreateBackupResp {
        pub code: crate::types::ErrorCode,
        pub leader: common::types::HostAddr,
        pub meta: crate::types::BackupMeta,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct HostPair {
        pub from_host: common::types::HostAddr,
        pub to_host: common::types::HostAddr,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct RestoreMetaReq {
        pub files: ::std::vec::Vec<::std::vec::Vec<::std::primitive::u8>>,
        pub hosts: ::std::vec::Vec<crate::types::HostPair>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct FTClient {
        pub host: common::types::HostAddr,
        pub user: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
        pub pwd: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct SignInFTServiceReq {
        pub type_: crate::types::FTServiceType,
        pub clients: ::std::vec::Vec<crate::types::FTClient>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct SignOutFTServiceReq {
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct ListFTClientsReq {
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct ListFTClientsResp {
        pub code: crate::types::ErrorCode,
        pub leader: common::types::HostAddr,
        pub clients: ::std::vec::Vec<crate::types::FTClient>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct Session {
        pub session_id: common::types::SessionID,
        pub create_time: common::types::Timestamp,
        pub update_time: common::types::Timestamp,
        pub user_name: ::std::vec::Vec<::std::primitive::u8>,
        pub space_name: ::std::vec::Vec<::std::primitive::u8>,
        pub graph_addr: common::types::HostAddr,
        pub timezone: ::std::primitive::i32,
        pub client_ip: ::std::vec::Vec<::std::primitive::u8>,
        pub configs: ::std::collections::BTreeMap<::std::vec::Vec<::std::primitive::u8>, common::types::Value>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct CreateSessionReq {
        pub user: ::std::vec::Vec<::std::primitive::u8>,
        pub graph_addr: common::types::HostAddr,
        pub client_ip: ::std::vec::Vec<::std::primitive::u8>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct CreateSessionResp {
        pub code: crate::types::ErrorCode,
        pub leader: common::types::HostAddr,
        pub session: crate::types::Session,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct UpdateSessionsReq {
        pub sessions: ::std::vec::Vec<crate::types::Session>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct ListSessionsReq {
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct ListSessionsResp {
        pub code: crate::types::ErrorCode,
        pub leader: common::types::HostAddr,
        pub sessions: ::std::vec::Vec<crate::types::Session>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct GetSessionReq {
        pub session_id: common::types::SessionID,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct GetSessionResp {
        pub code: crate::types::ErrorCode,
        pub leader: common::types::HostAddr,
        pub session: crate::types::Session,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct RemoveSessionReq {
        pub session_id: common::types::SessionID,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct ReportTaskReq {
        pub code: crate::types::ErrorCode,
        pub job_id: ::std::primitive::i32,
        pub task_id: ::std::primitive::i32,
        pub statis: ::std::option::Option<crate::types::StatisItem>,
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    pub struct ErrorCode(pub ::std::primitive::i32);

    impl ErrorCode {
        pub const SUCCEEDED: Self = ErrorCode(0i32);
        pub const E_DISCONNECTED: Self = ErrorCode(-1i32);
        pub const E_FAIL_TO_CONNECT: Self = ErrorCode(-2i32);
        pub const E_RPC_FAILURE: Self = ErrorCode(-3i32);
        pub const E_LEADER_CHANGED: Self = ErrorCode(-11i32);
        pub const E_NO_HOSTS: Self = ErrorCode(-21i32);
        pub const E_EXISTED: Self = ErrorCode(-22i32);
        pub const E_NOT_FOUND: Self = ErrorCode(-23i32);
        pub const E_INVALID_HOST: Self = ErrorCode(-24i32);
        pub const E_UNSUPPORTED: Self = ErrorCode(-25i32);
        pub const E_NOT_DROP: Self = ErrorCode(-26i32);
        pub const E_BALANCER_RUNNING: Self = ErrorCode(-27i32);
        pub const E_CONFIG_IMMUTABLE: Self = ErrorCode(-28i32);
        pub const E_CONFLICT: Self = ErrorCode(-29i32);
        pub const E_INVALID_PARM: Self = ErrorCode(-30i32);
        pub const E_WRONGCLUSTER: Self = ErrorCode(-31i32);
        pub const E_STORE_FAILURE: Self = ErrorCode(-32i32);
        pub const E_STORE_SEGMENT_ILLEGAL: Self = ErrorCode(-33i32);
        pub const E_BAD_BALANCE_PLAN: Self = ErrorCode(-34i32);
        pub const E_BALANCED: Self = ErrorCode(-35i32);
        pub const E_NO_RUNNING_BALANCE_PLAN: Self = ErrorCode(-36i32);
        pub const E_NO_VALID_HOST: Self = ErrorCode(-37i32);
        pub const E_CORRUPTTED_BALANCE_PLAN: Self = ErrorCode(-38i32);
        pub const E_NO_INVALID_BALANCE_PLAN: Self = ErrorCode(-39i32);
        pub const E_INVALID_PASSWORD: Self = ErrorCode(-41i32);
        pub const E_IMPROPER_ROLE: Self = ErrorCode(-42i32);
        pub const E_INVALID_PARTITION_NUM: Self = ErrorCode(-43i32);
        pub const E_INVALID_REPLICA_FACTOR: Self = ErrorCode(-44i32);
        pub const E_INVALID_CHARSET: Self = ErrorCode(-45i32);
        pub const E_INVALID_COLLATE: Self = ErrorCode(-46i32);
        pub const E_CHARSET_COLLATE_NOT_MATCH: Self = ErrorCode(-47i32);
        pub const E_SNAPSHOT_FAILURE: Self = ErrorCode(-51i32);
        pub const E_BLOCK_WRITE_FAILURE: Self = ErrorCode(-52i32);
        pub const E_REBUILD_INDEX_FAILURE: Self = ErrorCode(-53i32);
        pub const E_INDEX_WITH_TTL: Self = ErrorCode(-54i32);
        pub const E_ADD_JOB_FAILURE: Self = ErrorCode(-55i32);
        pub const E_STOP_JOB_FAILURE: Self = ErrorCode(-56i32);
        pub const E_SAVE_JOB_FAILURE: Self = ErrorCode(-57i32);
        pub const E_BALANCER_FAILURE: Self = ErrorCode(-58i32);
        pub const E_JOB_NOT_FINISHED: Self = ErrorCode(-59i32);
        pub const E_TASK_REPORT_OUT_DATE: Self = ErrorCode(-60i32);
        pub const E_INVALID_JOB: Self = ErrorCode(-61i32);
        pub const E_BACKUP_FAILURE: Self = ErrorCode(-70i32);
        pub const E_BACKUP_BUILDING_INDEX: Self = ErrorCode(-71i32);
        pub const E_BACKUP_SPACE_NOT_FOUND: Self = ErrorCode(-72i32);
        pub const E_RESTORE_FAILURE: Self = ErrorCode(-80i32);
        pub const E_UNKNOWN: Self = ErrorCode(-99i32);
    }

    impl ::fbthrift::ThriftEnum for ErrorCode {
        fn enumerate() -> &'static [(ErrorCode, &'static str)] {
            &[
                (ErrorCode::SUCCEEDED, "SUCCEEDED"),
                (ErrorCode::E_DISCONNECTED, "E_DISCONNECTED"),
                (ErrorCode::E_FAIL_TO_CONNECT, "E_FAIL_TO_CONNECT"),
                (ErrorCode::E_RPC_FAILURE, "E_RPC_FAILURE"),
                (ErrorCode::E_LEADER_CHANGED, "E_LEADER_CHANGED"),
                (ErrorCode::E_NO_HOSTS, "E_NO_HOSTS"),
                (ErrorCode::E_EXISTED, "E_EXISTED"),
                (ErrorCode::E_NOT_FOUND, "E_NOT_FOUND"),
                (ErrorCode::E_INVALID_HOST, "E_INVALID_HOST"),
                (ErrorCode::E_UNSUPPORTED, "E_UNSUPPORTED"),
                (ErrorCode::E_NOT_DROP, "E_NOT_DROP"),
                (ErrorCode::E_BALANCER_RUNNING, "E_BALANCER_RUNNING"),
                (ErrorCode::E_CONFIG_IMMUTABLE, "E_CONFIG_IMMUTABLE"),
                (ErrorCode::E_CONFLICT, "E_CONFLICT"),
                (ErrorCode::E_INVALID_PARM, "E_INVALID_PARM"),
                (ErrorCode::E_WRONGCLUSTER, "E_WRONGCLUSTER"),
                (ErrorCode::E_STORE_FAILURE, "E_STORE_FAILURE"),
                (ErrorCode::E_STORE_SEGMENT_ILLEGAL, "E_STORE_SEGMENT_ILLEGAL"),
                (ErrorCode::E_BAD_BALANCE_PLAN, "E_BAD_BALANCE_PLAN"),
                (ErrorCode::E_BALANCED, "E_BALANCED"),
                (ErrorCode::E_NO_RUNNING_BALANCE_PLAN, "E_NO_RUNNING_BALANCE_PLAN"),
                (ErrorCode::E_NO_VALID_HOST, "E_NO_VALID_HOST"),
                (ErrorCode::E_CORRUPTTED_BALANCE_PLAN, "E_CORRUPTTED_BALANCE_PLAN"),
                (ErrorCode::E_NO_INVALID_BALANCE_PLAN, "E_NO_INVALID_BALANCE_PLAN"),
                (ErrorCode::E_INVALID_PASSWORD, "E_INVALID_PASSWORD"),
                (ErrorCode::E_IMPROPER_ROLE, "E_IMPROPER_ROLE"),
                (ErrorCode::E_INVALID_PARTITION_NUM, "E_INVALID_PARTITION_NUM"),
                (ErrorCode::E_INVALID_REPLICA_FACTOR, "E_INVALID_REPLICA_FACTOR"),
                (ErrorCode::E_INVALID_CHARSET, "E_INVALID_CHARSET"),
                (ErrorCode::E_INVALID_COLLATE, "E_INVALID_COLLATE"),
                (ErrorCode::E_CHARSET_COLLATE_NOT_MATCH, "E_CHARSET_COLLATE_NOT_MATCH"),
                (ErrorCode::E_SNAPSHOT_FAILURE, "E_SNAPSHOT_FAILURE"),
                (ErrorCode::E_BLOCK_WRITE_FAILURE, "E_BLOCK_WRITE_FAILURE"),
                (ErrorCode::E_REBUILD_INDEX_FAILURE, "E_REBUILD_INDEX_FAILURE"),
                (ErrorCode::E_INDEX_WITH_TTL, "E_INDEX_WITH_TTL"),
                (ErrorCode::E_ADD_JOB_FAILURE, "E_ADD_JOB_FAILURE"),
                (ErrorCode::E_STOP_JOB_FAILURE, "E_STOP_JOB_FAILURE"),
                (ErrorCode::E_SAVE_JOB_FAILURE, "E_SAVE_JOB_FAILURE"),
                (ErrorCode::E_BALANCER_FAILURE, "E_BALANCER_FAILURE"),
                (ErrorCode::E_JOB_NOT_FINISHED, "E_JOB_NOT_FINISHED"),
                (ErrorCode::E_TASK_REPORT_OUT_DATE, "E_TASK_REPORT_OUT_DATE"),
                (ErrorCode::E_INVALID_JOB, "E_INVALID_JOB"),
                (ErrorCode::E_BACKUP_FAILURE, "E_BACKUP_FAILURE"),
                (ErrorCode::E_BACKUP_BUILDING_INDEX, "E_BACKUP_BUILDING_INDEX"),
                (ErrorCode::E_BACKUP_SPACE_NOT_FOUND, "E_BACKUP_SPACE_NOT_FOUND"),
                (ErrorCode::E_RESTORE_FAILURE, "E_RESTORE_FAILURE"),
                (ErrorCode::E_UNKNOWN, "E_UNKNOWN"),
            ]
        }

        fn variants() -> &'static [&'static str] {
            &[
                "SUCCEEDED",
                "E_DISCONNECTED",
                "E_FAIL_TO_CONNECT",
                "E_RPC_FAILURE",
                "E_LEADER_CHANGED",
                "E_NO_HOSTS",
                "E_EXISTED",
                "E_NOT_FOUND",
                "E_INVALID_HOST",
                "E_UNSUPPORTED",
                "E_NOT_DROP",
                "E_BALANCER_RUNNING",
                "E_CONFIG_IMMUTABLE",
                "E_CONFLICT",
                "E_INVALID_PARM",
                "E_WRONGCLUSTER",
                "E_STORE_FAILURE",
                "E_STORE_SEGMENT_ILLEGAL",
                "E_BAD_BALANCE_PLAN",
                "E_BALANCED",
                "E_NO_RUNNING_BALANCE_PLAN",
                "E_NO_VALID_HOST",
                "E_CORRUPTTED_BALANCE_PLAN",
                "E_NO_INVALID_BALANCE_PLAN",
                "E_INVALID_PASSWORD",
                "E_IMPROPER_ROLE",
                "E_INVALID_PARTITION_NUM",
                "E_INVALID_REPLICA_FACTOR",
                "E_INVALID_CHARSET",
                "E_INVALID_COLLATE",
                "E_CHARSET_COLLATE_NOT_MATCH",
                "E_SNAPSHOT_FAILURE",
                "E_BLOCK_WRITE_FAILURE",
                "E_REBUILD_INDEX_FAILURE",
                "E_INDEX_WITH_TTL",
                "E_ADD_JOB_FAILURE",
                "E_STOP_JOB_FAILURE",
                "E_SAVE_JOB_FAILURE",
                "E_BALANCER_FAILURE",
                "E_JOB_NOT_FINISHED",
                "E_TASK_REPORT_OUT_DATE",
                "E_INVALID_JOB",
                "E_BACKUP_FAILURE",
                "E_BACKUP_BUILDING_INDEX",
                "E_BACKUP_SPACE_NOT_FOUND",
                "E_RESTORE_FAILURE",
                "E_UNKNOWN",
            ]
        }

        fn variant_values() -> &'static [ErrorCode] {
            &[
                ErrorCode::SUCCEEDED,
                ErrorCode::E_DISCONNECTED,
                ErrorCode::E_FAIL_TO_CONNECT,
                ErrorCode::E_RPC_FAILURE,
                ErrorCode::E_LEADER_CHANGED,
                ErrorCode::E_NO_HOSTS,
                ErrorCode::E_EXISTED,
                ErrorCode::E_NOT_FOUND,
                ErrorCode::E_INVALID_HOST,
                ErrorCode::E_UNSUPPORTED,
                ErrorCode::E_NOT_DROP,
                ErrorCode::E_BALANCER_RUNNING,
                ErrorCode::E_CONFIG_IMMUTABLE,
                ErrorCode::E_CONFLICT,
                ErrorCode::E_INVALID_PARM,
                ErrorCode::E_WRONGCLUSTER,
                ErrorCode::E_STORE_FAILURE,
                ErrorCode::E_STORE_SEGMENT_ILLEGAL,
                ErrorCode::E_BAD_BALANCE_PLAN,
                ErrorCode::E_BALANCED,
                ErrorCode::E_NO_RUNNING_BALANCE_PLAN,
                ErrorCode::E_NO_VALID_HOST,
                ErrorCode::E_CORRUPTTED_BALANCE_PLAN,
                ErrorCode::E_NO_INVALID_BALANCE_PLAN,
                ErrorCode::E_INVALID_PASSWORD,
                ErrorCode::E_IMPROPER_ROLE,
                ErrorCode::E_INVALID_PARTITION_NUM,
                ErrorCode::E_INVALID_REPLICA_FACTOR,
                ErrorCode::E_INVALID_CHARSET,
                ErrorCode::E_INVALID_COLLATE,
                ErrorCode::E_CHARSET_COLLATE_NOT_MATCH,
                ErrorCode::E_SNAPSHOT_FAILURE,
                ErrorCode::E_BLOCK_WRITE_FAILURE,
                ErrorCode::E_REBUILD_INDEX_FAILURE,
                ErrorCode::E_INDEX_WITH_TTL,
                ErrorCode::E_ADD_JOB_FAILURE,
                ErrorCode::E_STOP_JOB_FAILURE,
                ErrorCode::E_SAVE_JOB_FAILURE,
                ErrorCode::E_BALANCER_FAILURE,
                ErrorCode::E_JOB_NOT_FINISHED,
                ErrorCode::E_TASK_REPORT_OUT_DATE,
                ErrorCode::E_INVALID_JOB,
                ErrorCode::E_BACKUP_FAILURE,
                ErrorCode::E_BACKUP_BUILDING_INDEX,
                ErrorCode::E_BACKUP_SPACE_NOT_FOUND,
                ErrorCode::E_RESTORE_FAILURE,
                ErrorCode::E_UNKNOWN,
            ]
        }
    }

    impl ::std::default::Default for ErrorCode {
        fn default() -> Self {
            ErrorCode(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a ErrorCode> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a ErrorCode) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<ErrorCode> for ::std::primitive::i32 {
        #[inline]
        fn from(x: ErrorCode) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for ErrorCode {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for ErrorCode {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("E_UNKNOWN", -99),
                ("E_RESTORE_FAILURE", -80),
                ("E_BACKUP_SPACE_NOT_FOUND", -72),
                ("E_BACKUP_BUILDING_INDEX", -71),
                ("E_BACKUP_FAILURE", -70),
                ("E_INVALID_JOB", -61),
                ("E_TASK_REPORT_OUT_DATE", -60),
                ("E_JOB_NOT_FINISHED", -59),
                ("E_BALANCER_FAILURE", -58),
                ("E_SAVE_JOB_FAILURE", -57),
                ("E_STOP_JOB_FAILURE", -56),
                ("E_ADD_JOB_FAILURE", -55),
                ("E_INDEX_WITH_TTL", -54),
                ("E_REBUILD_INDEX_FAILURE", -53),
                ("E_BLOCK_WRITE_FAILURE", -52),
                ("E_SNAPSHOT_FAILURE", -51),
                ("E_CHARSET_COLLATE_NOT_MATCH", -47),
                ("E_INVALID_COLLATE", -46),
                ("E_INVALID_CHARSET", -45),
                ("E_INVALID_REPLICA_FACTOR", -44),
                ("E_INVALID_PARTITION_NUM", -43),
                ("E_IMPROPER_ROLE", -42),
                ("E_INVALID_PASSWORD", -41),
                ("E_NO_INVALID_BALANCE_PLAN", -39),
                ("E_CORRUPTTED_BALANCE_PLAN", -38),
                ("E_NO_VALID_HOST", -37),
                ("E_NO_RUNNING_BALANCE_PLAN", -36),
                ("E_BALANCED", -35),
                ("E_BAD_BALANCE_PLAN", -34),
                ("E_STORE_SEGMENT_ILLEGAL", -33),
                ("E_STORE_FAILURE", -32),
                ("E_WRONGCLUSTER", -31),
                ("E_INVALID_PARM", -30),
                ("E_CONFLICT", -29),
                ("E_CONFIG_IMMUTABLE", -28),
                ("E_BALANCER_RUNNING", -27),
                ("E_NOT_DROP", -26),
                ("E_UNSUPPORTED", -25),
                ("E_INVALID_HOST", -24),
                ("E_NOT_FOUND", -23),
                ("E_EXISTED", -22),
                ("E_NO_HOSTS", -21),
                ("E_LEADER_CHANGED", -11),
                ("E_RPC_FAILURE", -3),
                ("E_FAIL_TO_CONNECT", -2),
                ("E_DISCONNECTED", -1),
                ("SUCCEEDED", 0),
            ];
            ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
        }
    }

    impl ::std::fmt::Debug for ErrorCode {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "ErrorCode::{}", self)
        }
    }

    impl ::std::str::FromStr for ErrorCode {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("E_ADD_JOB_FAILURE", -55),
                ("E_BACKUP_BUILDING_INDEX", -71),
                ("E_BACKUP_FAILURE", -70),
                ("E_BACKUP_SPACE_NOT_FOUND", -72),
                ("E_BAD_BALANCE_PLAN", -34),
                ("E_BALANCED", -35),
                ("E_BALANCER_FAILURE", -58),
                ("E_BALANCER_RUNNING", -27),
                ("E_BLOCK_WRITE_FAILURE", -52),
                ("E_CHARSET_COLLATE_NOT_MATCH", -47),
                ("E_CONFIG_IMMUTABLE", -28),
                ("E_CONFLICT", -29),
                ("E_CORRUPTTED_BALANCE_PLAN", -38),
                ("E_DISCONNECTED", -1),
                ("E_EXISTED", -22),
                ("E_FAIL_TO_CONNECT", -2),
                ("E_IMPROPER_ROLE", -42),
                ("E_INDEX_WITH_TTL", -54),
                ("E_INVALID_CHARSET", -45),
                ("E_INVALID_COLLATE", -46),
                ("E_INVALID_HOST", -24),
                ("E_INVALID_JOB", -61),
                ("E_INVALID_PARM", -30),
                ("E_INVALID_PARTITION_NUM", -43),
                ("E_INVALID_PASSWORD", -41),
                ("E_INVALID_REPLICA_FACTOR", -44),
                ("E_JOB_NOT_FINISHED", -59),
                ("E_LEADER_CHANGED", -11),
                ("E_NOT_DROP", -26),
                ("E_NOT_FOUND", -23),
                ("E_NO_HOSTS", -21),
                ("E_NO_INVALID_BALANCE_PLAN", -39),
                ("E_NO_RUNNING_BALANCE_PLAN", -36),
                ("E_NO_VALID_HOST", -37),
                ("E_REBUILD_INDEX_FAILURE", -53),
                ("E_RESTORE_FAILURE", -80),
                ("E_RPC_FAILURE", -3),
                ("E_SAVE_JOB_FAILURE", -57),
                ("E_SNAPSHOT_FAILURE", -51),
                ("E_STOP_JOB_FAILURE", -56),
                ("E_STORE_FAILURE", -32),
                ("E_STORE_SEGMENT_ILLEGAL", -33),
                ("E_TASK_REPORT_OUT_DATE", -60),
                ("E_UNKNOWN", -99),
                ("E_UNSUPPORTED", -25),
                ("E_WRONGCLUSTER", -31),
                ("SUCCEEDED", 0),
            ];
            ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "ErrorCode").map(ErrorCode)
        }
    }

    impl ::fbthrift::GetTType for ErrorCode {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for ErrorCode
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for ErrorCode
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(ErrorCode::from(p.read_i32()?))
        }
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    pub struct AlterSchemaOp(pub ::std::primitive::i32);

    impl AlterSchemaOp {
        pub const ADD: Self = AlterSchemaOp(1i32);
        pub const CHANGE: Self = AlterSchemaOp(2i32);
        pub const DROP: Self = AlterSchemaOp(3i32);
        pub const UNKNOWN: Self = AlterSchemaOp(4i32);
    }

    impl ::fbthrift::ThriftEnum for AlterSchemaOp {
        fn enumerate() -> &'static [(AlterSchemaOp, &'static str)] {
            &[
                (AlterSchemaOp::ADD, "ADD"),
                (AlterSchemaOp::CHANGE, "CHANGE"),
                (AlterSchemaOp::DROP, "DROP"),
                (AlterSchemaOp::UNKNOWN, "UNKNOWN"),
            ]
        }

        fn variants() -> &'static [&'static str] {
            &[
                "ADD",
                "CHANGE",
                "DROP",
                "UNKNOWN",
            ]
        }

        fn variant_values() -> &'static [AlterSchemaOp] {
            &[
                AlterSchemaOp::ADD,
                AlterSchemaOp::CHANGE,
                AlterSchemaOp::DROP,
                AlterSchemaOp::UNKNOWN,
            ]
        }
    }

    impl ::std::default::Default for AlterSchemaOp {
        fn default() -> Self {
            AlterSchemaOp(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a AlterSchemaOp> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a AlterSchemaOp) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<AlterSchemaOp> for ::std::primitive::i32 {
        #[inline]
        fn from(x: AlterSchemaOp) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for AlterSchemaOp {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for AlterSchemaOp {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("ADD", 1),
                ("CHANGE", 2),
                ("DROP", 3),
                ("UNKNOWN", 4),
            ];
            ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
        }
    }

    impl ::std::fmt::Debug for AlterSchemaOp {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "AlterSchemaOp::{}", self)
        }
    }

    impl ::std::str::FromStr for AlterSchemaOp {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("ADD", 1),
                ("CHANGE", 2),
                ("DROP", 3),
                ("UNKNOWN", 4),
            ];
            ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "AlterSchemaOp").map(AlterSchemaOp)
        }
    }

    impl ::fbthrift::GetTType for AlterSchemaOp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for AlterSchemaOp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for AlterSchemaOp
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(AlterSchemaOp::from(p.read_i32()?))
        }
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    pub struct RoleType(pub ::std::primitive::i32);

    impl RoleType {
        pub const GOD: Self = RoleType(1i32);
        pub const ADMIN: Self = RoleType(2i32);
        pub const DBA: Self = RoleType(3i32);
        pub const USER: Self = RoleType(4i32);
        pub const GUEST: Self = RoleType(5i32);
    }

    impl ::fbthrift::ThriftEnum for RoleType {
        fn enumerate() -> &'static [(RoleType, &'static str)] {
            &[
                (RoleType::GOD, "GOD"),
                (RoleType::ADMIN, "ADMIN"),
                (RoleType::DBA, "DBA"),
                (RoleType::USER, "USER"),
                (RoleType::GUEST, "GUEST"),
            ]
        }

        fn variants() -> &'static [&'static str] {
            &[
                "GOD",
                "ADMIN",
                "DBA",
                "USER",
                "GUEST",
            ]
        }

        fn variant_values() -> &'static [RoleType] {
            &[
                RoleType::GOD,
                RoleType::ADMIN,
                RoleType::DBA,
                RoleType::USER,
                RoleType::GUEST,
            ]
        }
    }

    impl ::std::default::Default for RoleType {
        fn default() -> Self {
            RoleType(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a RoleType> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a RoleType) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<RoleType> for ::std::primitive::i32 {
        #[inline]
        fn from(x: RoleType) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for RoleType {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for RoleType {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("GOD", 1),
                ("ADMIN", 2),
                ("DBA", 3),
                ("USER", 4),
                ("GUEST", 5),
            ];
            ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
        }
    }

    impl ::std::fmt::Debug for RoleType {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "RoleType::{}", self)
        }
    }

    impl ::std::str::FromStr for RoleType {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("ADMIN", 2),
                ("DBA", 3),
                ("GOD", 1),
                ("GUEST", 5),
                ("USER", 4),
            ];
            ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "RoleType").map(RoleType)
        }
    }

    impl ::fbthrift::GetTType for RoleType {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for RoleType
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for RoleType
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(RoleType::from(p.read_i32()?))
        }
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    pub struct PropertyType(pub ::std::primitive::i32);

    impl PropertyType {
        pub const UNKNOWN: Self = PropertyType(0i32);
        pub const BOOL: Self = PropertyType(1i32);
        pub const INT64: Self = PropertyType(2i32);
        pub const VID: Self = PropertyType(3i32);
        pub const FLOAT: Self = PropertyType(4i32);
        pub const DOUBLE: Self = PropertyType(5i32);
        pub const STRING: Self = PropertyType(6i32);
        pub const FIXED_STRING: Self = PropertyType(7i32);
        pub const INT8: Self = PropertyType(8i32);
        pub const INT16: Self = PropertyType(9i32);
        pub const INT32: Self = PropertyType(10i32);
        pub const TIMESTAMP: Self = PropertyType(21i32);
        pub const DATE: Self = PropertyType(24i32);
        pub const DATETIME: Self = PropertyType(25i32);
        pub const TIME: Self = PropertyType(26i32);
    }

    impl ::fbthrift::ThriftEnum for PropertyType {
        fn enumerate() -> &'static [(PropertyType, &'static str)] {
            &[
                (PropertyType::UNKNOWN, "UNKNOWN"),
                (PropertyType::BOOL, "BOOL"),
                (PropertyType::INT64, "INT64"),
                (PropertyType::VID, "VID"),
                (PropertyType::FLOAT, "FLOAT"),
                (PropertyType::DOUBLE, "DOUBLE"),
                (PropertyType::STRING, "STRING"),
                (PropertyType::FIXED_STRING, "FIXED_STRING"),
                (PropertyType::INT8, "INT8"),
                (PropertyType::INT16, "INT16"),
                (PropertyType::INT32, "INT32"),
                (PropertyType::TIMESTAMP, "TIMESTAMP"),
                (PropertyType::DATE, "DATE"),
                (PropertyType::DATETIME, "DATETIME"),
                (PropertyType::TIME, "TIME"),
            ]
        }

        fn variants() -> &'static [&'static str] {
            &[
                "UNKNOWN",
                "BOOL",
                "INT64",
                "VID",
                "FLOAT",
                "DOUBLE",
                "STRING",
                "FIXED_STRING",
                "INT8",
                "INT16",
                "INT32",
                "TIMESTAMP",
                "DATE",
                "DATETIME",
                "TIME",
            ]
        }

        fn variant_values() -> &'static [PropertyType] {
            &[
                PropertyType::UNKNOWN,
                PropertyType::BOOL,
                PropertyType::INT64,
                PropertyType::VID,
                PropertyType::FLOAT,
                PropertyType::DOUBLE,
                PropertyType::STRING,
                PropertyType::FIXED_STRING,
                PropertyType::INT8,
                PropertyType::INT16,
                PropertyType::INT32,
                PropertyType::TIMESTAMP,
                PropertyType::DATE,
                PropertyType::DATETIME,
                PropertyType::TIME,
            ]
        }
    }

    impl ::std::default::Default for PropertyType {
        fn default() -> Self {
            PropertyType(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a PropertyType> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a PropertyType) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<PropertyType> for ::std::primitive::i32 {
        #[inline]
        fn from(x: PropertyType) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for PropertyType {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for PropertyType {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("UNKNOWN", 0),
                ("BOOL", 1),
                ("INT64", 2),
                ("VID", 3),
                ("FLOAT", 4),
                ("DOUBLE", 5),
                ("STRING", 6),
                ("FIXED_STRING", 7),
                ("INT8", 8),
                ("INT16", 9),
                ("INT32", 10),
                ("TIMESTAMP", 21),
                ("DATE", 24),
                ("DATETIME", 25),
                ("TIME", 26),
            ];
            ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
        }
    }

    impl ::std::fmt::Debug for PropertyType {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "PropertyType::{}", self)
        }
    }

    impl ::std::str::FromStr for PropertyType {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("BOOL", 1),
                ("DATE", 24),
                ("DATETIME", 25),
                ("DOUBLE", 5),
                ("FIXED_STRING", 7),
                ("FLOAT", 4),
                ("INT16", 9),
                ("INT32", 10),
                ("INT64", 2),
                ("INT8", 8),
                ("STRING", 6),
                ("TIME", 26),
                ("TIMESTAMP", 21),
                ("UNKNOWN", 0),
                ("VID", 3),
            ];
            ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "PropertyType").map(PropertyType)
        }
    }

    impl ::fbthrift::GetTType for PropertyType {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for PropertyType
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for PropertyType
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(PropertyType::from(p.read_i32()?))
        }
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    pub struct IsolationLevel(pub ::std::primitive::i32);

    impl IsolationLevel {
        pub const DEFAULT: Self = IsolationLevel(0i32);
        pub const TOSS: Self = IsolationLevel(1i32);
    }

    impl ::fbthrift::ThriftEnum for IsolationLevel {
        fn enumerate() -> &'static [(IsolationLevel, &'static str)] {
            &[
                (IsolationLevel::DEFAULT, "DEFAULT"),
                (IsolationLevel::TOSS, "TOSS"),
            ]
        }

        fn variants() -> &'static [&'static str] {
            &[
                "DEFAULT",
                "TOSS",
            ]
        }

        fn variant_values() -> &'static [IsolationLevel] {
            &[
                IsolationLevel::DEFAULT,
                IsolationLevel::TOSS,
            ]
        }
    }

    impl ::std::default::Default for IsolationLevel {
        fn default() -> Self {
            IsolationLevel(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a IsolationLevel> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a IsolationLevel) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<IsolationLevel> for ::std::primitive::i32 {
        #[inline]
        fn from(x: IsolationLevel) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for IsolationLevel {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for IsolationLevel {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("DEFAULT", 0),
                ("TOSS", 1),
            ];
            ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
        }
    }

    impl ::std::fmt::Debug for IsolationLevel {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "IsolationLevel::{}", self)
        }
    }

    impl ::std::str::FromStr for IsolationLevel {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("DEFAULT", 0),
                ("TOSS", 1),
            ];
            ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "IsolationLevel").map(IsolationLevel)
        }
    }

    impl ::fbthrift::GetTType for IsolationLevel {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for IsolationLevel
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for IsolationLevel
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(IsolationLevel::from(p.read_i32()?))
        }
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    pub struct HostStatus(pub ::std::primitive::i32);

    impl HostStatus {
        pub const ONLINE: Self = HostStatus(0i32);
        pub const OFFLINE: Self = HostStatus(1i32);
        pub const UNKNOWN: Self = HostStatus(2i32);
    }

    impl ::fbthrift::ThriftEnum for HostStatus {
        fn enumerate() -> &'static [(HostStatus, &'static str)] {
            &[
                (HostStatus::ONLINE, "ONLINE"),
                (HostStatus::OFFLINE, "OFFLINE"),
                (HostStatus::UNKNOWN, "UNKNOWN"),
            ]
        }

        fn variants() -> &'static [&'static str] {
            &[
                "ONLINE",
                "OFFLINE",
                "UNKNOWN",
            ]
        }

        fn variant_values() -> &'static [HostStatus] {
            &[
                HostStatus::ONLINE,
                HostStatus::OFFLINE,
                HostStatus::UNKNOWN,
            ]
        }
    }

    impl ::std::default::Default for HostStatus {
        fn default() -> Self {
            HostStatus(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a HostStatus> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a HostStatus) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<HostStatus> for ::std::primitive::i32 {
        #[inline]
        fn from(x: HostStatus) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for HostStatus {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for HostStatus {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("ONLINE", 0),
                ("OFFLINE", 1),
                ("UNKNOWN", 2),
            ];
            ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
        }
    }

    impl ::std::fmt::Debug for HostStatus {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "HostStatus::{}", self)
        }
    }

    impl ::std::str::FromStr for HostStatus {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("OFFLINE", 1),
                ("ONLINE", 0),
                ("UNKNOWN", 2),
            ];
            ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "HostStatus").map(HostStatus)
        }
    }

    impl ::fbthrift::GetTType for HostStatus {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for HostStatus
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for HostStatus
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(HostStatus::from(p.read_i32()?))
        }
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    pub struct SnapshotStatus(pub ::std::primitive::i32);

    impl SnapshotStatus {
        pub const VALID: Self = SnapshotStatus(0i32);
        pub const INVALID: Self = SnapshotStatus(1i32);
    }

    impl ::fbthrift::ThriftEnum for SnapshotStatus {
        fn enumerate() -> &'static [(SnapshotStatus, &'static str)] {
            &[
                (SnapshotStatus::VALID, "VALID"),
                (SnapshotStatus::INVALID, "INVALID"),
            ]
        }

        fn variants() -> &'static [&'static str] {
            &[
                "VALID",
                "INVALID",
            ]
        }

        fn variant_values() -> &'static [SnapshotStatus] {
            &[
                SnapshotStatus::VALID,
                SnapshotStatus::INVALID,
            ]
        }
    }

    impl ::std::default::Default for SnapshotStatus {
        fn default() -> Self {
            SnapshotStatus(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a SnapshotStatus> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a SnapshotStatus) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<SnapshotStatus> for ::std::primitive::i32 {
        #[inline]
        fn from(x: SnapshotStatus) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for SnapshotStatus {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for SnapshotStatus {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("VALID", 0),
                ("INVALID", 1),
            ];
            ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
        }
    }

    impl ::std::fmt::Debug for SnapshotStatus {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "SnapshotStatus::{}", self)
        }
    }

    impl ::std::str::FromStr for SnapshotStatus {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("INVALID", 1),
                ("VALID", 0),
            ];
            ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "SnapshotStatus").map(SnapshotStatus)
        }
    }

    impl ::fbthrift::GetTType for SnapshotStatus {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for SnapshotStatus
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for SnapshotStatus
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(SnapshotStatus::from(p.read_i32()?))
        }
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    pub struct AdminJobOp(pub ::std::primitive::i32);

    impl AdminJobOp {
        pub const ADD: Self = AdminJobOp(1i32);
        pub const SHOW_All: Self = AdminJobOp(2i32);
        pub const SHOW: Self = AdminJobOp(3i32);
        pub const STOP: Self = AdminJobOp(4i32);
        pub const RECOVER: Self = AdminJobOp(5i32);
    }

    impl ::fbthrift::ThriftEnum for AdminJobOp {
        fn enumerate() -> &'static [(AdminJobOp, &'static str)] {
            &[
                (AdminJobOp::ADD, "ADD"),
                (AdminJobOp::SHOW_All, "SHOW_All"),
                (AdminJobOp::SHOW, "SHOW"),
                (AdminJobOp::STOP, "STOP"),
                (AdminJobOp::RECOVER, "RECOVER"),
            ]
        }

        fn variants() -> &'static [&'static str] {
            &[
                "ADD",
                "SHOW_All",
                "SHOW",
                "STOP",
                "RECOVER",
            ]
        }

        fn variant_values() -> &'static [AdminJobOp] {
            &[
                AdminJobOp::ADD,
                AdminJobOp::SHOW_All,
                AdminJobOp::SHOW,
                AdminJobOp::STOP,
                AdminJobOp::RECOVER,
            ]
        }
    }

    impl ::std::default::Default for AdminJobOp {
        fn default() -> Self {
            AdminJobOp(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a AdminJobOp> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a AdminJobOp) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<AdminJobOp> for ::std::primitive::i32 {
        #[inline]
        fn from(x: AdminJobOp) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for AdminJobOp {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for AdminJobOp {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("ADD", 1),
                ("SHOW_All", 2),
                ("SHOW", 3),
                ("STOP", 4),
                ("RECOVER", 5),
            ];
            ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
        }
    }

    impl ::std::fmt::Debug for AdminJobOp {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "AdminJobOp::{}", self)
        }
    }

    impl ::std::str::FromStr for AdminJobOp {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("ADD", 1),
                ("RECOVER", 5),
                ("SHOW", 3),
                ("SHOW_All", 2),
                ("STOP", 4),
            ];
            ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "AdminJobOp").map(AdminJobOp)
        }
    }

    impl ::fbthrift::GetTType for AdminJobOp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for AdminJobOp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for AdminJobOp
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(AdminJobOp::from(p.read_i32()?))
        }
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    pub struct AdminCmd(pub ::std::primitive::i32);

    impl AdminCmd {
        pub const COMPACT: Self = AdminCmd(0i32);
        pub const FLUSH: Self = AdminCmd(1i32);
        pub const REBUILD_TAG_INDEX: Self = AdminCmd(2i32);
        pub const REBUILD_EDGE_INDEX: Self = AdminCmd(3i32);
        pub const STATS: Self = AdminCmd(4i32);
        pub const DATA_BALANCE: Self = AdminCmd(5i32);
        pub const DOWELOAD: Self = AdminCmd(6i32);
        pub const INGEST: Self = AdminCmd(7i32);
        pub const UNKNOWN: Self = AdminCmd(99i32);
    }

    impl ::fbthrift::ThriftEnum for AdminCmd {
        fn enumerate() -> &'static [(AdminCmd, &'static str)] {
            &[
                (AdminCmd::COMPACT, "COMPACT"),
                (AdminCmd::FLUSH, "FLUSH"),
                (AdminCmd::REBUILD_TAG_INDEX, "REBUILD_TAG_INDEX"),
                (AdminCmd::REBUILD_EDGE_INDEX, "REBUILD_EDGE_INDEX"),
                (AdminCmd::STATS, "STATS"),
                (AdminCmd::DATA_BALANCE, "DATA_BALANCE"),
                (AdminCmd::DOWELOAD, "DOWELOAD"),
                (AdminCmd::INGEST, "INGEST"),
                (AdminCmd::UNKNOWN, "UNKNOWN"),
            ]
        }

        fn variants() -> &'static [&'static str] {
            &[
                "COMPACT",
                "FLUSH",
                "REBUILD_TAG_INDEX",
                "REBUILD_EDGE_INDEX",
                "STATS",
                "DATA_BALANCE",
                "DOWELOAD",
                "INGEST",
                "UNKNOWN",
            ]
        }

        fn variant_values() -> &'static [AdminCmd] {
            &[
                AdminCmd::COMPACT,
                AdminCmd::FLUSH,
                AdminCmd::REBUILD_TAG_INDEX,
                AdminCmd::REBUILD_EDGE_INDEX,
                AdminCmd::STATS,
                AdminCmd::DATA_BALANCE,
                AdminCmd::DOWELOAD,
                AdminCmd::INGEST,
                AdminCmd::UNKNOWN,
            ]
        }
    }

    impl ::std::default::Default for AdminCmd {
        fn default() -> Self {
            AdminCmd(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a AdminCmd> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a AdminCmd) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<AdminCmd> for ::std::primitive::i32 {
        #[inline]
        fn from(x: AdminCmd) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for AdminCmd {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for AdminCmd {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("COMPACT", 0),
                ("FLUSH", 1),
                ("REBUILD_TAG_INDEX", 2),
                ("REBUILD_EDGE_INDEX", 3),
                ("STATS", 4),
                ("DATA_BALANCE", 5),
                ("DOWELOAD", 6),
                ("INGEST", 7),
                ("UNKNOWN", 99),
            ];
            ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
        }
    }

    impl ::std::fmt::Debug for AdminCmd {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "AdminCmd::{}", self)
        }
    }

    impl ::std::str::FromStr for AdminCmd {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("COMPACT", 0),
                ("DATA_BALANCE", 5),
                ("DOWELOAD", 6),
                ("FLUSH", 1),
                ("INGEST", 7),
                ("REBUILD_EDGE_INDEX", 3),
                ("REBUILD_TAG_INDEX", 2),
                ("STATS", 4),
                ("UNKNOWN", 99),
            ];
            ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "AdminCmd").map(AdminCmd)
        }
    }

    impl ::fbthrift::GetTType for AdminCmd {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for AdminCmd
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for AdminCmd
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(AdminCmd::from(p.read_i32()?))
        }
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    pub struct JobStatus(pub ::std::primitive::i32);

    impl JobStatus {
        pub const QUEUE: Self = JobStatus(1i32);
        pub const RUNNING: Self = JobStatus(2i32);
        pub const FINISHED: Self = JobStatus(3i32);
        pub const FAILED: Self = JobStatus(4i32);
        pub const STOPPED: Self = JobStatus(5i32);
        pub const INVALID: Self = JobStatus(255i32);
    }

    impl ::fbthrift::ThriftEnum for JobStatus {
        fn enumerate() -> &'static [(JobStatus, &'static str)] {
            &[
                (JobStatus::QUEUE, "QUEUE"),
                (JobStatus::RUNNING, "RUNNING"),
                (JobStatus::FINISHED, "FINISHED"),
                (JobStatus::FAILED, "FAILED"),
                (JobStatus::STOPPED, "STOPPED"),
                (JobStatus::INVALID, "INVALID"),
            ]
        }

        fn variants() -> &'static [&'static str] {
            &[
                "QUEUE",
                "RUNNING",
                "FINISHED",
                "FAILED",
                "STOPPED",
                "INVALID",
            ]
        }

        fn variant_values() -> &'static [JobStatus] {
            &[
                JobStatus::QUEUE,
                JobStatus::RUNNING,
                JobStatus::FINISHED,
                JobStatus::FAILED,
                JobStatus::STOPPED,
                JobStatus::INVALID,
            ]
        }
    }

    impl ::std::default::Default for JobStatus {
        fn default() -> Self {
            JobStatus(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a JobStatus> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a JobStatus) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<JobStatus> for ::std::primitive::i32 {
        #[inline]
        fn from(x: JobStatus) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for JobStatus {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for JobStatus {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("QUEUE", 1),
                ("RUNNING", 2),
                ("FINISHED", 3),
                ("FAILED", 4),
                ("STOPPED", 5),
                ("INVALID", 255),
            ];
            ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
        }
    }

    impl ::std::fmt::Debug for JobStatus {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "JobStatus::{}", self)
        }
    }

    impl ::std::str::FromStr for JobStatus {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("FAILED", 4),
                ("FINISHED", 3),
                ("INVALID", 255),
                ("QUEUE", 1),
                ("RUNNING", 2),
                ("STOPPED", 5),
            ];
            ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "JobStatus").map(JobStatus)
        }
    }

    impl ::fbthrift::GetTType for JobStatus {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for JobStatus
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for JobStatus
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(JobStatus::from(p.read_i32()?))
        }
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    pub struct ListHostType(pub ::std::primitive::i32);

    impl ListHostType {
        pub const ALLOC: Self = ListHostType(0i32);
        pub const GRAPH: Self = ListHostType(1i32);
        pub const META: Self = ListHostType(2i32);
        pub const STORAGE: Self = ListHostType(3i32);
    }

    impl ::fbthrift::ThriftEnum for ListHostType {
        fn enumerate() -> &'static [(ListHostType, &'static str)] {
            &[
                (ListHostType::ALLOC, "ALLOC"),
                (ListHostType::GRAPH, "GRAPH"),
                (ListHostType::META, "META"),
                (ListHostType::STORAGE, "STORAGE"),
            ]
        }

        fn variants() -> &'static [&'static str] {
            &[
                "ALLOC",
                "GRAPH",
                "META",
                "STORAGE",
            ]
        }

        fn variant_values() -> &'static [ListHostType] {
            &[
                ListHostType::ALLOC,
                ListHostType::GRAPH,
                ListHostType::META,
                ListHostType::STORAGE,
            ]
        }
    }

    impl ::std::default::Default for ListHostType {
        fn default() -> Self {
            ListHostType(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a ListHostType> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a ListHostType) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<ListHostType> for ::std::primitive::i32 {
        #[inline]
        fn from(x: ListHostType) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for ListHostType {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for ListHostType {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("ALLOC", 0),
                ("GRAPH", 1),
                ("META", 2),
                ("STORAGE", 3),
            ];
            ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
        }
    }

    impl ::std::fmt::Debug for ListHostType {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "ListHostType::{}", self)
        }
    }

    impl ::std::str::FromStr for ListHostType {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("ALLOC", 0),
                ("GRAPH", 1),
                ("META", 2),
                ("STORAGE", 3),
            ];
            ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "ListHostType").map(ListHostType)
        }
    }

    impl ::fbthrift::GetTType for ListHostType {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for ListHostType
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for ListHostType
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(ListHostType::from(p.read_i32()?))
        }
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    pub struct HostRole(pub ::std::primitive::i32);

    impl HostRole {
        pub const GRAPH: Self = HostRole(0i32);
        pub const META: Self = HostRole(1i32);
        pub const STORAGE: Self = HostRole(2i32);
        pub const LISTENER: Self = HostRole(3i32);
        pub const UNKNOWN: Self = HostRole(4i32);
    }

    impl ::fbthrift::ThriftEnum for HostRole {
        fn enumerate() -> &'static [(HostRole, &'static str)] {
            &[
                (HostRole::GRAPH, "GRAPH"),
                (HostRole::META, "META"),
                (HostRole::STORAGE, "STORAGE"),
                (HostRole::LISTENER, "LISTENER"),
                (HostRole::UNKNOWN, "UNKNOWN"),
            ]
        }

        fn variants() -> &'static [&'static str] {
            &[
                "GRAPH",
                "META",
                "STORAGE",
                "LISTENER",
                "UNKNOWN",
            ]
        }

        fn variant_values() -> &'static [HostRole] {
            &[
                HostRole::GRAPH,
                HostRole::META,
                HostRole::STORAGE,
                HostRole::LISTENER,
                HostRole::UNKNOWN,
            ]
        }
    }

    impl ::std::default::Default for HostRole {
        fn default() -> Self {
            HostRole(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a HostRole> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a HostRole) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<HostRole> for ::std::primitive::i32 {
        #[inline]
        fn from(x: HostRole) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for HostRole {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for HostRole {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("GRAPH", 0),
                ("META", 1),
                ("STORAGE", 2),
                ("LISTENER", 3),
                ("UNKNOWN", 4),
            ];
            ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
        }
    }

    impl ::std::fmt::Debug for HostRole {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "HostRole::{}", self)
        }
    }

    impl ::std::str::FromStr for HostRole {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("GRAPH", 0),
                ("LISTENER", 3),
                ("META", 1),
                ("STORAGE", 2),
                ("UNKNOWN", 4),
            ];
            ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "HostRole").map(HostRole)
        }
    }

    impl ::fbthrift::GetTType for HostRole {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for HostRole
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for HostRole
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(HostRole::from(p.read_i32()?))
        }
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    pub struct TaskResult(pub ::std::primitive::i32);

    impl TaskResult {
        pub const SUCCEEDED: Self = TaskResult(0i32);
        pub const FAILED: Self = TaskResult(1i32);
        pub const IN_PROGRESS: Self = TaskResult(2i32);
        pub const INVALID: Self = TaskResult(3i32);
    }

    impl ::fbthrift::ThriftEnum for TaskResult {
        fn enumerate() -> &'static [(TaskResult, &'static str)] {
            &[
                (TaskResult::SUCCEEDED, "SUCCEEDED"),
                (TaskResult::FAILED, "FAILED"),
                (TaskResult::IN_PROGRESS, "IN_PROGRESS"),
                (TaskResult::INVALID, "INVALID"),
            ]
        }

        fn variants() -> &'static [&'static str] {
            &[
                "SUCCEEDED",
                "FAILED",
                "IN_PROGRESS",
                "INVALID",
            ]
        }

        fn variant_values() -> &'static [TaskResult] {
            &[
                TaskResult::SUCCEEDED,
                TaskResult::FAILED,
                TaskResult::IN_PROGRESS,
                TaskResult::INVALID,
            ]
        }
    }

    impl ::std::default::Default for TaskResult {
        fn default() -> Self {
            TaskResult(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a TaskResult> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a TaskResult) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<TaskResult> for ::std::primitive::i32 {
        #[inline]
        fn from(x: TaskResult) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for TaskResult {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for TaskResult {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("SUCCEEDED", 0),
                ("FAILED", 1),
                ("IN_PROGRESS", 2),
                ("INVALID", 3),
            ];
            ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
        }
    }

    impl ::std::fmt::Debug for TaskResult {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "TaskResult::{}", self)
        }
    }

    impl ::std::str::FromStr for TaskResult {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("FAILED", 1),
                ("INVALID", 3),
                ("IN_PROGRESS", 2),
                ("SUCCEEDED", 0),
            ];
            ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "TaskResult").map(TaskResult)
        }
    }

    impl ::fbthrift::GetTType for TaskResult {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for TaskResult
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for TaskResult
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(TaskResult::from(p.read_i32()?))
        }
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    pub struct ConfigModule(pub ::std::primitive::i32);

    impl ConfigModule {
        pub const UNKNOWN: Self = ConfigModule(0i32);
        pub const ALL: Self = ConfigModule(1i32);
        pub const GRAPH: Self = ConfigModule(2i32);
        pub const META: Self = ConfigModule(3i32);
        pub const STORAGE: Self = ConfigModule(4i32);
    }

    impl ::fbthrift::ThriftEnum for ConfigModule {
        fn enumerate() -> &'static [(ConfigModule, &'static str)] {
            &[
                (ConfigModule::UNKNOWN, "UNKNOWN"),
                (ConfigModule::ALL, "ALL"),
                (ConfigModule::GRAPH, "GRAPH"),
                (ConfigModule::META, "META"),
                (ConfigModule::STORAGE, "STORAGE"),
            ]
        }

        fn variants() -> &'static [&'static str] {
            &[
                "UNKNOWN",
                "ALL",
                "GRAPH",
                "META",
                "STORAGE",
            ]
        }

        fn variant_values() -> &'static [ConfigModule] {
            &[
                ConfigModule::UNKNOWN,
                ConfigModule::ALL,
                ConfigModule::GRAPH,
                ConfigModule::META,
                ConfigModule::STORAGE,
            ]
        }
    }

    impl ::std::default::Default for ConfigModule {
        fn default() -> Self {
            ConfigModule(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a ConfigModule> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a ConfigModule) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<ConfigModule> for ::std::primitive::i32 {
        #[inline]
        fn from(x: ConfigModule) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for ConfigModule {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for ConfigModule {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("UNKNOWN", 0),
                ("ALL", 1),
                ("GRAPH", 2),
                ("META", 3),
                ("STORAGE", 4),
            ];
            ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
        }
    }

    impl ::std::fmt::Debug for ConfigModule {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "ConfigModule::{}", self)
        }
    }

    impl ::std::str::FromStr for ConfigModule {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("ALL", 1),
                ("GRAPH", 2),
                ("META", 3),
                ("STORAGE", 4),
                ("UNKNOWN", 0),
            ];
            ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "ConfigModule").map(ConfigModule)
        }
    }

    impl ::fbthrift::GetTType for ConfigModule {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for ConfigModule
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for ConfigModule
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(ConfigModule::from(p.read_i32()?))
        }
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    pub struct ConfigMode(pub ::std::primitive::i32);

    impl ConfigMode {
        pub const IMMUTABLE: Self = ConfigMode(0i32);
        pub const REBOOT: Self = ConfigMode(1i32);
        pub const MUTABLE: Self = ConfigMode(2i32);
        pub const IGNORED: Self = ConfigMode(3i32);
    }

    impl ::fbthrift::ThriftEnum for ConfigMode {
        fn enumerate() -> &'static [(ConfigMode, &'static str)] {
            &[
                (ConfigMode::IMMUTABLE, "IMMUTABLE"),
                (ConfigMode::REBOOT, "REBOOT"),
                (ConfigMode::MUTABLE, "MUTABLE"),
                (ConfigMode::IGNORED, "IGNORED"),
            ]
        }

        fn variants() -> &'static [&'static str] {
            &[
                "IMMUTABLE",
                "REBOOT",
                "MUTABLE",
                "IGNORED",
            ]
        }

        fn variant_values() -> &'static [ConfigMode] {
            &[
                ConfigMode::IMMUTABLE,
                ConfigMode::REBOOT,
                ConfigMode::MUTABLE,
                ConfigMode::IGNORED,
            ]
        }
    }

    impl ::std::default::Default for ConfigMode {
        fn default() -> Self {
            ConfigMode(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a ConfigMode> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a ConfigMode) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<ConfigMode> for ::std::primitive::i32 {
        #[inline]
        fn from(x: ConfigMode) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for ConfigMode {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for ConfigMode {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("IMMUTABLE", 0),
                ("REBOOT", 1),
                ("MUTABLE", 2),
                ("IGNORED", 3),
            ];
            ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
        }
    }

    impl ::std::fmt::Debug for ConfigMode {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "ConfigMode::{}", self)
        }
    }

    impl ::std::str::FromStr for ConfigMode {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("IGNORED", 3),
                ("IMMUTABLE", 0),
                ("MUTABLE", 2),
                ("REBOOT", 1),
            ];
            ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "ConfigMode").map(ConfigMode)
        }
    }

    impl ::fbthrift::GetTType for ConfigMode {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for ConfigMode
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for ConfigMode
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(ConfigMode::from(p.read_i32()?))
        }
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    pub struct ListenerType(pub ::std::primitive::i32);

    impl ListenerType {
        pub const UNKNOWN: Self = ListenerType(0i32);
        pub const ELASTICSEARCH: Self = ListenerType(1i32);
    }

    impl ::fbthrift::ThriftEnum for ListenerType {
        fn enumerate() -> &'static [(ListenerType, &'static str)] {
            &[
                (ListenerType::UNKNOWN, "UNKNOWN"),
                (ListenerType::ELASTICSEARCH, "ELASTICSEARCH"),
            ]
        }

        fn variants() -> &'static [&'static str] {
            &[
                "UNKNOWN",
                "ELASTICSEARCH",
            ]
        }

        fn variant_values() -> &'static [ListenerType] {
            &[
                ListenerType::UNKNOWN,
                ListenerType::ELASTICSEARCH,
            ]
        }
    }

    impl ::std::default::Default for ListenerType {
        fn default() -> Self {
            ListenerType(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a ListenerType> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a ListenerType) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<ListenerType> for ::std::primitive::i32 {
        #[inline]
        fn from(x: ListenerType) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for ListenerType {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for ListenerType {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("UNKNOWN", 0),
                ("ELASTICSEARCH", 1),
            ];
            ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
        }
    }

    impl ::std::fmt::Debug for ListenerType {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "ListenerType::{}", self)
        }
    }

    impl ::std::str::FromStr for ListenerType {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("ELASTICSEARCH", 1),
                ("UNKNOWN", 0),
            ];
            ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "ListenerType").map(ListenerType)
        }
    }

    impl ::fbthrift::GetTType for ListenerType {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for ListenerType
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for ListenerType
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(ListenerType::from(p.read_i32()?))
        }
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    pub struct FTServiceType(pub ::std::primitive::i32);

    impl FTServiceType {
        pub const ELASTICSEARCH: Self = FTServiceType(1i32);
    }

    impl ::fbthrift::ThriftEnum for FTServiceType {
        fn enumerate() -> &'static [(FTServiceType, &'static str)] {
            &[
                (FTServiceType::ELASTICSEARCH, "ELASTICSEARCH"),
            ]
        }

        fn variants() -> &'static [&'static str] {
            &[
                "ELASTICSEARCH",
            ]
        }

        fn variant_values() -> &'static [FTServiceType] {
            &[
                FTServiceType::ELASTICSEARCH,
            ]
        }
    }

    impl ::std::default::Default for FTServiceType {
        fn default() -> Self {
            FTServiceType(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a FTServiceType> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a FTServiceType) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<FTServiceType> for ::std::primitive::i32 {
        #[inline]
        fn from(x: FTServiceType) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for FTServiceType {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for FTServiceType {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("ELASTICSEARCH", 1),
            ];
            ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
        }
    }

    impl ::std::fmt::Debug for FTServiceType {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "FTServiceType::{}", self)
        }
    }

    impl ::std::str::FromStr for FTServiceType {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("ELASTICSEARCH", 1),
            ];
            ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "FTServiceType").map(FTServiceType)
        }
    }

    impl ::fbthrift::GetTType for FTServiceType {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for FTServiceType
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for FTServiceType
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(FTServiceType::from(p.read_i32()?))
        }
    }




    impl ::std::default::Default for ID {
        fn default() -> Self {
            Self::UnknownField(-1)
        }
    }

    impl ::fbthrift::GetTType for ID {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for ID
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ID");
            match self {
                ID::space_id(inner) => {
                    p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                ID::tag_id(inner) => {
                    p.write_field_begin("tag_id", ::fbthrift::TType::I32, 2);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                ID::edge_type(inner) => {
                    p.write_field_begin("edge_type", ::fbthrift::TType::I32, 3);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                ID::index_id(inner) => {
                    p.write_field_begin("index_id", ::fbthrift::TType::I32, 4);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                ID::cluster_id(inner) => {
                    p.write_field_begin("cluster_id", ::fbthrift::TType::I64, 5);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                ID::UnknownField(x) => {
                    p.write_field_begin("UnknownField", ::fbthrift::TType::I32, *x as ::std::primitive::i16);
                    x.write(p);
                    p.write_field_end();
                }
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for ID
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("cluster_id", ::fbthrift::TType::I64, 5),
                ::fbthrift::Field::new("edge_type", ::fbthrift::TType::I32, 3),
                ::fbthrift::Field::new("index_id", ::fbthrift::TType::I32, 4),
                ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("tag_id", ::fbthrift::TType::I32, 2),
            ];
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::option::Option::None;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32, once) {
                    (::fbthrift::TType::Stop, _, _) => break,
                    (::fbthrift::TType::I32, 1, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(ID::space_id(::fbthrift::Deserialize::read(p)?));
                    }
                    (::fbthrift::TType::I32, 2, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(ID::tag_id(::fbthrift::Deserialize::read(p)?));
                    }
                    (::fbthrift::TType::I32, 3, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(ID::edge_type(::fbthrift::Deserialize::read(p)?));
                    }
                    (::fbthrift::TType::I32, 4, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(ID::index_id(::fbthrift::Deserialize::read(p)?));
                    }
                    (::fbthrift::TType::I64, 5, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(ID::cluster_id(::fbthrift::Deserialize::read(p)?));
                    }
                    (fty, _, false) => p.skip(fty)?,
                    (badty, badid, true) => return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                        format!(
                            "unwanted extra union {} field ty {:?} id {}",
                            "ID",
                            badty,
                            badid,
                        ),
                    ))),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(alt.unwrap_or_default())
        }
    }

    impl ::std::default::Default for self::ColumnTypeDef {
        fn default() -> Self {
            Self {
                type_: ::std::default::Default::default(),
                type_length: ::std::option::Option::Some(0),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ColumnTypeDef {}
    unsafe impl ::std::marker::Sync for self::ColumnTypeDef {}

    impl ::fbthrift::GetTType for self::ColumnTypeDef {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ColumnTypeDef
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ColumnTypeDef");
            p.write_field_begin("type", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.type_, p);
            p.write_field_end();
            if let ::std::option::Option::Some(some) = &self.type_length {
                p.write_field_begin("type_length", ::fbthrift::TType::I16, 2);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ColumnTypeDef
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("type", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("type_length", ::fbthrift::TType::I16, 2),
            ];
            let mut field_type = ::std::option::Option::None;
            let mut field_type_length = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_type = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I16, 2) => field_type_length = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                type_: field_type.unwrap_or_default(),
                type_length: field_type_length,
            })
        }
    }


    impl ::std::default::Default for self::ColumnDef {
        fn default() -> Self {
            Self {
                name: ::std::default::Default::default(),
                type_: ::std::default::Default::default(),
                default_value: ::std::option::Option::None,
                nullable: ::std::option::Option::Some(false),
                comment: ::std::option::Option::None,
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ColumnDef {}
    unsafe impl ::std::marker::Sync for self::ColumnDef {}

    impl ::fbthrift::GetTType for self::ColumnDef {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ColumnDef
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ColumnDef");
            p.write_field_begin("name", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.name, p);
            p.write_field_end();
            p.write_field_begin("type", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.type_, p);
            p.write_field_end();
            if let ::std::option::Option::Some(some) = &self.default_value {
                p.write_field_begin("default_value", ::fbthrift::TType::String, 3);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.nullable {
                p.write_field_begin("nullable", ::fbthrift::TType::Bool, 4);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.comment {
                p.write_field_begin("comment", ::fbthrift::TType::String, 5);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ColumnDef
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("comment", ::fbthrift::TType::String, 5),
                ::fbthrift::Field::new("default_value", ::fbthrift::TType::String, 3),
                ::fbthrift::Field::new("name", ::fbthrift::TType::String, 1),
                ::fbthrift::Field::new("nullable", ::fbthrift::TType::Bool, 4),
                ::fbthrift::Field::new("type", ::fbthrift::TType::Struct, 2),
            ];
            let mut field_name = ::std::option::Option::None;
            let mut field_type = ::std::option::Option::None;
            let mut field_default_value = ::std::option::Option::None;
            let mut field_nullable = ::std::option::Option::None;
            let mut field_comment = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_type = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 3) => field_default_value = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 4) => field_nullable = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 5) => field_comment = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                name: field_name.unwrap_or_default(),
                type_: field_type.unwrap_or_default(),
                default_value: field_default_value,
                nullable: field_nullable,
                comment: field_comment,
            })
        }
    }


    impl ::std::default::Default for self::SchemaProp {
        fn default() -> Self {
            Self {
                ttl_duration: ::std::option::Option::None,
                ttl_col: ::std::option::Option::None,
                comment: ::std::option::Option::None,
            }
        }
    }

    unsafe impl ::std::marker::Send for self::SchemaProp {}
    unsafe impl ::std::marker::Sync for self::SchemaProp {}

    impl ::fbthrift::GetTType for self::SchemaProp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::SchemaProp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("SchemaProp");
            if let ::std::option::Option::Some(some) = &self.ttl_duration {
                p.write_field_begin("ttl_duration", ::fbthrift::TType::I64, 1);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.ttl_col {
                p.write_field_begin("ttl_col", ::fbthrift::TType::String, 2);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.comment {
                p.write_field_begin("comment", ::fbthrift::TType::String, 3);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::SchemaProp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("comment", ::fbthrift::TType::String, 3),
                ::fbthrift::Field::new("ttl_col", ::fbthrift::TType::String, 2),
                ::fbthrift::Field::new("ttl_duration", ::fbthrift::TType::I64, 1),
            ];
            let mut field_ttl_duration = ::std::option::Option::None;
            let mut field_ttl_col = ::std::option::Option::None;
            let mut field_comment = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I64, 1) => field_ttl_duration = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_ttl_col = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 3) => field_comment = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                ttl_duration: field_ttl_duration,
                ttl_col: field_ttl_col,
                comment: field_comment,
            })
        }
    }


    impl ::std::default::Default for self::Schema {
        fn default() -> Self {
            Self {
                columns: ::std::default::Default::default(),
                schema_prop: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::Schema {}
    unsafe impl ::std::marker::Sync for self::Schema {}

    impl ::fbthrift::GetTType for self::Schema {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::Schema
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("Schema");
            p.write_field_begin("columns", ::fbthrift::TType::List, 1);
            ::fbthrift::Serialize::write(&self.columns, p);
            p.write_field_end();
            p.write_field_begin("schema_prop", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.schema_prop, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::Schema
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("columns", ::fbthrift::TType::List, 1),
                ::fbthrift::Field::new("schema_prop", ::fbthrift::TType::Struct, 2),
            ];
            let mut field_columns = ::std::option::Option::None;
            let mut field_schema_prop = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::List, 1) => field_columns = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_schema_prop = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                columns: field_columns.unwrap_or_default(),
                schema_prop: field_schema_prop.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::IdName {
        fn default() -> Self {
            Self {
                id: ::std::default::Default::default(),
                name: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::IdName {}
    unsafe impl ::std::marker::Sync for self::IdName {}

    impl ::fbthrift::GetTType for self::IdName {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::IdName
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("IdName");
            p.write_field_begin("id", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(&self.id, p);
            p.write_field_end();
            p.write_field_begin("name", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.name, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::IdName
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("id", ::fbthrift::TType::Struct, 1),
                ::fbthrift::Field::new("name", ::fbthrift::TType::String, 2),
            ];
            let mut field_id = ::std::option::Option::None;
            let mut field_name = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                id: field_id.unwrap_or_default(),
                name: field_name.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::SpaceDesc {
        fn default() -> Self {
            Self {
                space_name: ::std::default::Default::default(),
                partition_num: 0,
                replica_factor: 0,
                charset_name: ::std::default::Default::default(),
                collate_name: ::std::default::Default::default(),
                vid_type: crate::types::ColumnTypeDef {
                    type_: crate::types::PropertyType::FIXED_STRING,
                    type_length: ::std::option::Option::Some(8),
                },
                group_name: ::std::option::Option::None,
                isolation_level: ::std::option::Option::None,
                comment: ::std::option::Option::None,
            }
        }
    }

    unsafe impl ::std::marker::Send for self::SpaceDesc {}
    unsafe impl ::std::marker::Sync for self::SpaceDesc {}

    impl ::fbthrift::GetTType for self::SpaceDesc {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::SpaceDesc
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("SpaceDesc");
            p.write_field_begin("space_name", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.space_name, p);
            p.write_field_end();
            p.write_field_begin("partition_num", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.partition_num, p);
            p.write_field_end();
            p.write_field_begin("replica_factor", ::fbthrift::TType::I32, 3);
            ::fbthrift::Serialize::write(&self.replica_factor, p);
            p.write_field_end();
            p.write_field_begin("charset_name", ::fbthrift::TType::String, 4);
            ::fbthrift::Serialize::write(&self.charset_name, p);
            p.write_field_end();
            p.write_field_begin("collate_name", ::fbthrift::TType::String, 5);
            ::fbthrift::Serialize::write(&self.collate_name, p);
            p.write_field_end();
            p.write_field_begin("vid_type", ::fbthrift::TType::Struct, 6);
            ::fbthrift::Serialize::write(&self.vid_type, p);
            p.write_field_end();
            if let ::std::option::Option::Some(some) = &self.group_name {
                p.write_field_begin("group_name", ::fbthrift::TType::String, 7);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.isolation_level {
                p.write_field_begin("isolation_level", ::fbthrift::TType::I32, 8);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.comment {
                p.write_field_begin("comment", ::fbthrift::TType::String, 9);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::SpaceDesc
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("charset_name", ::fbthrift::TType::String, 4),
                ::fbthrift::Field::new("collate_name", ::fbthrift::TType::String, 5),
                ::fbthrift::Field::new("comment", ::fbthrift::TType::String, 9),
                ::fbthrift::Field::new("group_name", ::fbthrift::TType::String, 7),
                ::fbthrift::Field::new("isolation_level", ::fbthrift::TType::I32, 8),
                ::fbthrift::Field::new("partition_num", ::fbthrift::TType::I32, 2),
                ::fbthrift::Field::new("replica_factor", ::fbthrift::TType::I32, 3),
                ::fbthrift::Field::new("space_name", ::fbthrift::TType::String, 1),
                ::fbthrift::Field::new("vid_type", ::fbthrift::TType::Struct, 6),
            ];
            let mut field_space_name = ::std::option::Option::None;
            let mut field_partition_num = ::std::option::Option::None;
            let mut field_replica_factor = ::std::option::Option::None;
            let mut field_charset_name = ::std::option::Option::None;
            let mut field_collate_name = ::std::option::Option::None;
            let mut field_vid_type = ::std::option::Option::None;
            let mut field_group_name = ::std::option::Option::None;
            let mut field_isolation_level = ::std::option::Option::None;
            let mut field_comment = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_space_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_partition_num = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 3) => field_replica_factor = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 4) => field_charset_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 5) => field_collate_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 6) => field_vid_type = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 7) => field_group_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 8) => field_isolation_level = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 9) => field_comment = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_name: field_space_name.unwrap_or_default(),
                partition_num: field_partition_num.unwrap_or_else(|| 0),
                replica_factor: field_replica_factor.unwrap_or_else(|| 0),
                charset_name: field_charset_name.unwrap_or_default(),
                collate_name: field_collate_name.unwrap_or_default(),
                vid_type: field_vid_type.unwrap_or_else(|| crate::types::ColumnTypeDef {
                    type_: crate::types::PropertyType::FIXED_STRING,
                    type_length: ::std::option::Option::Some(8),
                }),
                group_name: field_group_name,
                isolation_level: field_isolation_level,
                comment: field_comment,
            })
        }
    }


    impl ::std::default::Default for self::SpaceItem {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                properties: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::SpaceItem {}
    unsafe impl ::std::marker::Sync for self::SpaceItem {}

    impl ::fbthrift::GetTType for self::SpaceItem {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::SpaceItem
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("SpaceItem");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("properties", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.properties, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::SpaceItem
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("properties", ::fbthrift::TType::Struct, 2),
                ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ];
            let mut field_space_id = ::std::option::Option::None;
            let mut field_properties = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_properties = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                properties: field_properties.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::TagItem {
        fn default() -> Self {
            Self {
                tag_id: ::std::default::Default::default(),
                tag_name: ::std::default::Default::default(),
                version: ::std::default::Default::default(),
                schema: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::TagItem {}
    unsafe impl ::std::marker::Sync for self::TagItem {}

    impl ::fbthrift::GetTType for self::TagItem {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::TagItem
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("TagItem");
            p.write_field_begin("tag_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.tag_id, p);
            p.write_field_end();
            p.write_field_begin("tag_name", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.tag_name, p);
            p.write_field_end();
            p.write_field_begin("version", ::fbthrift::TType::I64, 3);
            ::fbthrift::Serialize::write(&self.version, p);
            p.write_field_end();
            p.write_field_begin("schema", ::fbthrift::TType::Struct, 4);
            ::fbthrift::Serialize::write(&self.schema, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::TagItem
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("schema", ::fbthrift::TType::Struct, 4),
                ::fbthrift::Field::new("tag_id", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("tag_name", ::fbthrift::TType::String, 2),
                ::fbthrift::Field::new("version", ::fbthrift::TType::I64, 3),
            ];
            let mut field_tag_id = ::std::option::Option::None;
            let mut field_tag_name = ::std::option::Option::None;
            let mut field_version = ::std::option::Option::None;
            let mut field_schema = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_tag_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_tag_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 3) => field_version = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 4) => field_schema = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                tag_id: field_tag_id.unwrap_or_default(),
                tag_name: field_tag_name.unwrap_or_default(),
                version: field_version.unwrap_or_default(),
                schema: field_schema.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::AlterSchemaItem {
        fn default() -> Self {
            Self {
                op: ::std::default::Default::default(),
                schema: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::AlterSchemaItem {}
    unsafe impl ::std::marker::Sync for self::AlterSchemaItem {}

    impl ::fbthrift::GetTType for self::AlterSchemaItem {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::AlterSchemaItem
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("AlterSchemaItem");
            p.write_field_begin("op", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.op, p);
            p.write_field_end();
            p.write_field_begin("schema", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.schema, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::AlterSchemaItem
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("op", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("schema", ::fbthrift::TType::Struct, 2),
            ];
            let mut field_op = ::std::option::Option::None;
            let mut field_schema = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_op = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_schema = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                op: field_op.unwrap_or_default(),
                schema: field_schema.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::EdgeItem {
        fn default() -> Self {
            Self {
                edge_type: ::std::default::Default::default(),
                edge_name: ::std::default::Default::default(),
                version: ::std::default::Default::default(),
                schema: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::EdgeItem {}
    unsafe impl ::std::marker::Sync for self::EdgeItem {}

    impl ::fbthrift::GetTType for self::EdgeItem {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::EdgeItem
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("EdgeItem");
            p.write_field_begin("edge_type", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.edge_type, p);
            p.write_field_end();
            p.write_field_begin("edge_name", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.edge_name, p);
            p.write_field_end();
            p.write_field_begin("version", ::fbthrift::TType::I64, 3);
            ::fbthrift::Serialize::write(&self.version, p);
            p.write_field_end();
            p.write_field_begin("schema", ::fbthrift::TType::Struct, 4);
            ::fbthrift::Serialize::write(&self.schema, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::EdgeItem
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("edge_name", ::fbthrift::TType::String, 2),
                ::fbthrift::Field::new("edge_type", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("schema", ::fbthrift::TType::Struct, 4),
                ::fbthrift::Field::new("version", ::fbthrift::TType::I64, 3),
            ];
            let mut field_edge_type = ::std::option::Option::None;
            let mut field_edge_name = ::std::option::Option::None;
            let mut field_version = ::std::option::Option::None;
            let mut field_schema = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_edge_type = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_edge_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 3) => field_version = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 4) => field_schema = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                edge_type: field_edge_type.unwrap_or_default(),
                edge_name: field_edge_name.unwrap_or_default(),
                version: field_version.unwrap_or_default(),
                schema: field_schema.unwrap_or_default(),
            })
        }
    }



    impl ::std::default::Default for SchemaID {
        fn default() -> Self {
            Self::UnknownField(-1)
        }
    }

    impl ::fbthrift::GetTType for SchemaID {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for SchemaID
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("SchemaID");
            match self {
                SchemaID::tag_id(inner) => {
                    p.write_field_begin("tag_id", ::fbthrift::TType::I32, 1);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                SchemaID::edge_type(inner) => {
                    p.write_field_begin("edge_type", ::fbthrift::TType::I32, 2);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                SchemaID::UnknownField(x) => {
                    p.write_field_begin("UnknownField", ::fbthrift::TType::I32, *x as ::std::primitive::i16);
                    x.write(p);
                    p.write_field_end();
                }
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for SchemaID
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("edge_type", ::fbthrift::TType::I32, 2),
                ::fbthrift::Field::new("tag_id", ::fbthrift::TType::I32, 1),
            ];
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::option::Option::None;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32, once) {
                    (::fbthrift::TType::Stop, _, _) => break,
                    (::fbthrift::TType::I32, 1, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(SchemaID::tag_id(::fbthrift::Deserialize::read(p)?));
                    }
                    (::fbthrift::TType::I32, 2, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(SchemaID::edge_type(::fbthrift::Deserialize::read(p)?));
                    }
                    (fty, _, false) => p.skip(fty)?,
                    (badty, badid, true) => return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                        format!(
                            "unwanted extra union {} field ty {:?} id {}",
                            "SchemaID",
                            badty,
                            badid,
                        ),
                    ))),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(alt.unwrap_or_default())
        }
    }

    impl ::std::default::Default for self::IndexItem {
        fn default() -> Self {
            Self {
                index_id: ::std::default::Default::default(),
                index_name: ::std::default::Default::default(),
                schema_id: ::std::default::Default::default(),
                schema_name: ::std::default::Default::default(),
                fields: ::std::default::Default::default(),
                comment: ::std::option::Option::None,
            }
        }
    }

    unsafe impl ::std::marker::Send for self::IndexItem {}
    unsafe impl ::std::marker::Sync for self::IndexItem {}

    impl ::fbthrift::GetTType for self::IndexItem {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::IndexItem
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("IndexItem");
            p.write_field_begin("index_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.index_id, p);
            p.write_field_end();
            p.write_field_begin("index_name", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.index_name, p);
            p.write_field_end();
            p.write_field_begin("schema_id", ::fbthrift::TType::Struct, 3);
            ::fbthrift::Serialize::write(&self.schema_id, p);
            p.write_field_end();
            p.write_field_begin("schema_name", ::fbthrift::TType::String, 4);
            ::fbthrift::Serialize::write(&self.schema_name, p);
            p.write_field_end();
            p.write_field_begin("fields", ::fbthrift::TType::List, 5);
            ::fbthrift::Serialize::write(&self.fields, p);
            p.write_field_end();
            if let ::std::option::Option::Some(some) = &self.comment {
                p.write_field_begin("comment", ::fbthrift::TType::String, 6);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::IndexItem
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("comment", ::fbthrift::TType::String, 6),
                ::fbthrift::Field::new("fields", ::fbthrift::TType::List, 5),
                ::fbthrift::Field::new("index_id", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("index_name", ::fbthrift::TType::String, 2),
                ::fbthrift::Field::new("schema_id", ::fbthrift::TType::Struct, 3),
                ::fbthrift::Field::new("schema_name", ::fbthrift::TType::String, 4),
            ];
            let mut field_index_id = ::std::option::Option::None;
            let mut field_index_name = ::std::option::Option::None;
            let mut field_schema_id = ::std::option::Option::None;
            let mut field_schema_name = ::std::option::Option::None;
            let mut field_fields = ::std::option::Option::None;
            let mut field_comment = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_index_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_index_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 3) => field_schema_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 4) => field_schema_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 5) => field_fields = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 6) => field_comment = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                index_id: field_index_id.unwrap_or_default(),
                index_name: field_index_name.unwrap_or_default(),
                schema_id: field_schema_id.unwrap_or_default(),
                schema_name: field_schema_name.unwrap_or_default(),
                fields: field_fields.unwrap_or_default(),
                comment: field_comment,
            })
        }
    }


    impl ::std::default::Default for self::HostItem {
        fn default() -> Self {
            Self {
                hostAddr: ::std::default::Default::default(),
                status: ::std::default::Default::default(),
                leader_parts: ::std::default::Default::default(),
                all_parts: ::std::default::Default::default(),
                role: ::std::default::Default::default(),
                git_info_sha: ::std::default::Default::default(),
                zone_name: ::std::option::Option::None,
            }
        }
    }

    unsafe impl ::std::marker::Send for self::HostItem {}
    unsafe impl ::std::marker::Sync for self::HostItem {}

    impl ::fbthrift::GetTType for self::HostItem {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::HostItem
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("HostItem");
            p.write_field_begin("hostAddr", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(&self.hostAddr, p);
            p.write_field_end();
            p.write_field_begin("status", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.status, p);
            p.write_field_end();
            p.write_field_begin("leader_parts", ::fbthrift::TType::Map, 3);
            ::fbthrift::Serialize::write(&self.leader_parts, p);
            p.write_field_end();
            p.write_field_begin("all_parts", ::fbthrift::TType::Map, 4);
            ::fbthrift::Serialize::write(&self.all_parts, p);
            p.write_field_end();
            p.write_field_begin("role", ::fbthrift::TType::I32, 5);
            ::fbthrift::Serialize::write(&self.role, p);
            p.write_field_end();
            p.write_field_begin("git_info_sha", ::fbthrift::TType::String, 6);
            ::fbthrift::Serialize::write(&self.git_info_sha, p);
            p.write_field_end();
            if let ::std::option::Option::Some(some) = &self.zone_name {
                p.write_field_begin("zone_name", ::fbthrift::TType::String, 7);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::HostItem
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("all_parts", ::fbthrift::TType::Map, 4),
                ::fbthrift::Field::new("git_info_sha", ::fbthrift::TType::String, 6),
                ::fbthrift::Field::new("hostAddr", ::fbthrift::TType::Struct, 1),
                ::fbthrift::Field::new("leader_parts", ::fbthrift::TType::Map, 3),
                ::fbthrift::Field::new("role", ::fbthrift::TType::I32, 5),
                ::fbthrift::Field::new("status", ::fbthrift::TType::I32, 2),
                ::fbthrift::Field::new("zone_name", ::fbthrift::TType::String, 7),
            ];
            let mut field_hostAddr = ::std::option::Option::None;
            let mut field_status = ::std::option::Option::None;
            let mut field_leader_parts = ::std::option::Option::None;
            let mut field_all_parts = ::std::option::Option::None;
            let mut field_role = ::std::option::Option::None;
            let mut field_git_info_sha = ::std::option::Option::None;
            let mut field_zone_name = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_hostAddr = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_status = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 3) => field_leader_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 4) => field_all_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 5) => field_role = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 6) => field_git_info_sha = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 7) => field_zone_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                hostAddr: field_hostAddr.unwrap_or_default(),
                status: field_status.unwrap_or_default(),
                leader_parts: field_leader_parts.unwrap_or_default(),
                all_parts: field_all_parts.unwrap_or_default(),
                role: field_role.unwrap_or_default(),
                git_info_sha: field_git_info_sha.unwrap_or_default(),
                zone_name: field_zone_name,
            })
        }
    }


    impl ::std::default::Default for self::UserItem {
        fn default() -> Self {
            Self {
                account: ::std::default::Default::default(),
                is_lock: ::std::default::Default::default(),
                max_queries_per_hour: ::std::default::Default::default(),
                max_updates_per_hour: ::std::default::Default::default(),
                max_connections_per_hour: ::std::default::Default::default(),
                max_user_connections: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::UserItem {}
    unsafe impl ::std::marker::Sync for self::UserItem {}

    impl ::fbthrift::GetTType for self::UserItem {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::UserItem
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("UserItem");
            p.write_field_begin("account", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.account, p);
            p.write_field_end();
            p.write_field_begin("is_lock", ::fbthrift::TType::Bool, 2);
            ::fbthrift::Serialize::write(&self.is_lock, p);
            p.write_field_end();
            p.write_field_begin("max_queries_per_hour", ::fbthrift::TType::I32, 3);
            ::fbthrift::Serialize::write(&self.max_queries_per_hour, p);
            p.write_field_end();
            p.write_field_begin("max_updates_per_hour", ::fbthrift::TType::I32, 4);
            ::fbthrift::Serialize::write(&self.max_updates_per_hour, p);
            p.write_field_end();
            p.write_field_begin("max_connections_per_hour", ::fbthrift::TType::I32, 5);
            ::fbthrift::Serialize::write(&self.max_connections_per_hour, p);
            p.write_field_end();
            p.write_field_begin("max_user_connections", ::fbthrift::TType::I32, 6);
            ::fbthrift::Serialize::write(&self.max_user_connections, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::UserItem
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("account", ::fbthrift::TType::String, 1),
                ::fbthrift::Field::new("is_lock", ::fbthrift::TType::Bool, 2),
                ::fbthrift::Field::new("max_connections_per_hour", ::fbthrift::TType::I32, 5),
                ::fbthrift::Field::new("max_queries_per_hour", ::fbthrift::TType::I32, 3),
                ::fbthrift::Field::new("max_updates_per_hour", ::fbthrift::TType::I32, 4),
                ::fbthrift::Field::new("max_user_connections", ::fbthrift::TType::I32, 6),
            ];
            let mut field_account = ::std::option::Option::None;
            let mut field_is_lock = ::std::option::Option::None;
            let mut field_max_queries_per_hour = ::std::option::Option::None;
            let mut field_max_updates_per_hour = ::std::option::Option::None;
            let mut field_max_connections_per_hour = ::std::option::Option::None;
            let mut field_max_user_connections = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_account = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 2) => field_is_lock = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 3) => field_max_queries_per_hour = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 4) => field_max_updates_per_hour = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 5) => field_max_connections_per_hour = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 6) => field_max_user_connections = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                account: field_account.unwrap_or_default(),
                is_lock: field_is_lock.unwrap_or_default(),
                max_queries_per_hour: field_max_queries_per_hour.unwrap_or_default(),
                max_updates_per_hour: field_max_updates_per_hour.unwrap_or_default(),
                max_connections_per_hour: field_max_connections_per_hour.unwrap_or_default(),
                max_user_connections: field_max_user_connections.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::RoleItem {
        fn default() -> Self {
            Self {
                user_id: ::std::default::Default::default(),
                space_id: ::std::default::Default::default(),
                role_type: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::RoleItem {}
    unsafe impl ::std::marker::Sync for self::RoleItem {}

    impl ::fbthrift::GetTType for self::RoleItem {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::RoleItem
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("RoleItem");
            p.write_field_begin("user_id", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.user_id, p);
            p.write_field_end();
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("role_type", ::fbthrift::TType::I32, 3);
            ::fbthrift::Serialize::write(&self.role_type, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::RoleItem
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("role_type", ::fbthrift::TType::I32, 3),
                ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 2),
                ::fbthrift::Field::new("user_id", ::fbthrift::TType::String, 1),
            ];
            let mut field_user_id = ::std::option::Option::None;
            let mut field_space_id = ::std::option::Option::None;
            let mut field_role_type = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_user_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 3) => field_role_type = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                user_id: field_user_id.unwrap_or_default(),
                space_id: field_space_id.unwrap_or_default(),
                role_type: field_role_type.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ExecResp {
        fn default() -> Self {
            Self {
                code: ::std::default::Default::default(),
                id: ::std::default::Default::default(),
                leader: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ExecResp {}
    unsafe impl ::std::marker::Sync for self::ExecResp {}

    impl ::fbthrift::GetTType for self::ExecResp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ExecResp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ExecResp");
            p.write_field_begin("code", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.code, p);
            p.write_field_end();
            p.write_field_begin("id", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.id, p);
            p.write_field_end();
            p.write_field_begin("leader", ::fbthrift::TType::Struct, 3);
            ::fbthrift::Serialize::write(&self.leader, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ExecResp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("id", ::fbthrift::TType::Struct, 2),
                ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 3),
            ];
            let mut field_code = ::std::option::Option::None;
            let mut field_id = ::std::option::Option::None;
            let mut field_leader = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 3) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                code: field_code.unwrap_or_default(),
                id: field_id.unwrap_or_default(),
                leader: field_leader.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::AdminJobReq {
        fn default() -> Self {
            Self {
                op: ::std::default::Default::default(),
                cmd: ::std::default::Default::default(),
                paras: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::AdminJobReq {}
    unsafe impl ::std::marker::Sync for self::AdminJobReq {}

    impl ::fbthrift::GetTType for self::AdminJobReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::AdminJobReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("AdminJobReq");
            p.write_field_begin("op", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.op, p);
            p.write_field_end();
            p.write_field_begin("cmd", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.cmd, p);
            p.write_field_end();
            p.write_field_begin("paras", ::fbthrift::TType::List, 3);
            ::fbthrift::Serialize::write(&self.paras, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::AdminJobReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("cmd", ::fbthrift::TType::I32, 2),
                ::fbthrift::Field::new("op", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("paras", ::fbthrift::TType::List, 3),
            ];
            let mut field_op = ::std::option::Option::None;
            let mut field_cmd = ::std::option::Option::None;
            let mut field_paras = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_op = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_cmd = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 3) => field_paras = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                op: field_op.unwrap_or_default(),
                cmd: field_cmd.unwrap_or_default(),
                paras: field_paras.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::JobDesc {
        fn default() -> Self {
            Self {
                id: ::std::default::Default::default(),
                cmd: ::std::default::Default::default(),
                paras: ::std::default::Default::default(),
                status: ::std::default::Default::default(),
                start_time: ::std::default::Default::default(),
                stop_time: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::JobDesc {}
    unsafe impl ::std::marker::Sync for self::JobDesc {}

    impl ::fbthrift::GetTType for self::JobDesc {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::JobDesc
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("JobDesc");
            p.write_field_begin("id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.id, p);
            p.write_field_end();
            p.write_field_begin("cmd", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.cmd, p);
            p.write_field_end();
            p.write_field_begin("paras", ::fbthrift::TType::List, 3);
            ::fbthrift::Serialize::write(&self.paras, p);
            p.write_field_end();
            p.write_field_begin("status", ::fbthrift::TType::I32, 4);
            ::fbthrift::Serialize::write(&self.status, p);
            p.write_field_end();
            p.write_field_begin("start_time", ::fbthrift::TType::I64, 5);
            ::fbthrift::Serialize::write(&self.start_time, p);
            p.write_field_end();
            p.write_field_begin("stop_time", ::fbthrift::TType::I64, 6);
            ::fbthrift::Serialize::write(&self.stop_time, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::JobDesc
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("cmd", ::fbthrift::TType::I32, 2),
                ::fbthrift::Field::new("id", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("paras", ::fbthrift::TType::List, 3),
                ::fbthrift::Field::new("start_time", ::fbthrift::TType::I64, 5),
                ::fbthrift::Field::new("status", ::fbthrift::TType::I32, 4),
                ::fbthrift::Field::new("stop_time", ::fbthrift::TType::I64, 6),
            ];
            let mut field_id = ::std::option::Option::None;
            let mut field_cmd = ::std::option::Option::None;
            let mut field_paras = ::std::option::Option::None;
            let mut field_status = ::std::option::Option::None;
            let mut field_start_time = ::std::option::Option::None;
            let mut field_stop_time = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_cmd = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 3) => field_paras = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 4) => field_status = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 5) => field_start_time = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 6) => field_stop_time = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                id: field_id.unwrap_or_default(),
                cmd: field_cmd.unwrap_or_default(),
                paras: field_paras.unwrap_or_default(),
                status: field_status.unwrap_or_default(),
                start_time: field_start_time.unwrap_or_default(),
                stop_time: field_stop_time.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::TaskDesc {
        fn default() -> Self {
            Self {
                task_id: ::std::default::Default::default(),
                host: ::std::default::Default::default(),
                status: ::std::default::Default::default(),
                start_time: ::std::default::Default::default(),
                stop_time: ::std::default::Default::default(),
                job_id: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::TaskDesc {}
    unsafe impl ::std::marker::Sync for self::TaskDesc {}

    impl ::fbthrift::GetTType for self::TaskDesc {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::TaskDesc
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("TaskDesc");
            p.write_field_begin("task_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.task_id, p);
            p.write_field_end();
            p.write_field_begin("host", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.host, p);
            p.write_field_end();
            p.write_field_begin("status", ::fbthrift::TType::I32, 3);
            ::fbthrift::Serialize::write(&self.status, p);
            p.write_field_end();
            p.write_field_begin("start_time", ::fbthrift::TType::I64, 4);
            ::fbthrift::Serialize::write(&self.start_time, p);
            p.write_field_end();
            p.write_field_begin("stop_time", ::fbthrift::TType::I64, 5);
            ::fbthrift::Serialize::write(&self.stop_time, p);
            p.write_field_end();
            p.write_field_begin("job_id", ::fbthrift::TType::I32, 6);
            ::fbthrift::Serialize::write(&self.job_id, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::TaskDesc
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("host", ::fbthrift::TType::Struct, 2),
                ::fbthrift::Field::new("job_id", ::fbthrift::TType::I32, 6),
                ::fbthrift::Field::new("start_time", ::fbthrift::TType::I64, 4),
                ::fbthrift::Field::new("status", ::fbthrift::TType::I32, 3),
                ::fbthrift::Field::new("stop_time", ::fbthrift::TType::I64, 5),
                ::fbthrift::Field::new("task_id", ::fbthrift::TType::I32, 1),
            ];
            let mut field_task_id = ::std::option::Option::None;
            let mut field_host = ::std::option::Option::None;
            let mut field_status = ::std::option::Option::None;
            let mut field_start_time = ::std::option::Option::None;
            let mut field_stop_time = ::std::option::Option::None;
            let mut field_job_id = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_task_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_host = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 3) => field_status = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 4) => field_start_time = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 5) => field_stop_time = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 6) => field_job_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                task_id: field_task_id.unwrap_or_default(),
                host: field_host.unwrap_or_default(),
                status: field_status.unwrap_or_default(),
                start_time: field_start_time.unwrap_or_default(),
                stop_time: field_stop_time.unwrap_or_default(),
                job_id: field_job_id.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::AdminJobResult {
        fn default() -> Self {
            Self {
                job_id: ::std::option::Option::None,
                job_desc: ::std::option::Option::None,
                task_desc: ::std::option::Option::None,
                recovered_job_num: ::std::option::Option::None,
            }
        }
    }

    unsafe impl ::std::marker::Send for self::AdminJobResult {}
    unsafe impl ::std::marker::Sync for self::AdminJobResult {}

    impl ::fbthrift::GetTType for self::AdminJobResult {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::AdminJobResult
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("AdminJobResult");
            if let ::std::option::Option::Some(some) = &self.job_id {
                p.write_field_begin("job_id", ::fbthrift::TType::I32, 1);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.job_desc {
                p.write_field_begin("job_desc", ::fbthrift::TType::List, 2);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.task_desc {
                p.write_field_begin("task_desc", ::fbthrift::TType::List, 3);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.recovered_job_num {
                p.write_field_begin("recovered_job_num", ::fbthrift::TType::I32, 4);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::AdminJobResult
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("job_desc", ::fbthrift::TType::List, 2),
                ::fbthrift::Field::new("job_id", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("recovered_job_num", ::fbthrift::TType::I32, 4),
                ::fbthrift::Field::new("task_desc", ::fbthrift::TType::List, 3),
            ];
            let mut field_job_id = ::std::option::Option::None;
            let mut field_job_desc = ::std::option::Option::None;
            let mut field_task_desc = ::std::option::Option::None;
            let mut field_recovered_job_num = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_job_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 2) => field_job_desc = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 3) => field_task_desc = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 4) => field_recovered_job_num = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                job_id: field_job_id,
                job_desc: field_job_desc,
                task_desc: field_task_desc,
                recovered_job_num: field_recovered_job_num,
            })
        }
    }


    impl ::std::default::Default for self::AdminJobResp {
        fn default() -> Self {
            Self {
                code: ::std::default::Default::default(),
                leader: ::std::default::Default::default(),
                result: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::AdminJobResp {}
    unsafe impl ::std::marker::Sync for self::AdminJobResp {}

    impl ::fbthrift::GetTType for self::AdminJobResp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::AdminJobResp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("AdminJobResp");
            p.write_field_begin("code", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.code, p);
            p.write_field_end();
            p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.leader, p);
            p.write_field_end();
            p.write_field_begin("result", ::fbthrift::TType::Struct, 3);
            ::fbthrift::Serialize::write(&self.result, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::AdminJobResp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
                ::fbthrift::Field::new("result", ::fbthrift::TType::Struct, 3),
            ];
            let mut field_code = ::std::option::Option::None;
            let mut field_leader = ::std::option::Option::None;
            let mut field_result = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 3) => field_result = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                code: field_code.unwrap_or_default(),
                leader: field_leader.unwrap_or_default(),
                result: field_result.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::Correlativity {
        fn default() -> Self {
            Self {
                part_id: ::std::default::Default::default(),
                proportion: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::Correlativity {}
    unsafe impl ::std::marker::Sync for self::Correlativity {}

    impl ::fbthrift::GetTType for self::Correlativity {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::Correlativity
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("Correlativity");
            p.write_field_begin("part_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.part_id, p);
            p.write_field_end();
            p.write_field_begin("proportion", ::fbthrift::TType::Double, 2);
            ::fbthrift::Serialize::write(&self.proportion, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::Correlativity
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("part_id", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("proportion", ::fbthrift::TType::Double, 2),
            ];
            let mut field_part_id = ::std::option::Option::None;
            let mut field_proportion = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_part_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Double, 2) => field_proportion = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                part_id: field_part_id.unwrap_or_default(),
                proportion: field_proportion.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::StatisItem {
        fn default() -> Self {
            Self {
                tag_vertices: ::std::default::Default::default(),
                edges: ::std::default::Default::default(),
                space_vertices: ::std::default::Default::default(),
                space_edges: ::std::default::Default::default(),
                positive_part_correlativity: ::std::default::Default::default(),
                negative_part_correlativity: ::std::default::Default::default(),
                status: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::StatisItem {}
    unsafe impl ::std::marker::Sync for self::StatisItem {}

    impl ::fbthrift::GetTType for self::StatisItem {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::StatisItem
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("StatisItem");
            p.write_field_begin("tag_vertices", ::fbthrift::TType::Map, 1);
            ::fbthrift::Serialize::write(&self.tag_vertices, p);
            p.write_field_end();
            p.write_field_begin("edges", ::fbthrift::TType::Map, 2);
            ::fbthrift::Serialize::write(&self.edges, p);
            p.write_field_end();
            p.write_field_begin("space_vertices", ::fbthrift::TType::I64, 3);
            ::fbthrift::Serialize::write(&self.space_vertices, p);
            p.write_field_end();
            p.write_field_begin("space_edges", ::fbthrift::TType::I64, 4);
            ::fbthrift::Serialize::write(&self.space_edges, p);
            p.write_field_end();
            p.write_field_begin("positive_part_correlativity", ::fbthrift::TType::Map, 5);
            ::fbthrift::Serialize::write(&self.positive_part_correlativity, p);
            p.write_field_end();
            p.write_field_begin("negative_part_correlativity", ::fbthrift::TType::Map, 6);
            ::fbthrift::Serialize::write(&self.negative_part_correlativity, p);
            p.write_field_end();
            p.write_field_begin("status", ::fbthrift::TType::I32, 7);
            ::fbthrift::Serialize::write(&self.status, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::StatisItem
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("edges", ::fbthrift::TType::Map, 2),
                ::fbthrift::Field::new("negative_part_correlativity", ::fbthrift::TType::Map, 6),
                ::fbthrift::Field::new("positive_part_correlativity", ::fbthrift::TType::Map, 5),
                ::fbthrift::Field::new("space_edges", ::fbthrift::TType::I64, 4),
                ::fbthrift::Field::new("space_vertices", ::fbthrift::TType::I64, 3),
                ::fbthrift::Field::new("status", ::fbthrift::TType::I32, 7),
                ::fbthrift::Field::new("tag_vertices", ::fbthrift::TType::Map, 1),
            ];
            let mut field_tag_vertices = ::std::option::Option::None;
            let mut field_edges = ::std::option::Option::None;
            let mut field_space_vertices = ::std::option::Option::None;
            let mut field_space_edges = ::std::option::Option::None;
            let mut field_positive_part_correlativity = ::std::option::Option::None;
            let mut field_negative_part_correlativity = ::std::option::Option::None;
            let mut field_status = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Map, 1) => field_tag_vertices = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 2) => field_edges = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 3) => field_space_vertices = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 4) => field_space_edges = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 5) => field_positive_part_correlativity = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 6) => field_negative_part_correlativity = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 7) => field_status = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                tag_vertices: field_tag_vertices.unwrap_or_default(),
                edges: field_edges.unwrap_or_default(),
                space_vertices: field_space_vertices.unwrap_or_default(),
                space_edges: field_space_edges.unwrap_or_default(),
                positive_part_correlativity: field_positive_part_correlativity.unwrap_or_default(),
                negative_part_correlativity: field_negative_part_correlativity.unwrap_or_default(),
                status: field_status.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::CreateSpaceReq {
        fn default() -> Self {
            Self {
                properties: ::std::default::Default::default(),
                if_not_exists: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::CreateSpaceReq {}
    unsafe impl ::std::marker::Sync for self::CreateSpaceReq {}

    impl ::fbthrift::GetTType for self::CreateSpaceReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::CreateSpaceReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("CreateSpaceReq");
            p.write_field_begin("properties", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(&self.properties, p);
            p.write_field_end();
            p.write_field_begin("if_not_exists", ::fbthrift::TType::Bool, 2);
            ::fbthrift::Serialize::write(&self.if_not_exists, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::CreateSpaceReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("if_not_exists", ::fbthrift::TType::Bool, 2),
                ::fbthrift::Field::new("properties", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_properties = ::std::option::Option::None;
            let mut field_if_not_exists = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_properties = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 2) => field_if_not_exists = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                properties: field_properties.unwrap_or_default(),
                if_not_exists: field_if_not_exists.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::DropSpaceReq {
        fn default() -> Self {
            Self {
                space_name: ::std::default::Default::default(),
                if_exists: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::DropSpaceReq {}
    unsafe impl ::std::marker::Sync for self::DropSpaceReq {}

    impl ::fbthrift::GetTType for self::DropSpaceReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::DropSpaceReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("DropSpaceReq");
            p.write_field_begin("space_name", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.space_name, p);
            p.write_field_end();
            p.write_field_begin("if_exists", ::fbthrift::TType::Bool, 2);
            ::fbthrift::Serialize::write(&self.if_exists, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::DropSpaceReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("if_exists", ::fbthrift::TType::Bool, 2),
                ::fbthrift::Field::new("space_name", ::fbthrift::TType::String, 1),
            ];
            let mut field_space_name = ::std::option::Option::None;
            let mut field_if_exists = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_space_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 2) => field_if_exists = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_name: field_space_name.unwrap_or_default(),
                if_exists: field_if_exists.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ListSpacesReq {
        fn default() -> Self {
            Self {
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ListSpacesReq {}
    unsafe impl ::std::marker::Sync for self::ListSpacesReq {}

    impl ::fbthrift::GetTType for self::ListSpacesReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ListSpacesReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ListSpacesReq");
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ListSpacesReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
            ];
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
            })
        }
    }


    impl ::std::default::Default for self::ListSpacesResp {
        fn default() -> Self {
            Self {
                code: ::std::default::Default::default(),
                leader: ::std::default::Default::default(),
                spaces: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ListSpacesResp {}
    unsafe impl ::std::marker::Sync for self::ListSpacesResp {}

    impl ::fbthrift::GetTType for self::ListSpacesResp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ListSpacesResp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ListSpacesResp");
            p.write_field_begin("code", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.code, p);
            p.write_field_end();
            p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.leader, p);
            p.write_field_end();
            p.write_field_begin("spaces", ::fbthrift::TType::List, 3);
            ::fbthrift::Serialize::write(&self.spaces, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ListSpacesResp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
                ::fbthrift::Field::new("spaces", ::fbthrift::TType::List, 3),
            ];
            let mut field_code = ::std::option::Option::None;
            let mut field_leader = ::std::option::Option::None;
            let mut field_spaces = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 3) => field_spaces = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                code: field_code.unwrap_or_default(),
                leader: field_leader.unwrap_or_default(),
                spaces: field_spaces.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::GetSpaceReq {
        fn default() -> Self {
            Self {
                space_name: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::GetSpaceReq {}
    unsafe impl ::std::marker::Sync for self::GetSpaceReq {}

    impl ::fbthrift::GetTType for self::GetSpaceReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GetSpaceReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetSpaceReq");
            p.write_field_begin("space_name", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.space_name, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GetSpaceReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("space_name", ::fbthrift::TType::String, 1),
            ];
            let mut field_space_name = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_space_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_name: field_space_name.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::GetSpaceResp {
        fn default() -> Self {
            Self {
                code: ::std::default::Default::default(),
                leader: ::std::default::Default::default(),
                item: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::GetSpaceResp {}
    unsafe impl ::std::marker::Sync for self::GetSpaceResp {}

    impl ::fbthrift::GetTType for self::GetSpaceResp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GetSpaceResp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetSpaceResp");
            p.write_field_begin("code", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.code, p);
            p.write_field_end();
            p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.leader, p);
            p.write_field_end();
            p.write_field_begin("item", ::fbthrift::TType::Struct, 3);
            ::fbthrift::Serialize::write(&self.item, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GetSpaceResp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("item", ::fbthrift::TType::Struct, 3),
                ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ];
            let mut field_code = ::std::option::Option::None;
            let mut field_leader = ::std::option::Option::None;
            let mut field_item = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 3) => field_item = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                code: field_code.unwrap_or_default(),
                leader: field_leader.unwrap_or_default(),
                item: field_item.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::CreateTagReq {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                tag_name: ::std::default::Default::default(),
                schema: ::std::default::Default::default(),
                if_not_exists: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::CreateTagReq {}
    unsafe impl ::std::marker::Sync for self::CreateTagReq {}

    impl ::fbthrift::GetTType for self::CreateTagReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::CreateTagReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("CreateTagReq");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("tag_name", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.tag_name, p);
            p.write_field_end();
            p.write_field_begin("schema", ::fbthrift::TType::Struct, 3);
            ::fbthrift::Serialize::write(&self.schema, p);
            p.write_field_end();
            p.write_field_begin("if_not_exists", ::fbthrift::TType::Bool, 4);
            ::fbthrift::Serialize::write(&self.if_not_exists, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::CreateTagReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("if_not_exists", ::fbthrift::TType::Bool, 4),
                ::fbthrift::Field::new("schema", ::fbthrift::TType::Struct, 3),
                ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("tag_name", ::fbthrift::TType::String, 2),
            ];
            let mut field_space_id = ::std::option::Option::None;
            let mut field_tag_name = ::std::option::Option::None;
            let mut field_schema = ::std::option::Option::None;
            let mut field_if_not_exists = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_tag_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 3) => field_schema = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 4) => field_if_not_exists = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                tag_name: field_tag_name.unwrap_or_default(),
                schema: field_schema.unwrap_or_default(),
                if_not_exists: field_if_not_exists.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::AlterTagReq {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                tag_name: ::std::default::Default::default(),
                tag_items: ::std::default::Default::default(),
                schema_prop: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::AlterTagReq {}
    unsafe impl ::std::marker::Sync for self::AlterTagReq {}

    impl ::fbthrift::GetTType for self::AlterTagReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::AlterTagReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("AlterTagReq");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("tag_name", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.tag_name, p);
            p.write_field_end();
            p.write_field_begin("tag_items", ::fbthrift::TType::List, 3);
            ::fbthrift::Serialize::write(&self.tag_items, p);
            p.write_field_end();
            p.write_field_begin("schema_prop", ::fbthrift::TType::Struct, 4);
            ::fbthrift::Serialize::write(&self.schema_prop, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::AlterTagReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("schema_prop", ::fbthrift::TType::Struct, 4),
                ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("tag_items", ::fbthrift::TType::List, 3),
                ::fbthrift::Field::new("tag_name", ::fbthrift::TType::String, 2),
            ];
            let mut field_space_id = ::std::option::Option::None;
            let mut field_tag_name = ::std::option::Option::None;
            let mut field_tag_items = ::std::option::Option::None;
            let mut field_schema_prop = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_tag_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 3) => field_tag_items = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 4) => field_schema_prop = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                tag_name: field_tag_name.unwrap_or_default(),
                tag_items: field_tag_items.unwrap_or_default(),
                schema_prop: field_schema_prop.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::DropTagReq {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                tag_name: ::std::default::Default::default(),
                if_exists: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::DropTagReq {}
    unsafe impl ::std::marker::Sync for self::DropTagReq {}

    impl ::fbthrift::GetTType for self::DropTagReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::DropTagReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("DropTagReq");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("tag_name", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.tag_name, p);
            p.write_field_end();
            p.write_field_begin("if_exists", ::fbthrift::TType::Bool, 3);
            ::fbthrift::Serialize::write(&self.if_exists, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::DropTagReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("if_exists", ::fbthrift::TType::Bool, 3),
                ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("tag_name", ::fbthrift::TType::String, 2),
            ];
            let mut field_space_id = ::std::option::Option::None;
            let mut field_tag_name = ::std::option::Option::None;
            let mut field_if_exists = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_tag_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 3) => field_if_exists = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                tag_name: field_tag_name.unwrap_or_default(),
                if_exists: field_if_exists.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ListTagsReq {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ListTagsReq {}
    unsafe impl ::std::marker::Sync for self::ListTagsReq {}

    impl ::fbthrift::GetTType for self::ListTagsReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ListTagsReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ListTagsReq");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ListTagsReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ];
            let mut field_space_id = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ListTagsResp {
        fn default() -> Self {
            Self {
                code: ::std::default::Default::default(),
                leader: ::std::default::Default::default(),
                tags: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ListTagsResp {}
    unsafe impl ::std::marker::Sync for self::ListTagsResp {}

    impl ::fbthrift::GetTType for self::ListTagsResp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ListTagsResp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ListTagsResp");
            p.write_field_begin("code", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.code, p);
            p.write_field_end();
            p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.leader, p);
            p.write_field_end();
            p.write_field_begin("tags", ::fbthrift::TType::List, 3);
            ::fbthrift::Serialize::write(&self.tags, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ListTagsResp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
                ::fbthrift::Field::new("tags", ::fbthrift::TType::List, 3),
            ];
            let mut field_code = ::std::option::Option::None;
            let mut field_leader = ::std::option::Option::None;
            let mut field_tags = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 3) => field_tags = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                code: field_code.unwrap_or_default(),
                leader: field_leader.unwrap_or_default(),
                tags: field_tags.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::GetTagReq {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                tag_name: ::std::default::Default::default(),
                version: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::GetTagReq {}
    unsafe impl ::std::marker::Sync for self::GetTagReq {}

    impl ::fbthrift::GetTType for self::GetTagReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GetTagReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetTagReq");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("tag_name", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.tag_name, p);
            p.write_field_end();
            p.write_field_begin("version", ::fbthrift::TType::I64, 3);
            ::fbthrift::Serialize::write(&self.version, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GetTagReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("tag_name", ::fbthrift::TType::String, 2),
                ::fbthrift::Field::new("version", ::fbthrift::TType::I64, 3),
            ];
            let mut field_space_id = ::std::option::Option::None;
            let mut field_tag_name = ::std::option::Option::None;
            let mut field_version = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_tag_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 3) => field_version = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                tag_name: field_tag_name.unwrap_or_default(),
                version: field_version.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::GetTagResp {
        fn default() -> Self {
            Self {
                code: ::std::default::Default::default(),
                leader: ::std::default::Default::default(),
                schema: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::GetTagResp {}
    unsafe impl ::std::marker::Sync for self::GetTagResp {}

    impl ::fbthrift::GetTType for self::GetTagResp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GetTagResp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetTagResp");
            p.write_field_begin("code", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.code, p);
            p.write_field_end();
            p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.leader, p);
            p.write_field_end();
            p.write_field_begin("schema", ::fbthrift::TType::Struct, 3);
            ::fbthrift::Serialize::write(&self.schema, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GetTagResp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
                ::fbthrift::Field::new("schema", ::fbthrift::TType::Struct, 3),
            ];
            let mut field_code = ::std::option::Option::None;
            let mut field_leader = ::std::option::Option::None;
            let mut field_schema = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 3) => field_schema = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                code: field_code.unwrap_or_default(),
                leader: field_leader.unwrap_or_default(),
                schema: field_schema.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::CreateEdgeReq {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                edge_name: ::std::default::Default::default(),
                schema: ::std::default::Default::default(),
                if_not_exists: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::CreateEdgeReq {}
    unsafe impl ::std::marker::Sync for self::CreateEdgeReq {}

    impl ::fbthrift::GetTType for self::CreateEdgeReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::CreateEdgeReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("CreateEdgeReq");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("edge_name", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.edge_name, p);
            p.write_field_end();
            p.write_field_begin("schema", ::fbthrift::TType::Struct, 3);
            ::fbthrift::Serialize::write(&self.schema, p);
            p.write_field_end();
            p.write_field_begin("if_not_exists", ::fbthrift::TType::Bool, 4);
            ::fbthrift::Serialize::write(&self.if_not_exists, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::CreateEdgeReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("edge_name", ::fbthrift::TType::String, 2),
                ::fbthrift::Field::new("if_not_exists", ::fbthrift::TType::Bool, 4),
                ::fbthrift::Field::new("schema", ::fbthrift::TType::Struct, 3),
                ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ];
            let mut field_space_id = ::std::option::Option::None;
            let mut field_edge_name = ::std::option::Option::None;
            let mut field_schema = ::std::option::Option::None;
            let mut field_if_not_exists = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_edge_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 3) => field_schema = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 4) => field_if_not_exists = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                edge_name: field_edge_name.unwrap_or_default(),
                schema: field_schema.unwrap_or_default(),
                if_not_exists: field_if_not_exists.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::AlterEdgeReq {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                edge_name: ::std::default::Default::default(),
                edge_items: ::std::default::Default::default(),
                schema_prop: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::AlterEdgeReq {}
    unsafe impl ::std::marker::Sync for self::AlterEdgeReq {}

    impl ::fbthrift::GetTType for self::AlterEdgeReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::AlterEdgeReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("AlterEdgeReq");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("edge_name", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.edge_name, p);
            p.write_field_end();
            p.write_field_begin("edge_items", ::fbthrift::TType::List, 3);
            ::fbthrift::Serialize::write(&self.edge_items, p);
            p.write_field_end();
            p.write_field_begin("schema_prop", ::fbthrift::TType::Struct, 4);
            ::fbthrift::Serialize::write(&self.schema_prop, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::AlterEdgeReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("edge_items", ::fbthrift::TType::List, 3),
                ::fbthrift::Field::new("edge_name", ::fbthrift::TType::String, 2),
                ::fbthrift::Field::new("schema_prop", ::fbthrift::TType::Struct, 4),
                ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ];
            let mut field_space_id = ::std::option::Option::None;
            let mut field_edge_name = ::std::option::Option::None;
            let mut field_edge_items = ::std::option::Option::None;
            let mut field_schema_prop = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_edge_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 3) => field_edge_items = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 4) => field_schema_prop = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                edge_name: field_edge_name.unwrap_or_default(),
                edge_items: field_edge_items.unwrap_or_default(),
                schema_prop: field_schema_prop.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::GetEdgeReq {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                edge_name: ::std::default::Default::default(),
                version: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::GetEdgeReq {}
    unsafe impl ::std::marker::Sync for self::GetEdgeReq {}

    impl ::fbthrift::GetTType for self::GetEdgeReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GetEdgeReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetEdgeReq");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("edge_name", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.edge_name, p);
            p.write_field_end();
            p.write_field_begin("version", ::fbthrift::TType::I64, 3);
            ::fbthrift::Serialize::write(&self.version, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GetEdgeReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("edge_name", ::fbthrift::TType::String, 2),
                ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("version", ::fbthrift::TType::I64, 3),
            ];
            let mut field_space_id = ::std::option::Option::None;
            let mut field_edge_name = ::std::option::Option::None;
            let mut field_version = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_edge_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 3) => field_version = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                edge_name: field_edge_name.unwrap_or_default(),
                version: field_version.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::GetEdgeResp {
        fn default() -> Self {
            Self {
                code: ::std::default::Default::default(),
                leader: ::std::default::Default::default(),
                schema: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::GetEdgeResp {}
    unsafe impl ::std::marker::Sync for self::GetEdgeResp {}

    impl ::fbthrift::GetTType for self::GetEdgeResp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GetEdgeResp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetEdgeResp");
            p.write_field_begin("code", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.code, p);
            p.write_field_end();
            p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.leader, p);
            p.write_field_end();
            p.write_field_begin("schema", ::fbthrift::TType::Struct, 3);
            ::fbthrift::Serialize::write(&self.schema, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GetEdgeResp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
                ::fbthrift::Field::new("schema", ::fbthrift::TType::Struct, 3),
            ];
            let mut field_code = ::std::option::Option::None;
            let mut field_leader = ::std::option::Option::None;
            let mut field_schema = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 3) => field_schema = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                code: field_code.unwrap_or_default(),
                leader: field_leader.unwrap_or_default(),
                schema: field_schema.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::DropEdgeReq {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                edge_name: ::std::default::Default::default(),
                if_exists: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::DropEdgeReq {}
    unsafe impl ::std::marker::Sync for self::DropEdgeReq {}

    impl ::fbthrift::GetTType for self::DropEdgeReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::DropEdgeReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("DropEdgeReq");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("edge_name", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.edge_name, p);
            p.write_field_end();
            p.write_field_begin("if_exists", ::fbthrift::TType::Bool, 3);
            ::fbthrift::Serialize::write(&self.if_exists, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::DropEdgeReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("edge_name", ::fbthrift::TType::String, 2),
                ::fbthrift::Field::new("if_exists", ::fbthrift::TType::Bool, 3),
                ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ];
            let mut field_space_id = ::std::option::Option::None;
            let mut field_edge_name = ::std::option::Option::None;
            let mut field_if_exists = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_edge_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 3) => field_if_exists = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                edge_name: field_edge_name.unwrap_or_default(),
                if_exists: field_if_exists.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ListEdgesReq {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ListEdgesReq {}
    unsafe impl ::std::marker::Sync for self::ListEdgesReq {}

    impl ::fbthrift::GetTType for self::ListEdgesReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ListEdgesReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ListEdgesReq");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ListEdgesReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ];
            let mut field_space_id = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ListEdgesResp {
        fn default() -> Self {
            Self {
                code: ::std::default::Default::default(),
                leader: ::std::default::Default::default(),
                edges: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ListEdgesResp {}
    unsafe impl ::std::marker::Sync for self::ListEdgesResp {}

    impl ::fbthrift::GetTType for self::ListEdgesResp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ListEdgesResp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ListEdgesResp");
            p.write_field_begin("code", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.code, p);
            p.write_field_end();
            p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.leader, p);
            p.write_field_end();
            p.write_field_begin("edges", ::fbthrift::TType::List, 3);
            ::fbthrift::Serialize::write(&self.edges, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ListEdgesResp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("edges", ::fbthrift::TType::List, 3),
                ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ];
            let mut field_code = ::std::option::Option::None;
            let mut field_leader = ::std::option::Option::None;
            let mut field_edges = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 3) => field_edges = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                code: field_code.unwrap_or_default(),
                leader: field_leader.unwrap_or_default(),
                edges: field_edges.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ListHostsReq {
        fn default() -> Self {
            Self {
                type_: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ListHostsReq {}
    unsafe impl ::std::marker::Sync for self::ListHostsReq {}

    impl ::fbthrift::GetTType for self::ListHostsReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ListHostsReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ListHostsReq");
            p.write_field_begin("type", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.type_, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ListHostsReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("type", ::fbthrift::TType::I32, 1),
            ];
            let mut field_type = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_type = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                type_: field_type.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ListHostsResp {
        fn default() -> Self {
            Self {
                code: ::std::default::Default::default(),
                leader: ::std::default::Default::default(),
                hosts: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ListHostsResp {}
    unsafe impl ::std::marker::Sync for self::ListHostsResp {}

    impl ::fbthrift::GetTType for self::ListHostsResp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ListHostsResp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ListHostsResp");
            p.write_field_begin("code", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.code, p);
            p.write_field_end();
            p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.leader, p);
            p.write_field_end();
            p.write_field_begin("hosts", ::fbthrift::TType::List, 3);
            ::fbthrift::Serialize::write(&self.hosts, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ListHostsResp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("hosts", ::fbthrift::TType::List, 3),
                ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ];
            let mut field_code = ::std::option::Option::None;
            let mut field_leader = ::std::option::Option::None;
            let mut field_hosts = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 3) => field_hosts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                code: field_code.unwrap_or_default(),
                leader: field_leader.unwrap_or_default(),
                hosts: field_hosts.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::PartItem {
        fn default() -> Self {
            Self {
                part_id: ::std::default::Default::default(),
                leader: ::std::option::Option::None,
                peers: ::std::default::Default::default(),
                losts: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::PartItem {}
    unsafe impl ::std::marker::Sync for self::PartItem {}

    impl ::fbthrift::GetTType for self::PartItem {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::PartItem
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("PartItem");
            p.write_field_begin("part_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.part_id, p);
            p.write_field_end();
            if let ::std::option::Option::Some(some) = &self.leader {
                p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_begin("peers", ::fbthrift::TType::List, 3);
            ::fbthrift::Serialize::write(&self.peers, p);
            p.write_field_end();
            p.write_field_begin("losts", ::fbthrift::TType::List, 4);
            ::fbthrift::Serialize::write(&self.losts, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::PartItem
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
                ::fbthrift::Field::new("losts", ::fbthrift::TType::List, 4),
                ::fbthrift::Field::new("part_id", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("peers", ::fbthrift::TType::List, 3),
            ];
            let mut field_part_id = ::std::option::Option::None;
            let mut field_leader = ::std::option::Option::None;
            let mut field_peers = ::std::option::Option::None;
            let mut field_losts = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_part_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 3) => field_peers = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 4) => field_losts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                part_id: field_part_id.unwrap_or_default(),
                leader: field_leader,
                peers: field_peers.unwrap_or_default(),
                losts: field_losts.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ListPartsReq {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                part_ids: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ListPartsReq {}
    unsafe impl ::std::marker::Sync for self::ListPartsReq {}

    impl ::fbthrift::GetTType for self::ListPartsReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ListPartsReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ListPartsReq");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("part_ids", ::fbthrift::TType::List, 2);
            ::fbthrift::Serialize::write(&self.part_ids, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ListPartsReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("part_ids", ::fbthrift::TType::List, 2),
                ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ];
            let mut field_space_id = ::std::option::Option::None;
            let mut field_part_ids = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 2) => field_part_ids = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                part_ids: field_part_ids.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ListPartsResp {
        fn default() -> Self {
            Self {
                code: ::std::default::Default::default(),
                leader: ::std::default::Default::default(),
                parts: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ListPartsResp {}
    unsafe impl ::std::marker::Sync for self::ListPartsResp {}

    impl ::fbthrift::GetTType for self::ListPartsResp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ListPartsResp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ListPartsResp");
            p.write_field_begin("code", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.code, p);
            p.write_field_end();
            p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.leader, p);
            p.write_field_end();
            p.write_field_begin("parts", ::fbthrift::TType::List, 3);
            ::fbthrift::Serialize::write(&self.parts, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ListPartsResp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
                ::fbthrift::Field::new("parts", ::fbthrift::TType::List, 3),
            ];
            let mut field_code = ::std::option::Option::None;
            let mut field_leader = ::std::option::Option::None;
            let mut field_parts = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 3) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                code: field_code.unwrap_or_default(),
                leader: field_leader.unwrap_or_default(),
                parts: field_parts.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::GetPartsAllocReq {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::GetPartsAllocReq {}
    unsafe impl ::std::marker::Sync for self::GetPartsAllocReq {}

    impl ::fbthrift::GetTType for self::GetPartsAllocReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GetPartsAllocReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetPartsAllocReq");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GetPartsAllocReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ];
            let mut field_space_id = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::GetPartsAllocResp {
        fn default() -> Self {
            Self {
                code: ::std::default::Default::default(),
                leader: ::std::default::Default::default(),
                parts: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::GetPartsAllocResp {}
    unsafe impl ::std::marker::Sync for self::GetPartsAllocResp {}

    impl ::fbthrift::GetTType for self::GetPartsAllocResp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GetPartsAllocResp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetPartsAllocResp");
            p.write_field_begin("code", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.code, p);
            p.write_field_end();
            p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.leader, p);
            p.write_field_end();
            p.write_field_begin("parts", ::fbthrift::TType::Map, 3);
            ::fbthrift::Serialize::write(&self.parts, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GetPartsAllocResp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
                ::fbthrift::Field::new("parts", ::fbthrift::TType::Map, 3),
            ];
            let mut field_code = ::std::option::Option::None;
            let mut field_leader = ::std::option::Option::None;
            let mut field_parts = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 3) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                code: field_code.unwrap_or_default(),
                leader: field_leader.unwrap_or_default(),
                parts: field_parts.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::MultiPutReq {
        fn default() -> Self {
            Self {
                segment: ::std::default::Default::default(),
                pairs: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::MultiPutReq {}
    unsafe impl ::std::marker::Sync for self::MultiPutReq {}

    impl ::fbthrift::GetTType for self::MultiPutReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::MultiPutReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("MultiPutReq");
            p.write_field_begin("segment", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.segment, p);
            p.write_field_end();
            p.write_field_begin("pairs", ::fbthrift::TType::List, 2);
            ::fbthrift::Serialize::write(&self.pairs, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::MultiPutReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("pairs", ::fbthrift::TType::List, 2),
                ::fbthrift::Field::new("segment", ::fbthrift::TType::String, 1),
            ];
            let mut field_segment = ::std::option::Option::None;
            let mut field_pairs = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_segment = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 2) => field_pairs = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                segment: field_segment.unwrap_or_default(),
                pairs: field_pairs.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::GetReq {
        fn default() -> Self {
            Self {
                segment: ::std::default::Default::default(),
                key: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::GetReq {}
    unsafe impl ::std::marker::Sync for self::GetReq {}

    impl ::fbthrift::GetTType for self::GetReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GetReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetReq");
            p.write_field_begin("segment", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.segment, p);
            p.write_field_end();
            p.write_field_begin("key", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.key, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GetReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("key", ::fbthrift::TType::String, 2),
                ::fbthrift::Field::new("segment", ::fbthrift::TType::String, 1),
            ];
            let mut field_segment = ::std::option::Option::None;
            let mut field_key = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_segment = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_key = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                segment: field_segment.unwrap_or_default(),
                key: field_key.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::GetResp {
        fn default() -> Self {
            Self {
                code: ::std::default::Default::default(),
                leader: ::std::default::Default::default(),
                value: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::GetResp {}
    unsafe impl ::std::marker::Sync for self::GetResp {}

    impl ::fbthrift::GetTType for self::GetResp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GetResp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetResp");
            p.write_field_begin("code", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.code, p);
            p.write_field_end();
            p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.leader, p);
            p.write_field_end();
            p.write_field_begin("value", ::fbthrift::TType::String, 3);
            ::fbthrift::Serialize::write(&self.value, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GetResp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
                ::fbthrift::Field::new("value", ::fbthrift::TType::String, 3),
            ];
            let mut field_code = ::std::option::Option::None;
            let mut field_leader = ::std::option::Option::None;
            let mut field_value = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 3) => field_value = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                code: field_code.unwrap_or_default(),
                leader: field_leader.unwrap_or_default(),
                value: field_value.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::MultiGetReq {
        fn default() -> Self {
            Self {
                segment: ::std::default::Default::default(),
                keys: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::MultiGetReq {}
    unsafe impl ::std::marker::Sync for self::MultiGetReq {}

    impl ::fbthrift::GetTType for self::MultiGetReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::MultiGetReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("MultiGetReq");
            p.write_field_begin("segment", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.segment, p);
            p.write_field_end();
            p.write_field_begin("keys", ::fbthrift::TType::List, 2);
            ::fbthrift::Serialize::write(&self.keys, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::MultiGetReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("keys", ::fbthrift::TType::List, 2),
                ::fbthrift::Field::new("segment", ::fbthrift::TType::String, 1),
            ];
            let mut field_segment = ::std::option::Option::None;
            let mut field_keys = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_segment = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 2) => field_keys = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                segment: field_segment.unwrap_or_default(),
                keys: field_keys.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::MultiGetResp {
        fn default() -> Self {
            Self {
                code: ::std::default::Default::default(),
                leader: ::std::default::Default::default(),
                values: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::MultiGetResp {}
    unsafe impl ::std::marker::Sync for self::MultiGetResp {}

    impl ::fbthrift::GetTType for self::MultiGetResp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::MultiGetResp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("MultiGetResp");
            p.write_field_begin("code", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.code, p);
            p.write_field_end();
            p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.leader, p);
            p.write_field_end();
            p.write_field_begin("values", ::fbthrift::TType::List, 3);
            ::fbthrift::Serialize::write(&self.values, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::MultiGetResp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
                ::fbthrift::Field::new("values", ::fbthrift::TType::List, 3),
            ];
            let mut field_code = ::std::option::Option::None;
            let mut field_leader = ::std::option::Option::None;
            let mut field_values = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 3) => field_values = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                code: field_code.unwrap_or_default(),
                leader: field_leader.unwrap_or_default(),
                values: field_values.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::RemoveReq {
        fn default() -> Self {
            Self {
                segment: ::std::default::Default::default(),
                key: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::RemoveReq {}
    unsafe impl ::std::marker::Sync for self::RemoveReq {}

    impl ::fbthrift::GetTType for self::RemoveReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::RemoveReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("RemoveReq");
            p.write_field_begin("segment", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.segment, p);
            p.write_field_end();
            p.write_field_begin("key", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.key, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::RemoveReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("key", ::fbthrift::TType::String, 2),
                ::fbthrift::Field::new("segment", ::fbthrift::TType::String, 1),
            ];
            let mut field_segment = ::std::option::Option::None;
            let mut field_key = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_segment = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_key = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                segment: field_segment.unwrap_or_default(),
                key: field_key.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::RemoveRangeReq {
        fn default() -> Self {
            Self {
                segment: ::std::default::Default::default(),
                start: ::std::default::Default::default(),
                end: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::RemoveRangeReq {}
    unsafe impl ::std::marker::Sync for self::RemoveRangeReq {}

    impl ::fbthrift::GetTType for self::RemoveRangeReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::RemoveRangeReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("RemoveRangeReq");
            p.write_field_begin("segment", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.segment, p);
            p.write_field_end();
            p.write_field_begin("start", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.start, p);
            p.write_field_end();
            p.write_field_begin("end", ::fbthrift::TType::String, 3);
            ::fbthrift::Serialize::write(&self.end, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::RemoveRangeReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("end", ::fbthrift::TType::String, 3),
                ::fbthrift::Field::new("segment", ::fbthrift::TType::String, 1),
                ::fbthrift::Field::new("start", ::fbthrift::TType::String, 2),
            ];
            let mut field_segment = ::std::option::Option::None;
            let mut field_start = ::std::option::Option::None;
            let mut field_end = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_segment = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_start = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 3) => field_end = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                segment: field_segment.unwrap_or_default(),
                start: field_start.unwrap_or_default(),
                end: field_end.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ScanReq {
        fn default() -> Self {
            Self {
                segment: ::std::default::Default::default(),
                start: ::std::default::Default::default(),
                end: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ScanReq {}
    unsafe impl ::std::marker::Sync for self::ScanReq {}

    impl ::fbthrift::GetTType for self::ScanReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ScanReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ScanReq");
            p.write_field_begin("segment", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.segment, p);
            p.write_field_end();
            p.write_field_begin("start", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.start, p);
            p.write_field_end();
            p.write_field_begin("end", ::fbthrift::TType::String, 3);
            ::fbthrift::Serialize::write(&self.end, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ScanReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("end", ::fbthrift::TType::String, 3),
                ::fbthrift::Field::new("segment", ::fbthrift::TType::String, 1),
                ::fbthrift::Field::new("start", ::fbthrift::TType::String, 2),
            ];
            let mut field_segment = ::std::option::Option::None;
            let mut field_start = ::std::option::Option::None;
            let mut field_end = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_segment = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_start = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 3) => field_end = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                segment: field_segment.unwrap_or_default(),
                start: field_start.unwrap_or_default(),
                end: field_end.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ScanResp {
        fn default() -> Self {
            Self {
                code: ::std::default::Default::default(),
                leader: ::std::default::Default::default(),
                values: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ScanResp {}
    unsafe impl ::std::marker::Sync for self::ScanResp {}

    impl ::fbthrift::GetTType for self::ScanResp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ScanResp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ScanResp");
            p.write_field_begin("code", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.code, p);
            p.write_field_end();
            p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.leader, p);
            p.write_field_end();
            p.write_field_begin("values", ::fbthrift::TType::List, 3);
            ::fbthrift::Serialize::write(&self.values, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ScanResp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
                ::fbthrift::Field::new("values", ::fbthrift::TType::List, 3),
            ];
            let mut field_code = ::std::option::Option::None;
            let mut field_leader = ::std::option::Option::None;
            let mut field_values = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 3) => field_values = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                code: field_code.unwrap_or_default(),
                leader: field_leader.unwrap_or_default(),
                values: field_values.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::HBResp {
        fn default() -> Self {
            Self {
                code: ::std::default::Default::default(),
                leader: ::std::default::Default::default(),
                cluster_id: ::std::default::Default::default(),
                last_update_time_in_ms: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::HBResp {}
    unsafe impl ::std::marker::Sync for self::HBResp {}

    impl ::fbthrift::GetTType for self::HBResp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::HBResp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("HBResp");
            p.write_field_begin("code", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.code, p);
            p.write_field_end();
            p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.leader, p);
            p.write_field_end();
            p.write_field_begin("cluster_id", ::fbthrift::TType::I64, 3);
            ::fbthrift::Serialize::write(&self.cluster_id, p);
            p.write_field_end();
            p.write_field_begin("last_update_time_in_ms", ::fbthrift::TType::I64, 4);
            ::fbthrift::Serialize::write(&self.last_update_time_in_ms, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::HBResp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("cluster_id", ::fbthrift::TType::I64, 3),
                ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("last_update_time_in_ms", ::fbthrift::TType::I64, 4),
                ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ];
            let mut field_code = ::std::option::Option::None;
            let mut field_leader = ::std::option::Option::None;
            let mut field_cluster_id = ::std::option::Option::None;
            let mut field_last_update_time_in_ms = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 3) => field_cluster_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 4) => field_last_update_time_in_ms = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                code: field_code.unwrap_or_default(),
                leader: field_leader.unwrap_or_default(),
                cluster_id: field_cluster_id.unwrap_or_default(),
                last_update_time_in_ms: field_last_update_time_in_ms.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::LeaderInfo {
        fn default() -> Self {
            Self {
                part_id: ::std::default::Default::default(),
                term: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::LeaderInfo {}
    unsafe impl ::std::marker::Sync for self::LeaderInfo {}

    impl ::fbthrift::GetTType for self::LeaderInfo {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::LeaderInfo
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("LeaderInfo");
            p.write_field_begin("part_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.part_id, p);
            p.write_field_end();
            p.write_field_begin("term", ::fbthrift::TType::I64, 2);
            ::fbthrift::Serialize::write(&self.term, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::LeaderInfo
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("part_id", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("term", ::fbthrift::TType::I64, 2),
            ];
            let mut field_part_id = ::std::option::Option::None;
            let mut field_term = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_part_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 2) => field_term = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                part_id: field_part_id.unwrap_or_default(),
                term: field_term.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::HBReq {
        fn default() -> Self {
            Self {
                role: ::std::default::Default::default(),
                host: ::std::default::Default::default(),
                cluster_id: ::std::default::Default::default(),
                leader_partIds: ::std::option::Option::None,
                git_info_sha: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::HBReq {}
    unsafe impl ::std::marker::Sync for self::HBReq {}

    impl ::fbthrift::GetTType for self::HBReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::HBReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("HBReq");
            p.write_field_begin("role", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.role, p);
            p.write_field_end();
            p.write_field_begin("host", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.host, p);
            p.write_field_end();
            p.write_field_begin("cluster_id", ::fbthrift::TType::I64, 3);
            ::fbthrift::Serialize::write(&self.cluster_id, p);
            p.write_field_end();
            if let ::std::option::Option::Some(some) = &self.leader_partIds {
                p.write_field_begin("leader_partIds", ::fbthrift::TType::Map, 4);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_begin("git_info_sha", ::fbthrift::TType::String, 5);
            ::fbthrift::Serialize::write(&self.git_info_sha, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::HBReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("cluster_id", ::fbthrift::TType::I64, 3),
                ::fbthrift::Field::new("git_info_sha", ::fbthrift::TType::String, 5),
                ::fbthrift::Field::new("host", ::fbthrift::TType::Struct, 2),
                ::fbthrift::Field::new("leader_partIds", ::fbthrift::TType::Map, 4),
                ::fbthrift::Field::new("role", ::fbthrift::TType::I32, 1),
            ];
            let mut field_role = ::std::option::Option::None;
            let mut field_host = ::std::option::Option::None;
            let mut field_cluster_id = ::std::option::Option::None;
            let mut field_leader_partIds = ::std::option::Option::None;
            let mut field_git_info_sha = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_role = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_host = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 3) => field_cluster_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 4) => field_leader_partIds = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 5) => field_git_info_sha = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                role: field_role.unwrap_or_default(),
                host: field_host.unwrap_or_default(),
                cluster_id: field_cluster_id.unwrap_or_default(),
                leader_partIds: field_leader_partIds,
                git_info_sha: field_git_info_sha.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::IndexFieldDef {
        fn default() -> Self {
            Self {
                name: ::std::default::Default::default(),
                type_length: ::std::option::Option::None,
            }
        }
    }

    unsafe impl ::std::marker::Send for self::IndexFieldDef {}
    unsafe impl ::std::marker::Sync for self::IndexFieldDef {}

    impl ::fbthrift::GetTType for self::IndexFieldDef {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::IndexFieldDef
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("IndexFieldDef");
            p.write_field_begin("name", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.name, p);
            p.write_field_end();
            if let ::std::option::Option::Some(some) = &self.type_length {
                p.write_field_begin("type_length", ::fbthrift::TType::I16, 2);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::IndexFieldDef
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("name", ::fbthrift::TType::String, 1),
                ::fbthrift::Field::new("type_length", ::fbthrift::TType::I16, 2),
            ];
            let mut field_name = ::std::option::Option::None;
            let mut field_type_length = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I16, 2) => field_type_length = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                name: field_name.unwrap_or_default(),
                type_length: field_type_length,
            })
        }
    }


    impl ::std::default::Default for self::CreateTagIndexReq {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                index_name: ::std::default::Default::default(),
                tag_name: ::std::default::Default::default(),
                fields: ::std::default::Default::default(),
                if_not_exists: ::std::default::Default::default(),
                comment: ::std::option::Option::None,
            }
        }
    }

    unsafe impl ::std::marker::Send for self::CreateTagIndexReq {}
    unsafe impl ::std::marker::Sync for self::CreateTagIndexReq {}

    impl ::fbthrift::GetTType for self::CreateTagIndexReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::CreateTagIndexReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("CreateTagIndexReq");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("index_name", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.index_name, p);
            p.write_field_end();
            p.write_field_begin("tag_name", ::fbthrift::TType::String, 3);
            ::fbthrift::Serialize::write(&self.tag_name, p);
            p.write_field_end();
            p.write_field_begin("fields", ::fbthrift::TType::List, 4);
            ::fbthrift::Serialize::write(&self.fields, p);
            p.write_field_end();
            p.write_field_begin("if_not_exists", ::fbthrift::TType::Bool, 5);
            ::fbthrift::Serialize::write(&self.if_not_exists, p);
            p.write_field_end();
            if let ::std::option::Option::Some(some) = &self.comment {
                p.write_field_begin("comment", ::fbthrift::TType::String, 6);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::CreateTagIndexReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("comment", ::fbthrift::TType::String, 6),
                ::fbthrift::Field::new("fields", ::fbthrift::TType::List, 4),
                ::fbthrift::Field::new("if_not_exists", ::fbthrift::TType::Bool, 5),
                ::fbthrift::Field::new("index_name", ::fbthrift::TType::String, 2),
                ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("tag_name", ::fbthrift::TType::String, 3),
            ];
            let mut field_space_id = ::std::option::Option::None;
            let mut field_index_name = ::std::option::Option::None;
            let mut field_tag_name = ::std::option::Option::None;
            let mut field_fields = ::std::option::Option::None;
            let mut field_if_not_exists = ::std::option::Option::None;
            let mut field_comment = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_index_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 3) => field_tag_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 4) => field_fields = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 5) => field_if_not_exists = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 6) => field_comment = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                index_name: field_index_name.unwrap_or_default(),
                tag_name: field_tag_name.unwrap_or_default(),
                fields: field_fields.unwrap_or_default(),
                if_not_exists: field_if_not_exists.unwrap_or_default(),
                comment: field_comment,
            })
        }
    }


    impl ::std::default::Default for self::DropTagIndexReq {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                index_name: ::std::default::Default::default(),
                if_exists: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::DropTagIndexReq {}
    unsafe impl ::std::marker::Sync for self::DropTagIndexReq {}

    impl ::fbthrift::GetTType for self::DropTagIndexReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::DropTagIndexReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("DropTagIndexReq");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("index_name", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.index_name, p);
            p.write_field_end();
            p.write_field_begin("if_exists", ::fbthrift::TType::Bool, 3);
            ::fbthrift::Serialize::write(&self.if_exists, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::DropTagIndexReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("if_exists", ::fbthrift::TType::Bool, 3),
                ::fbthrift::Field::new("index_name", ::fbthrift::TType::String, 2),
                ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ];
            let mut field_space_id = ::std::option::Option::None;
            let mut field_index_name = ::std::option::Option::None;
            let mut field_if_exists = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_index_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 3) => field_if_exists = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                index_name: field_index_name.unwrap_or_default(),
                if_exists: field_if_exists.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::GetTagIndexReq {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                index_name: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::GetTagIndexReq {}
    unsafe impl ::std::marker::Sync for self::GetTagIndexReq {}

    impl ::fbthrift::GetTType for self::GetTagIndexReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GetTagIndexReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetTagIndexReq");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("index_name", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.index_name, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GetTagIndexReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("index_name", ::fbthrift::TType::String, 2),
                ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ];
            let mut field_space_id = ::std::option::Option::None;
            let mut field_index_name = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_index_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                index_name: field_index_name.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::GetTagIndexResp {
        fn default() -> Self {
            Self {
                code: ::std::default::Default::default(),
                leader: ::std::default::Default::default(),
                item: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::GetTagIndexResp {}
    unsafe impl ::std::marker::Sync for self::GetTagIndexResp {}

    impl ::fbthrift::GetTType for self::GetTagIndexResp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GetTagIndexResp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetTagIndexResp");
            p.write_field_begin("code", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.code, p);
            p.write_field_end();
            p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.leader, p);
            p.write_field_end();
            p.write_field_begin("item", ::fbthrift::TType::Struct, 3);
            ::fbthrift::Serialize::write(&self.item, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GetTagIndexResp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("item", ::fbthrift::TType::Struct, 3),
                ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ];
            let mut field_code = ::std::option::Option::None;
            let mut field_leader = ::std::option::Option::None;
            let mut field_item = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 3) => field_item = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                code: field_code.unwrap_or_default(),
                leader: field_leader.unwrap_or_default(),
                item: field_item.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ListTagIndexesReq {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ListTagIndexesReq {}
    unsafe impl ::std::marker::Sync for self::ListTagIndexesReq {}

    impl ::fbthrift::GetTType for self::ListTagIndexesReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ListTagIndexesReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ListTagIndexesReq");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ListTagIndexesReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ];
            let mut field_space_id = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ListTagIndexesResp {
        fn default() -> Self {
            Self {
                code: ::std::default::Default::default(),
                leader: ::std::default::Default::default(),
                items: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ListTagIndexesResp {}
    unsafe impl ::std::marker::Sync for self::ListTagIndexesResp {}

    impl ::fbthrift::GetTType for self::ListTagIndexesResp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ListTagIndexesResp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ListTagIndexesResp");
            p.write_field_begin("code", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.code, p);
            p.write_field_end();
            p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.leader, p);
            p.write_field_end();
            p.write_field_begin("items", ::fbthrift::TType::List, 3);
            ::fbthrift::Serialize::write(&self.items, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ListTagIndexesResp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("items", ::fbthrift::TType::List, 3),
                ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ];
            let mut field_code = ::std::option::Option::None;
            let mut field_leader = ::std::option::Option::None;
            let mut field_items = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 3) => field_items = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                code: field_code.unwrap_or_default(),
                leader: field_leader.unwrap_or_default(),
                items: field_items.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::CreateEdgeIndexReq {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                index_name: ::std::default::Default::default(),
                edge_name: ::std::default::Default::default(),
                fields: ::std::default::Default::default(),
                if_not_exists: ::std::default::Default::default(),
                comment: ::std::option::Option::None,
            }
        }
    }

    unsafe impl ::std::marker::Send for self::CreateEdgeIndexReq {}
    unsafe impl ::std::marker::Sync for self::CreateEdgeIndexReq {}

    impl ::fbthrift::GetTType for self::CreateEdgeIndexReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::CreateEdgeIndexReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("CreateEdgeIndexReq");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("index_name", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.index_name, p);
            p.write_field_end();
            p.write_field_begin("edge_name", ::fbthrift::TType::String, 3);
            ::fbthrift::Serialize::write(&self.edge_name, p);
            p.write_field_end();
            p.write_field_begin("fields", ::fbthrift::TType::List, 4);
            ::fbthrift::Serialize::write(&self.fields, p);
            p.write_field_end();
            p.write_field_begin("if_not_exists", ::fbthrift::TType::Bool, 5);
            ::fbthrift::Serialize::write(&self.if_not_exists, p);
            p.write_field_end();
            if let ::std::option::Option::Some(some) = &self.comment {
                p.write_field_begin("comment", ::fbthrift::TType::String, 6);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::CreateEdgeIndexReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("comment", ::fbthrift::TType::String, 6),
                ::fbthrift::Field::new("edge_name", ::fbthrift::TType::String, 3),
                ::fbthrift::Field::new("fields", ::fbthrift::TType::List, 4),
                ::fbthrift::Field::new("if_not_exists", ::fbthrift::TType::Bool, 5),
                ::fbthrift::Field::new("index_name", ::fbthrift::TType::String, 2),
                ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ];
            let mut field_space_id = ::std::option::Option::None;
            let mut field_index_name = ::std::option::Option::None;
            let mut field_edge_name = ::std::option::Option::None;
            let mut field_fields = ::std::option::Option::None;
            let mut field_if_not_exists = ::std::option::Option::None;
            let mut field_comment = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_index_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 3) => field_edge_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 4) => field_fields = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 5) => field_if_not_exists = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 6) => field_comment = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                index_name: field_index_name.unwrap_or_default(),
                edge_name: field_edge_name.unwrap_or_default(),
                fields: field_fields.unwrap_or_default(),
                if_not_exists: field_if_not_exists.unwrap_or_default(),
                comment: field_comment,
            })
        }
    }


    impl ::std::default::Default for self::DropEdgeIndexReq {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                index_name: ::std::default::Default::default(),
                if_exists: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::DropEdgeIndexReq {}
    unsafe impl ::std::marker::Sync for self::DropEdgeIndexReq {}

    impl ::fbthrift::GetTType for self::DropEdgeIndexReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::DropEdgeIndexReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("DropEdgeIndexReq");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("index_name", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.index_name, p);
            p.write_field_end();
            p.write_field_begin("if_exists", ::fbthrift::TType::Bool, 3);
            ::fbthrift::Serialize::write(&self.if_exists, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::DropEdgeIndexReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("if_exists", ::fbthrift::TType::Bool, 3),
                ::fbthrift::Field::new("index_name", ::fbthrift::TType::String, 2),
                ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ];
            let mut field_space_id = ::std::option::Option::None;
            let mut field_index_name = ::std::option::Option::None;
            let mut field_if_exists = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_index_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 3) => field_if_exists = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                index_name: field_index_name.unwrap_or_default(),
                if_exists: field_if_exists.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::GetEdgeIndexReq {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                index_name: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::GetEdgeIndexReq {}
    unsafe impl ::std::marker::Sync for self::GetEdgeIndexReq {}

    impl ::fbthrift::GetTType for self::GetEdgeIndexReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GetEdgeIndexReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetEdgeIndexReq");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("index_name", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.index_name, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GetEdgeIndexReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("index_name", ::fbthrift::TType::String, 2),
                ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ];
            let mut field_space_id = ::std::option::Option::None;
            let mut field_index_name = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_index_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                index_name: field_index_name.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::GetEdgeIndexResp {
        fn default() -> Self {
            Self {
                code: ::std::default::Default::default(),
                leader: ::std::default::Default::default(),
                item: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::GetEdgeIndexResp {}
    unsafe impl ::std::marker::Sync for self::GetEdgeIndexResp {}

    impl ::fbthrift::GetTType for self::GetEdgeIndexResp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GetEdgeIndexResp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetEdgeIndexResp");
            p.write_field_begin("code", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.code, p);
            p.write_field_end();
            p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.leader, p);
            p.write_field_end();
            p.write_field_begin("item", ::fbthrift::TType::Struct, 3);
            ::fbthrift::Serialize::write(&self.item, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GetEdgeIndexResp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("item", ::fbthrift::TType::Struct, 3),
                ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ];
            let mut field_code = ::std::option::Option::None;
            let mut field_leader = ::std::option::Option::None;
            let mut field_item = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 3) => field_item = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                code: field_code.unwrap_or_default(),
                leader: field_leader.unwrap_or_default(),
                item: field_item.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ListEdgeIndexesReq {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ListEdgeIndexesReq {}
    unsafe impl ::std::marker::Sync for self::ListEdgeIndexesReq {}

    impl ::fbthrift::GetTType for self::ListEdgeIndexesReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ListEdgeIndexesReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ListEdgeIndexesReq");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ListEdgeIndexesReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ];
            let mut field_space_id = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ListEdgeIndexesResp {
        fn default() -> Self {
            Self {
                code: ::std::default::Default::default(),
                leader: ::std::default::Default::default(),
                items: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ListEdgeIndexesResp {}
    unsafe impl ::std::marker::Sync for self::ListEdgeIndexesResp {}

    impl ::fbthrift::GetTType for self::ListEdgeIndexesResp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ListEdgeIndexesResp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ListEdgeIndexesResp");
            p.write_field_begin("code", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.code, p);
            p.write_field_end();
            p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.leader, p);
            p.write_field_end();
            p.write_field_begin("items", ::fbthrift::TType::List, 3);
            ::fbthrift::Serialize::write(&self.items, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ListEdgeIndexesResp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("items", ::fbthrift::TType::List, 3),
                ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ];
            let mut field_code = ::std::option::Option::None;
            let mut field_leader = ::std::option::Option::None;
            let mut field_items = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 3) => field_items = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                code: field_code.unwrap_or_default(),
                leader: field_leader.unwrap_or_default(),
                items: field_items.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::RebuildIndexReq {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                index_name: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::RebuildIndexReq {}
    unsafe impl ::std::marker::Sync for self::RebuildIndexReq {}

    impl ::fbthrift::GetTType for self::RebuildIndexReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::RebuildIndexReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("RebuildIndexReq");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("index_name", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.index_name, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::RebuildIndexReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("index_name", ::fbthrift::TType::String, 2),
                ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ];
            let mut field_space_id = ::std::option::Option::None;
            let mut field_index_name = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_index_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                index_name: field_index_name.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::CreateUserReq {
        fn default() -> Self {
            Self {
                account: ::std::default::Default::default(),
                encoded_pwd: ::std::default::Default::default(),
                if_not_exists: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::CreateUserReq {}
    unsafe impl ::std::marker::Sync for self::CreateUserReq {}

    impl ::fbthrift::GetTType for self::CreateUserReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::CreateUserReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("CreateUserReq");
            p.write_field_begin("account", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.account, p);
            p.write_field_end();
            p.write_field_begin("encoded_pwd", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.encoded_pwd, p);
            p.write_field_end();
            p.write_field_begin("if_not_exists", ::fbthrift::TType::Bool, 3);
            ::fbthrift::Serialize::write(&self.if_not_exists, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::CreateUserReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("account", ::fbthrift::TType::String, 1),
                ::fbthrift::Field::new("encoded_pwd", ::fbthrift::TType::String, 2),
                ::fbthrift::Field::new("if_not_exists", ::fbthrift::TType::Bool, 3),
            ];
            let mut field_account = ::std::option::Option::None;
            let mut field_encoded_pwd = ::std::option::Option::None;
            let mut field_if_not_exists = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_account = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_encoded_pwd = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 3) => field_if_not_exists = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                account: field_account.unwrap_or_default(),
                encoded_pwd: field_encoded_pwd.unwrap_or_default(),
                if_not_exists: field_if_not_exists.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::DropUserReq {
        fn default() -> Self {
            Self {
                account: ::std::default::Default::default(),
                if_exists: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::DropUserReq {}
    unsafe impl ::std::marker::Sync for self::DropUserReq {}

    impl ::fbthrift::GetTType for self::DropUserReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::DropUserReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("DropUserReq");
            p.write_field_begin("account", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.account, p);
            p.write_field_end();
            p.write_field_begin("if_exists", ::fbthrift::TType::Bool, 2);
            ::fbthrift::Serialize::write(&self.if_exists, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::DropUserReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("account", ::fbthrift::TType::String, 1),
                ::fbthrift::Field::new("if_exists", ::fbthrift::TType::Bool, 2),
            ];
            let mut field_account = ::std::option::Option::None;
            let mut field_if_exists = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_account = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 2) => field_if_exists = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                account: field_account.unwrap_or_default(),
                if_exists: field_if_exists.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::AlterUserReq {
        fn default() -> Self {
            Self {
                account: ::std::default::Default::default(),
                encoded_pwd: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::AlterUserReq {}
    unsafe impl ::std::marker::Sync for self::AlterUserReq {}

    impl ::fbthrift::GetTType for self::AlterUserReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::AlterUserReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("AlterUserReq");
            p.write_field_begin("account", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.account, p);
            p.write_field_end();
            p.write_field_begin("encoded_pwd", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.encoded_pwd, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::AlterUserReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("account", ::fbthrift::TType::String, 1),
                ::fbthrift::Field::new("encoded_pwd", ::fbthrift::TType::String, 2),
            ];
            let mut field_account = ::std::option::Option::None;
            let mut field_encoded_pwd = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_account = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_encoded_pwd = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                account: field_account.unwrap_or_default(),
                encoded_pwd: field_encoded_pwd.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::GrantRoleReq {
        fn default() -> Self {
            Self {
                role_item: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::GrantRoleReq {}
    unsafe impl ::std::marker::Sync for self::GrantRoleReq {}

    impl ::fbthrift::GetTType for self::GrantRoleReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GrantRoleReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GrantRoleReq");
            p.write_field_begin("role_item", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(&self.role_item, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GrantRoleReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("role_item", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_role_item = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_role_item = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                role_item: field_role_item.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::RevokeRoleReq {
        fn default() -> Self {
            Self {
                role_item: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::RevokeRoleReq {}
    unsafe impl ::std::marker::Sync for self::RevokeRoleReq {}

    impl ::fbthrift::GetTType for self::RevokeRoleReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::RevokeRoleReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("RevokeRoleReq");
            p.write_field_begin("role_item", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(&self.role_item, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::RevokeRoleReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("role_item", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_role_item = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_role_item = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                role_item: field_role_item.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ListUsersReq {
        fn default() -> Self {
            Self {
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ListUsersReq {}
    unsafe impl ::std::marker::Sync for self::ListUsersReq {}

    impl ::fbthrift::GetTType for self::ListUsersReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ListUsersReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ListUsersReq");
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ListUsersReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
            ];
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
            })
        }
    }


    impl ::std::default::Default for self::ListUsersResp {
        fn default() -> Self {
            Self {
                code: ::std::default::Default::default(),
                leader: ::std::default::Default::default(),
                users: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ListUsersResp {}
    unsafe impl ::std::marker::Sync for self::ListUsersResp {}

    impl ::fbthrift::GetTType for self::ListUsersResp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ListUsersResp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ListUsersResp");
            p.write_field_begin("code", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.code, p);
            p.write_field_end();
            p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.leader, p);
            p.write_field_end();
            p.write_field_begin("users", ::fbthrift::TType::Map, 3);
            ::fbthrift::Serialize::write(&self.users, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ListUsersResp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
                ::fbthrift::Field::new("users", ::fbthrift::TType::Map, 3),
            ];
            let mut field_code = ::std::option::Option::None;
            let mut field_leader = ::std::option::Option::None;
            let mut field_users = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 3) => field_users = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                code: field_code.unwrap_or_default(),
                leader: field_leader.unwrap_or_default(),
                users: field_users.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ListRolesReq {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ListRolesReq {}
    unsafe impl ::std::marker::Sync for self::ListRolesReq {}

    impl ::fbthrift::GetTType for self::ListRolesReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ListRolesReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ListRolesReq");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ListRolesReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ];
            let mut field_space_id = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ListRolesResp {
        fn default() -> Self {
            Self {
                code: ::std::default::Default::default(),
                leader: ::std::default::Default::default(),
                roles: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ListRolesResp {}
    unsafe impl ::std::marker::Sync for self::ListRolesResp {}

    impl ::fbthrift::GetTType for self::ListRolesResp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ListRolesResp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ListRolesResp");
            p.write_field_begin("code", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.code, p);
            p.write_field_end();
            p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.leader, p);
            p.write_field_end();
            p.write_field_begin("roles", ::fbthrift::TType::List, 3);
            ::fbthrift::Serialize::write(&self.roles, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ListRolesResp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
                ::fbthrift::Field::new("roles", ::fbthrift::TType::List, 3),
            ];
            let mut field_code = ::std::option::Option::None;
            let mut field_leader = ::std::option::Option::None;
            let mut field_roles = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 3) => field_roles = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                code: field_code.unwrap_or_default(),
                leader: field_leader.unwrap_or_default(),
                roles: field_roles.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::GetUserRolesReq {
        fn default() -> Self {
            Self {
                account: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::GetUserRolesReq {}
    unsafe impl ::std::marker::Sync for self::GetUserRolesReq {}

    impl ::fbthrift::GetTType for self::GetUserRolesReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GetUserRolesReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetUserRolesReq");
            p.write_field_begin("account", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.account, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GetUserRolesReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("account", ::fbthrift::TType::String, 1),
            ];
            let mut field_account = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_account = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                account: field_account.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ChangePasswordReq {
        fn default() -> Self {
            Self {
                account: ::std::default::Default::default(),
                new_encoded_pwd: ::std::default::Default::default(),
                old_encoded_pwd: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ChangePasswordReq {}
    unsafe impl ::std::marker::Sync for self::ChangePasswordReq {}

    impl ::fbthrift::GetTType for self::ChangePasswordReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ChangePasswordReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ChangePasswordReq");
            p.write_field_begin("account", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.account, p);
            p.write_field_end();
            p.write_field_begin("new_encoded_pwd", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.new_encoded_pwd, p);
            p.write_field_end();
            p.write_field_begin("old_encoded_pwd", ::fbthrift::TType::String, 3);
            ::fbthrift::Serialize::write(&self.old_encoded_pwd, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ChangePasswordReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("account", ::fbthrift::TType::String, 1),
                ::fbthrift::Field::new("new_encoded_pwd", ::fbthrift::TType::String, 2),
                ::fbthrift::Field::new("old_encoded_pwd", ::fbthrift::TType::String, 3),
            ];
            let mut field_account = ::std::option::Option::None;
            let mut field_new_encoded_pwd = ::std::option::Option::None;
            let mut field_old_encoded_pwd = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_account = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_new_encoded_pwd = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 3) => field_old_encoded_pwd = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                account: field_account.unwrap_or_default(),
                new_encoded_pwd: field_new_encoded_pwd.unwrap_or_default(),
                old_encoded_pwd: field_old_encoded_pwd.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::BalanceReq {
        fn default() -> Self {
            Self {
                space_id: ::std::option::Option::None,
                id: ::std::option::Option::None,
                host_del: ::std::option::Option::None,
                stop: ::std::option::Option::None,
                reset: ::std::option::Option::None,
            }
        }
    }

    unsafe impl ::std::marker::Send for self::BalanceReq {}
    unsafe impl ::std::marker::Sync for self::BalanceReq {}

    impl ::fbthrift::GetTType for self::BalanceReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::BalanceReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("BalanceReq");
            if let ::std::option::Option::Some(some) = &self.space_id {
                p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.id {
                p.write_field_begin("id", ::fbthrift::TType::I64, 2);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.host_del {
                p.write_field_begin("host_del", ::fbthrift::TType::List, 3);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.stop {
                p.write_field_begin("stop", ::fbthrift::TType::Bool, 4);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.reset {
                p.write_field_begin("reset", ::fbthrift::TType::Bool, 5);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::BalanceReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("host_del", ::fbthrift::TType::List, 3),
                ::fbthrift::Field::new("id", ::fbthrift::TType::I64, 2),
                ::fbthrift::Field::new("reset", ::fbthrift::TType::Bool, 5),
                ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("stop", ::fbthrift::TType::Bool, 4),
            ];
            let mut field_space_id = ::std::option::Option::None;
            let mut field_id = ::std::option::Option::None;
            let mut field_host_del = ::std::option::Option::None;
            let mut field_stop = ::std::option::Option::None;
            let mut field_reset = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 2) => field_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 3) => field_host_del = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 4) => field_stop = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 5) => field_reset = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id,
                id: field_id,
                host_del: field_host_del,
                stop: field_stop,
                reset: field_reset,
            })
        }
    }


    impl ::std::default::Default for self::BalanceTask {
        fn default() -> Self {
            Self {
                id: ::std::default::Default::default(),
                result: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::BalanceTask {}
    unsafe impl ::std::marker::Sync for self::BalanceTask {}

    impl ::fbthrift::GetTType for self::BalanceTask {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::BalanceTask
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("BalanceTask");
            p.write_field_begin("id", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.id, p);
            p.write_field_end();
            p.write_field_begin("result", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.result, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::BalanceTask
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("id", ::fbthrift::TType::String, 1),
                ::fbthrift::Field::new("result", ::fbthrift::TType::I32, 2),
            ];
            let mut field_id = ::std::option::Option::None;
            let mut field_result = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_result = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                id: field_id.unwrap_or_default(),
                result: field_result.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::BalanceResp {
        fn default() -> Self {
            Self {
                code: ::std::default::Default::default(),
                id: ::std::default::Default::default(),
                leader: ::std::default::Default::default(),
                tasks: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::BalanceResp {}
    unsafe impl ::std::marker::Sync for self::BalanceResp {}

    impl ::fbthrift::GetTType for self::BalanceResp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::BalanceResp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("BalanceResp");
            p.write_field_begin("code", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.code, p);
            p.write_field_end();
            p.write_field_begin("id", ::fbthrift::TType::I64, 2);
            ::fbthrift::Serialize::write(&self.id, p);
            p.write_field_end();
            p.write_field_begin("leader", ::fbthrift::TType::Struct, 3);
            ::fbthrift::Serialize::write(&self.leader, p);
            p.write_field_end();
            p.write_field_begin("tasks", ::fbthrift::TType::List, 4);
            ::fbthrift::Serialize::write(&self.tasks, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::BalanceResp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("id", ::fbthrift::TType::I64, 2),
                ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 3),
                ::fbthrift::Field::new("tasks", ::fbthrift::TType::List, 4),
            ];
            let mut field_code = ::std::option::Option::None;
            let mut field_id = ::std::option::Option::None;
            let mut field_leader = ::std::option::Option::None;
            let mut field_tasks = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 2) => field_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 3) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 4) => field_tasks = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                code: field_code.unwrap_or_default(),
                id: field_id.unwrap_or_default(),
                leader: field_leader.unwrap_or_default(),
                tasks: field_tasks.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::LeaderBalanceReq {
        fn default() -> Self {
            Self {
            }
        }
    }

    unsafe impl ::std::marker::Send for self::LeaderBalanceReq {}
    unsafe impl ::std::marker::Sync for self::LeaderBalanceReq {}

    impl ::fbthrift::GetTType for self::LeaderBalanceReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::LeaderBalanceReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("LeaderBalanceReq");
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::LeaderBalanceReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
            ];
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
            })
        }
    }


    impl ::std::default::Default for self::ConfigItem {
        fn default() -> Self {
            Self {
                module: ::std::default::Default::default(),
                name: ::std::default::Default::default(),
                mode: ::std::default::Default::default(),
                value: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ConfigItem {}
    unsafe impl ::std::marker::Sync for self::ConfigItem {}

    impl ::fbthrift::GetTType for self::ConfigItem {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ConfigItem
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ConfigItem");
            p.write_field_begin("module", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.module, p);
            p.write_field_end();
            p.write_field_begin("name", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.name, p);
            p.write_field_end();
            p.write_field_begin("mode", ::fbthrift::TType::I32, 3);
            ::fbthrift::Serialize::write(&self.mode, p);
            p.write_field_end();
            p.write_field_begin("value", ::fbthrift::TType::Struct, 4);
            ::fbthrift::Serialize::write(&self.value, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ConfigItem
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("mode", ::fbthrift::TType::I32, 3),
                ::fbthrift::Field::new("module", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("name", ::fbthrift::TType::String, 2),
                ::fbthrift::Field::new("value", ::fbthrift::TType::Struct, 4),
            ];
            let mut field_module = ::std::option::Option::None;
            let mut field_name = ::std::option::Option::None;
            let mut field_mode = ::std::option::Option::None;
            let mut field_value = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_module = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 3) => field_mode = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 4) => field_value = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                module: field_module.unwrap_or_default(),
                name: field_name.unwrap_or_default(),
                mode: field_mode.unwrap_or_default(),
                value: field_value.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::RegConfigReq {
        fn default() -> Self {
            Self {
                items: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::RegConfigReq {}
    unsafe impl ::std::marker::Sync for self::RegConfigReq {}

    impl ::fbthrift::GetTType for self::RegConfigReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::RegConfigReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("RegConfigReq");
            p.write_field_begin("items", ::fbthrift::TType::List, 1);
            ::fbthrift::Serialize::write(&self.items, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::RegConfigReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("items", ::fbthrift::TType::List, 1),
            ];
            let mut field_items = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::List, 1) => field_items = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                items: field_items.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::GetConfigReq {
        fn default() -> Self {
            Self {
                item: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::GetConfigReq {}
    unsafe impl ::std::marker::Sync for self::GetConfigReq {}

    impl ::fbthrift::GetTType for self::GetConfigReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GetConfigReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetConfigReq");
            p.write_field_begin("item", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(&self.item, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GetConfigReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("item", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_item = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_item = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                item: field_item.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::GetConfigResp {
        fn default() -> Self {
            Self {
                code: ::std::default::Default::default(),
                leader: ::std::default::Default::default(),
                items: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::GetConfigResp {}
    unsafe impl ::std::marker::Sync for self::GetConfigResp {}

    impl ::fbthrift::GetTType for self::GetConfigResp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GetConfigResp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetConfigResp");
            p.write_field_begin("code", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.code, p);
            p.write_field_end();
            p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.leader, p);
            p.write_field_end();
            p.write_field_begin("items", ::fbthrift::TType::List, 3);
            ::fbthrift::Serialize::write(&self.items, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GetConfigResp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("items", ::fbthrift::TType::List, 3),
                ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ];
            let mut field_code = ::std::option::Option::None;
            let mut field_leader = ::std::option::Option::None;
            let mut field_items = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 3) => field_items = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                code: field_code.unwrap_or_default(),
                leader: field_leader.unwrap_or_default(),
                items: field_items.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::SetConfigReq {
        fn default() -> Self {
            Self {
                item: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::SetConfigReq {}
    unsafe impl ::std::marker::Sync for self::SetConfigReq {}

    impl ::fbthrift::GetTType for self::SetConfigReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::SetConfigReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("SetConfigReq");
            p.write_field_begin("item", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(&self.item, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::SetConfigReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("item", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_item = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_item = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                item: field_item.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ListConfigsReq {
        fn default() -> Self {
            Self {
                space: ::std::default::Default::default(),
                module: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ListConfigsReq {}
    unsafe impl ::std::marker::Sync for self::ListConfigsReq {}

    impl ::fbthrift::GetTType for self::ListConfigsReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ListConfigsReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ListConfigsReq");
            p.write_field_begin("space", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.space, p);
            p.write_field_end();
            p.write_field_begin("module", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.module, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ListConfigsReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("module", ::fbthrift::TType::I32, 2),
                ::fbthrift::Field::new("space", ::fbthrift::TType::String, 1),
            ];
            let mut field_space = ::std::option::Option::None;
            let mut field_module = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_space = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_module = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space: field_space.unwrap_or_default(),
                module: field_module.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ListConfigsResp {
        fn default() -> Self {
            Self {
                code: ::std::default::Default::default(),
                leader: ::std::default::Default::default(),
                items: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ListConfigsResp {}
    unsafe impl ::std::marker::Sync for self::ListConfigsResp {}

    impl ::fbthrift::GetTType for self::ListConfigsResp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ListConfigsResp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ListConfigsResp");
            p.write_field_begin("code", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.code, p);
            p.write_field_end();
            p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.leader, p);
            p.write_field_end();
            p.write_field_begin("items", ::fbthrift::TType::List, 3);
            ::fbthrift::Serialize::write(&self.items, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ListConfigsResp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("items", ::fbthrift::TType::List, 3),
                ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ];
            let mut field_code = ::std::option::Option::None;
            let mut field_leader = ::std::option::Option::None;
            let mut field_items = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 3) => field_items = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                code: field_code.unwrap_or_default(),
                leader: field_leader.unwrap_or_default(),
                items: field_items.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::CreateSnapshotReq {
        fn default() -> Self {
            Self {
            }
        }
    }

    unsafe impl ::std::marker::Send for self::CreateSnapshotReq {}
    unsafe impl ::std::marker::Sync for self::CreateSnapshotReq {}

    impl ::fbthrift::GetTType for self::CreateSnapshotReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::CreateSnapshotReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("CreateSnapshotReq");
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::CreateSnapshotReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
            ];
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
            })
        }
    }


    impl ::std::default::Default for self::DropSnapshotReq {
        fn default() -> Self {
            Self {
                name: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::DropSnapshotReq {}
    unsafe impl ::std::marker::Sync for self::DropSnapshotReq {}

    impl ::fbthrift::GetTType for self::DropSnapshotReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::DropSnapshotReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("DropSnapshotReq");
            p.write_field_begin("name", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.name, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::DropSnapshotReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("name", ::fbthrift::TType::String, 1),
            ];
            let mut field_name = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                name: field_name.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ListSnapshotsReq {
        fn default() -> Self {
            Self {
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ListSnapshotsReq {}
    unsafe impl ::std::marker::Sync for self::ListSnapshotsReq {}

    impl ::fbthrift::GetTType for self::ListSnapshotsReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ListSnapshotsReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ListSnapshotsReq");
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ListSnapshotsReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
            ];
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
            })
        }
    }


    impl ::std::default::Default for self::Snapshot {
        fn default() -> Self {
            Self {
                name: ::std::default::Default::default(),
                status: ::std::default::Default::default(),
                hosts: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::Snapshot {}
    unsafe impl ::std::marker::Sync for self::Snapshot {}

    impl ::fbthrift::GetTType for self::Snapshot {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::Snapshot
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("Snapshot");
            p.write_field_begin("name", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.name, p);
            p.write_field_end();
            p.write_field_begin("status", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.status, p);
            p.write_field_end();
            p.write_field_begin("hosts", ::fbthrift::TType::String, 3);
            ::fbthrift::Serialize::write(&self.hosts, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::Snapshot
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("hosts", ::fbthrift::TType::String, 3),
                ::fbthrift::Field::new("name", ::fbthrift::TType::String, 1),
                ::fbthrift::Field::new("status", ::fbthrift::TType::I32, 2),
            ];
            let mut field_name = ::std::option::Option::None;
            let mut field_status = ::std::option::Option::None;
            let mut field_hosts = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_status = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 3) => field_hosts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                name: field_name.unwrap_or_default(),
                status: field_status.unwrap_or_default(),
                hosts: field_hosts.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ListSnapshotsResp {
        fn default() -> Self {
            Self {
                code: ::std::default::Default::default(),
                leader: ::std::default::Default::default(),
                snapshots: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ListSnapshotsResp {}
    unsafe impl ::std::marker::Sync for self::ListSnapshotsResp {}

    impl ::fbthrift::GetTType for self::ListSnapshotsResp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ListSnapshotsResp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ListSnapshotsResp");
            p.write_field_begin("code", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.code, p);
            p.write_field_end();
            p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.leader, p);
            p.write_field_end();
            p.write_field_begin("snapshots", ::fbthrift::TType::List, 3);
            ::fbthrift::Serialize::write(&self.snapshots, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ListSnapshotsResp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
                ::fbthrift::Field::new("snapshots", ::fbthrift::TType::List, 3),
            ];
            let mut field_code = ::std::option::Option::None;
            let mut field_leader = ::std::option::Option::None;
            let mut field_snapshots = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 3) => field_snapshots = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                code: field_code.unwrap_or_default(),
                leader: field_leader.unwrap_or_default(),
                snapshots: field_snapshots.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ListIndexStatusReq {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ListIndexStatusReq {}
    unsafe impl ::std::marker::Sync for self::ListIndexStatusReq {}

    impl ::fbthrift::GetTType for self::ListIndexStatusReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ListIndexStatusReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ListIndexStatusReq");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ListIndexStatusReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ];
            let mut field_space_id = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::IndexStatus {
        fn default() -> Self {
            Self {
                name: ::std::default::Default::default(),
                status: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::IndexStatus {}
    unsafe impl ::std::marker::Sync for self::IndexStatus {}

    impl ::fbthrift::GetTType for self::IndexStatus {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::IndexStatus
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("IndexStatus");
            p.write_field_begin("name", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.name, p);
            p.write_field_end();
            p.write_field_begin("status", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.status, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::IndexStatus
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("name", ::fbthrift::TType::String, 1),
                ::fbthrift::Field::new("status", ::fbthrift::TType::String, 2),
            ];
            let mut field_name = ::std::option::Option::None;
            let mut field_status = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_status = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                name: field_name.unwrap_or_default(),
                status: field_status.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ListIndexStatusResp {
        fn default() -> Self {
            Self {
                code: ::std::default::Default::default(),
                leader: ::std::default::Default::default(),
                statuses: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ListIndexStatusResp {}
    unsafe impl ::std::marker::Sync for self::ListIndexStatusResp {}

    impl ::fbthrift::GetTType for self::ListIndexStatusResp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ListIndexStatusResp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ListIndexStatusResp");
            p.write_field_begin("code", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.code, p);
            p.write_field_end();
            p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.leader, p);
            p.write_field_end();
            p.write_field_begin("statuses", ::fbthrift::TType::List, 3);
            ::fbthrift::Serialize::write(&self.statuses, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ListIndexStatusResp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
                ::fbthrift::Field::new("statuses", ::fbthrift::TType::List, 3),
            ];
            let mut field_code = ::std::option::Option::None;
            let mut field_leader = ::std::option::Option::None;
            let mut field_statuses = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 3) => field_statuses = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                code: field_code.unwrap_or_default(),
                leader: field_leader.unwrap_or_default(),
                statuses: field_statuses.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::AddZoneReq {
        fn default() -> Self {
            Self {
                zone_name: ::std::default::Default::default(),
                nodes: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::AddZoneReq {}
    unsafe impl ::std::marker::Sync for self::AddZoneReq {}

    impl ::fbthrift::GetTType for self::AddZoneReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::AddZoneReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("AddZoneReq");
            p.write_field_begin("zone_name", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.zone_name, p);
            p.write_field_end();
            p.write_field_begin("nodes", ::fbthrift::TType::List, 2);
            ::fbthrift::Serialize::write(&self.nodes, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::AddZoneReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("nodes", ::fbthrift::TType::List, 2),
                ::fbthrift::Field::new("zone_name", ::fbthrift::TType::String, 1),
            ];
            let mut field_zone_name = ::std::option::Option::None;
            let mut field_nodes = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_zone_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 2) => field_nodes = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                zone_name: field_zone_name.unwrap_or_default(),
                nodes: field_nodes.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::DropZoneReq {
        fn default() -> Self {
            Self {
                zone_name: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::DropZoneReq {}
    unsafe impl ::std::marker::Sync for self::DropZoneReq {}

    impl ::fbthrift::GetTType for self::DropZoneReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::DropZoneReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("DropZoneReq");
            p.write_field_begin("zone_name", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.zone_name, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::DropZoneReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("zone_name", ::fbthrift::TType::String, 1),
            ];
            let mut field_zone_name = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_zone_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                zone_name: field_zone_name.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::AddHostIntoZoneReq {
        fn default() -> Self {
            Self {
                node: ::std::default::Default::default(),
                zone_name: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::AddHostIntoZoneReq {}
    unsafe impl ::std::marker::Sync for self::AddHostIntoZoneReq {}

    impl ::fbthrift::GetTType for self::AddHostIntoZoneReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::AddHostIntoZoneReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("AddHostIntoZoneReq");
            p.write_field_begin("node", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(&self.node, p);
            p.write_field_end();
            p.write_field_begin("zone_name", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.zone_name, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::AddHostIntoZoneReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("node", ::fbthrift::TType::Struct, 1),
                ::fbthrift::Field::new("zone_name", ::fbthrift::TType::String, 2),
            ];
            let mut field_node = ::std::option::Option::None;
            let mut field_zone_name = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_node = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_zone_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                node: field_node.unwrap_or_default(),
                zone_name: field_zone_name.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::DropHostFromZoneReq {
        fn default() -> Self {
            Self {
                node: ::std::default::Default::default(),
                zone_name: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::DropHostFromZoneReq {}
    unsafe impl ::std::marker::Sync for self::DropHostFromZoneReq {}

    impl ::fbthrift::GetTType for self::DropHostFromZoneReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::DropHostFromZoneReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("DropHostFromZoneReq");
            p.write_field_begin("node", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(&self.node, p);
            p.write_field_end();
            p.write_field_begin("zone_name", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.zone_name, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::DropHostFromZoneReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("node", ::fbthrift::TType::Struct, 1),
                ::fbthrift::Field::new("zone_name", ::fbthrift::TType::String, 2),
            ];
            let mut field_node = ::std::option::Option::None;
            let mut field_zone_name = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_node = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_zone_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                node: field_node.unwrap_or_default(),
                zone_name: field_zone_name.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::GetZoneReq {
        fn default() -> Self {
            Self {
                zone_name: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::GetZoneReq {}
    unsafe impl ::std::marker::Sync for self::GetZoneReq {}

    impl ::fbthrift::GetTType for self::GetZoneReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GetZoneReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetZoneReq");
            p.write_field_begin("zone_name", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.zone_name, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GetZoneReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("zone_name", ::fbthrift::TType::String, 1),
            ];
            let mut field_zone_name = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_zone_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                zone_name: field_zone_name.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::GetZoneResp {
        fn default() -> Self {
            Self {
                code: ::std::default::Default::default(),
                leader: ::std::default::Default::default(),
                hosts: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::GetZoneResp {}
    unsafe impl ::std::marker::Sync for self::GetZoneResp {}

    impl ::fbthrift::GetTType for self::GetZoneResp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GetZoneResp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetZoneResp");
            p.write_field_begin("code", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.code, p);
            p.write_field_end();
            p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.leader, p);
            p.write_field_end();
            p.write_field_begin("hosts", ::fbthrift::TType::List, 3);
            ::fbthrift::Serialize::write(&self.hosts, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GetZoneResp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("hosts", ::fbthrift::TType::List, 3),
                ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ];
            let mut field_code = ::std::option::Option::None;
            let mut field_leader = ::std::option::Option::None;
            let mut field_hosts = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 3) => field_hosts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                code: field_code.unwrap_or_default(),
                leader: field_leader.unwrap_or_default(),
                hosts: field_hosts.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ListZonesReq {
        fn default() -> Self {
            Self {
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ListZonesReq {}
    unsafe impl ::std::marker::Sync for self::ListZonesReq {}

    impl ::fbthrift::GetTType for self::ListZonesReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ListZonesReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ListZonesReq");
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ListZonesReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
            ];
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
            })
        }
    }


    impl ::std::default::Default for self::Zone {
        fn default() -> Self {
            Self {
                zone_name: ::std::default::Default::default(),
                nodes: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::Zone {}
    unsafe impl ::std::marker::Sync for self::Zone {}

    impl ::fbthrift::GetTType for self::Zone {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::Zone
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("Zone");
            p.write_field_begin("zone_name", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.zone_name, p);
            p.write_field_end();
            p.write_field_begin("nodes", ::fbthrift::TType::List, 2);
            ::fbthrift::Serialize::write(&self.nodes, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::Zone
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("nodes", ::fbthrift::TType::List, 2),
                ::fbthrift::Field::new("zone_name", ::fbthrift::TType::String, 1),
            ];
            let mut field_zone_name = ::std::option::Option::None;
            let mut field_nodes = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_zone_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 2) => field_nodes = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                zone_name: field_zone_name.unwrap_or_default(),
                nodes: field_nodes.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ListZonesResp {
        fn default() -> Self {
            Self {
                code: ::std::default::Default::default(),
                leader: ::std::default::Default::default(),
                zones: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ListZonesResp {}
    unsafe impl ::std::marker::Sync for self::ListZonesResp {}

    impl ::fbthrift::GetTType for self::ListZonesResp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ListZonesResp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ListZonesResp");
            p.write_field_begin("code", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.code, p);
            p.write_field_end();
            p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.leader, p);
            p.write_field_end();
            p.write_field_begin("zones", ::fbthrift::TType::List, 3);
            ::fbthrift::Serialize::write(&self.zones, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ListZonesResp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
                ::fbthrift::Field::new("zones", ::fbthrift::TType::List, 3),
            ];
            let mut field_code = ::std::option::Option::None;
            let mut field_leader = ::std::option::Option::None;
            let mut field_zones = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 3) => field_zones = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                code: field_code.unwrap_or_default(),
                leader: field_leader.unwrap_or_default(),
                zones: field_zones.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::AddGroupReq {
        fn default() -> Self {
            Self {
                group_name: ::std::default::Default::default(),
                zone_names: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::AddGroupReq {}
    unsafe impl ::std::marker::Sync for self::AddGroupReq {}

    impl ::fbthrift::GetTType for self::AddGroupReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::AddGroupReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("AddGroupReq");
            p.write_field_begin("group_name", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.group_name, p);
            p.write_field_end();
            p.write_field_begin("zone_names", ::fbthrift::TType::List, 2);
            ::fbthrift::Serialize::write(&self.zone_names, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::AddGroupReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("group_name", ::fbthrift::TType::String, 1),
                ::fbthrift::Field::new("zone_names", ::fbthrift::TType::List, 2),
            ];
            let mut field_group_name = ::std::option::Option::None;
            let mut field_zone_names = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_group_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 2) => field_zone_names = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                group_name: field_group_name.unwrap_or_default(),
                zone_names: field_zone_names.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::DropGroupReq {
        fn default() -> Self {
            Self {
                group_name: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::DropGroupReq {}
    unsafe impl ::std::marker::Sync for self::DropGroupReq {}

    impl ::fbthrift::GetTType for self::DropGroupReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::DropGroupReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("DropGroupReq");
            p.write_field_begin("group_name", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.group_name, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::DropGroupReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("group_name", ::fbthrift::TType::String, 1),
            ];
            let mut field_group_name = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_group_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                group_name: field_group_name.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::AddZoneIntoGroupReq {
        fn default() -> Self {
            Self {
                zone_name: ::std::default::Default::default(),
                group_name: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::AddZoneIntoGroupReq {}
    unsafe impl ::std::marker::Sync for self::AddZoneIntoGroupReq {}

    impl ::fbthrift::GetTType for self::AddZoneIntoGroupReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::AddZoneIntoGroupReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("AddZoneIntoGroupReq");
            p.write_field_begin("zone_name", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.zone_name, p);
            p.write_field_end();
            p.write_field_begin("group_name", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.group_name, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::AddZoneIntoGroupReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("group_name", ::fbthrift::TType::String, 2),
                ::fbthrift::Field::new("zone_name", ::fbthrift::TType::String, 1),
            ];
            let mut field_zone_name = ::std::option::Option::None;
            let mut field_group_name = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_zone_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_group_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                zone_name: field_zone_name.unwrap_or_default(),
                group_name: field_group_name.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::DropZoneFromGroupReq {
        fn default() -> Self {
            Self {
                zone_name: ::std::default::Default::default(),
                group_name: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::DropZoneFromGroupReq {}
    unsafe impl ::std::marker::Sync for self::DropZoneFromGroupReq {}

    impl ::fbthrift::GetTType for self::DropZoneFromGroupReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::DropZoneFromGroupReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("DropZoneFromGroupReq");
            p.write_field_begin("zone_name", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.zone_name, p);
            p.write_field_end();
            p.write_field_begin("group_name", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.group_name, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::DropZoneFromGroupReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("group_name", ::fbthrift::TType::String, 2),
                ::fbthrift::Field::new("zone_name", ::fbthrift::TType::String, 1),
            ];
            let mut field_zone_name = ::std::option::Option::None;
            let mut field_group_name = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_zone_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_group_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                zone_name: field_zone_name.unwrap_or_default(),
                group_name: field_group_name.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::GetGroupReq {
        fn default() -> Self {
            Self {
                group_name: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::GetGroupReq {}
    unsafe impl ::std::marker::Sync for self::GetGroupReq {}

    impl ::fbthrift::GetTType for self::GetGroupReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GetGroupReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetGroupReq");
            p.write_field_begin("group_name", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.group_name, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GetGroupReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("group_name", ::fbthrift::TType::String, 1),
            ];
            let mut field_group_name = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_group_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                group_name: field_group_name.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::GetGroupResp {
        fn default() -> Self {
            Self {
                code: ::std::default::Default::default(),
                leader: ::std::default::Default::default(),
                zone_names: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::GetGroupResp {}
    unsafe impl ::std::marker::Sync for self::GetGroupResp {}

    impl ::fbthrift::GetTType for self::GetGroupResp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GetGroupResp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetGroupResp");
            p.write_field_begin("code", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.code, p);
            p.write_field_end();
            p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.leader, p);
            p.write_field_end();
            p.write_field_begin("zone_names", ::fbthrift::TType::List, 3);
            ::fbthrift::Serialize::write(&self.zone_names, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GetGroupResp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
                ::fbthrift::Field::new("zone_names", ::fbthrift::TType::List, 3),
            ];
            let mut field_code = ::std::option::Option::None;
            let mut field_leader = ::std::option::Option::None;
            let mut field_zone_names = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 3) => field_zone_names = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                code: field_code.unwrap_or_default(),
                leader: field_leader.unwrap_or_default(),
                zone_names: field_zone_names.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ListGroupsReq {
        fn default() -> Self {
            Self {
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ListGroupsReq {}
    unsafe impl ::std::marker::Sync for self::ListGroupsReq {}

    impl ::fbthrift::GetTType for self::ListGroupsReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ListGroupsReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ListGroupsReq");
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ListGroupsReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
            ];
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
            })
        }
    }


    impl ::std::default::Default for self::Group {
        fn default() -> Self {
            Self {
                group_name: ::std::default::Default::default(),
                zone_names: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::Group {}
    unsafe impl ::std::marker::Sync for self::Group {}

    impl ::fbthrift::GetTType for self::Group {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::Group
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("Group");
            p.write_field_begin("group_name", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.group_name, p);
            p.write_field_end();
            p.write_field_begin("zone_names", ::fbthrift::TType::List, 2);
            ::fbthrift::Serialize::write(&self.zone_names, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::Group
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("group_name", ::fbthrift::TType::String, 1),
                ::fbthrift::Field::new("zone_names", ::fbthrift::TType::List, 2),
            ];
            let mut field_group_name = ::std::option::Option::None;
            let mut field_zone_names = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_group_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 2) => field_zone_names = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                group_name: field_group_name.unwrap_or_default(),
                zone_names: field_zone_names.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ListGroupsResp {
        fn default() -> Self {
            Self {
                code: ::std::default::Default::default(),
                leader: ::std::default::Default::default(),
                groups: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ListGroupsResp {}
    unsafe impl ::std::marker::Sync for self::ListGroupsResp {}

    impl ::fbthrift::GetTType for self::ListGroupsResp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ListGroupsResp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ListGroupsResp");
            p.write_field_begin("code", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.code, p);
            p.write_field_end();
            p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.leader, p);
            p.write_field_end();
            p.write_field_begin("groups", ::fbthrift::TType::List, 3);
            ::fbthrift::Serialize::write(&self.groups, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ListGroupsResp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("groups", ::fbthrift::TType::List, 3),
                ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ];
            let mut field_code = ::std::option::Option::None;
            let mut field_leader = ::std::option::Option::None;
            let mut field_groups = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 3) => field_groups = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                code: field_code.unwrap_or_default(),
                leader: field_leader.unwrap_or_default(),
                groups: field_groups.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::AddListenerReq {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                type_: ::std::default::Default::default(),
                hosts: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::AddListenerReq {}
    unsafe impl ::std::marker::Sync for self::AddListenerReq {}

    impl ::fbthrift::GetTType for self::AddListenerReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::AddListenerReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("AddListenerReq");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("type", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.type_, p);
            p.write_field_end();
            p.write_field_begin("hosts", ::fbthrift::TType::List, 3);
            ::fbthrift::Serialize::write(&self.hosts, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::AddListenerReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("hosts", ::fbthrift::TType::List, 3),
                ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("type", ::fbthrift::TType::I32, 2),
            ];
            let mut field_space_id = ::std::option::Option::None;
            let mut field_type = ::std::option::Option::None;
            let mut field_hosts = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_type = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 3) => field_hosts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                type_: field_type.unwrap_or_default(),
                hosts: field_hosts.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::RemoveListenerReq {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                type_: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::RemoveListenerReq {}
    unsafe impl ::std::marker::Sync for self::RemoveListenerReq {}

    impl ::fbthrift::GetTType for self::RemoveListenerReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::RemoveListenerReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("RemoveListenerReq");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("type", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.type_, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::RemoveListenerReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("type", ::fbthrift::TType::I32, 2),
            ];
            let mut field_space_id = ::std::option::Option::None;
            let mut field_type = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_type = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                type_: field_type.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ListListenerReq {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ListListenerReq {}
    unsafe impl ::std::marker::Sync for self::ListListenerReq {}

    impl ::fbthrift::GetTType for self::ListListenerReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ListListenerReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ListListenerReq");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ListListenerReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ];
            let mut field_space_id = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ListenerInfo {
        fn default() -> Self {
            Self {
                type_: ::std::default::Default::default(),
                host: ::std::default::Default::default(),
                part_id: ::std::default::Default::default(),
                status: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ListenerInfo {}
    unsafe impl ::std::marker::Sync for self::ListenerInfo {}

    impl ::fbthrift::GetTType for self::ListenerInfo {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ListenerInfo
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ListenerInfo");
            p.write_field_begin("type", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.type_, p);
            p.write_field_end();
            p.write_field_begin("host", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.host, p);
            p.write_field_end();
            p.write_field_begin("part_id", ::fbthrift::TType::I32, 3);
            ::fbthrift::Serialize::write(&self.part_id, p);
            p.write_field_end();
            p.write_field_begin("status", ::fbthrift::TType::I32, 4);
            ::fbthrift::Serialize::write(&self.status, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ListenerInfo
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("host", ::fbthrift::TType::Struct, 2),
                ::fbthrift::Field::new("part_id", ::fbthrift::TType::I32, 3),
                ::fbthrift::Field::new("status", ::fbthrift::TType::I32, 4),
                ::fbthrift::Field::new("type", ::fbthrift::TType::I32, 1),
            ];
            let mut field_type = ::std::option::Option::None;
            let mut field_host = ::std::option::Option::None;
            let mut field_part_id = ::std::option::Option::None;
            let mut field_status = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_type = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_host = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 3) => field_part_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 4) => field_status = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                type_: field_type.unwrap_or_default(),
                host: field_host.unwrap_or_default(),
                part_id: field_part_id.unwrap_or_default(),
                status: field_status.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ListListenerResp {
        fn default() -> Self {
            Self {
                code: ::std::default::Default::default(),
                leader: ::std::default::Default::default(),
                listeners: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ListListenerResp {}
    unsafe impl ::std::marker::Sync for self::ListListenerResp {}

    impl ::fbthrift::GetTType for self::ListListenerResp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ListListenerResp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ListListenerResp");
            p.write_field_begin("code", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.code, p);
            p.write_field_end();
            p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.leader, p);
            p.write_field_end();
            p.write_field_begin("listeners", ::fbthrift::TType::List, 3);
            ::fbthrift::Serialize::write(&self.listeners, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ListListenerResp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
                ::fbthrift::Field::new("listeners", ::fbthrift::TType::List, 3),
            ];
            let mut field_code = ::std::option::Option::None;
            let mut field_leader = ::std::option::Option::None;
            let mut field_listeners = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 3) => field_listeners = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                code: field_code.unwrap_or_default(),
                leader: field_leader.unwrap_or_default(),
                listeners: field_listeners.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::GetStatisReq {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::GetStatisReq {}
    unsafe impl ::std::marker::Sync for self::GetStatisReq {}

    impl ::fbthrift::GetTType for self::GetStatisReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GetStatisReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetStatisReq");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GetStatisReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("space_id", ::fbthrift::TType::I32, 1),
            ];
            let mut field_space_id = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::GetStatisResp {
        fn default() -> Self {
            Self {
                code: ::std::default::Default::default(),
                leader: ::std::default::Default::default(),
                statis: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::GetStatisResp {}
    unsafe impl ::std::marker::Sync for self::GetStatisResp {}

    impl ::fbthrift::GetTType for self::GetStatisResp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GetStatisResp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetStatisResp");
            p.write_field_begin("code", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.code, p);
            p.write_field_end();
            p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.leader, p);
            p.write_field_end();
            p.write_field_begin("statis", ::fbthrift::TType::Struct, 3);
            ::fbthrift::Serialize::write(&self.statis, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GetStatisResp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
                ::fbthrift::Field::new("statis", ::fbthrift::TType::Struct, 3),
            ];
            let mut field_code = ::std::option::Option::None;
            let mut field_leader = ::std::option::Option::None;
            let mut field_statis = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 3) => field_statis = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                code: field_code.unwrap_or_default(),
                leader: field_leader.unwrap_or_default(),
                statis: field_statis.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::CheckpointInfo {
        fn default() -> Self {
            Self {
                host: ::std::default::Default::default(),
                checkpoint_dir: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::CheckpointInfo {}
    unsafe impl ::std::marker::Sync for self::CheckpointInfo {}

    impl ::fbthrift::GetTType for self::CheckpointInfo {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::CheckpointInfo
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("CheckpointInfo");
            p.write_field_begin("host", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(&self.host, p);
            p.write_field_end();
            p.write_field_begin("checkpoint_dir", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.checkpoint_dir, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::CheckpointInfo
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("checkpoint_dir", ::fbthrift::TType::String, 2),
                ::fbthrift::Field::new("host", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_host = ::std::option::Option::None;
            let mut field_checkpoint_dir = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_host = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_checkpoint_dir = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                host: field_host.unwrap_or_default(),
                checkpoint_dir: field_checkpoint_dir.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::SpaceBackupInfo {
        fn default() -> Self {
            Self {
                space: ::std::default::Default::default(),
                partition_info: ::std::default::Default::default(),
                cp_dirs: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::SpaceBackupInfo {}
    unsafe impl ::std::marker::Sync for self::SpaceBackupInfo {}

    impl ::fbthrift::GetTType for self::SpaceBackupInfo {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::SpaceBackupInfo
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("SpaceBackupInfo");
            p.write_field_begin("space", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(&self.space, p);
            p.write_field_end();
            p.write_field_begin("partition_info", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.partition_info, p);
            p.write_field_end();
            p.write_field_begin("cp_dirs", ::fbthrift::TType::List, 3);
            ::fbthrift::Serialize::write(&self.cp_dirs, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::SpaceBackupInfo
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("cp_dirs", ::fbthrift::TType::List, 3),
                ::fbthrift::Field::new("partition_info", ::fbthrift::TType::Struct, 2),
                ::fbthrift::Field::new("space", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_space = ::std::option::Option::None;
            let mut field_partition_info = ::std::option::Option::None;
            let mut field_cp_dirs = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_space = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_partition_info = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 3) => field_cp_dirs = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space: field_space.unwrap_or_default(),
                partition_info: field_partition_info.unwrap_or_default(),
                cp_dirs: field_cp_dirs.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::BackupMeta {
        fn default() -> Self {
            Self {
                backup_info: ::std::default::Default::default(),
                meta_files: ::std::default::Default::default(),
                backup_name: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::BackupMeta {}
    unsafe impl ::std::marker::Sync for self::BackupMeta {}

    impl ::fbthrift::GetTType for self::BackupMeta {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::BackupMeta
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("BackupMeta");
            p.write_field_begin("backup_info", ::fbthrift::TType::Map, 1);
            ::fbthrift::Serialize::write(&self.backup_info, p);
            p.write_field_end();
            p.write_field_begin("meta_files", ::fbthrift::TType::List, 2);
            ::fbthrift::Serialize::write(&self.meta_files, p);
            p.write_field_end();
            p.write_field_begin("backup_name", ::fbthrift::TType::String, 3);
            ::fbthrift::Serialize::write(&self.backup_name, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::BackupMeta
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("backup_info", ::fbthrift::TType::Map, 1),
                ::fbthrift::Field::new("backup_name", ::fbthrift::TType::String, 3),
                ::fbthrift::Field::new("meta_files", ::fbthrift::TType::List, 2),
            ];
            let mut field_backup_info = ::std::option::Option::None;
            let mut field_meta_files = ::std::option::Option::None;
            let mut field_backup_name = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Map, 1) => field_backup_info = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 2) => field_meta_files = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 3) => field_backup_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                backup_info: field_backup_info.unwrap_or_default(),
                meta_files: field_meta_files.unwrap_or_default(),
                backup_name: field_backup_name.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::CreateBackupReq {
        fn default() -> Self {
            Self {
                spaces: ::std::option::Option::None,
            }
        }
    }

    unsafe impl ::std::marker::Send for self::CreateBackupReq {}
    unsafe impl ::std::marker::Sync for self::CreateBackupReq {}

    impl ::fbthrift::GetTType for self::CreateBackupReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::CreateBackupReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("CreateBackupReq");
            if let ::std::option::Option::Some(some) = &self.spaces {
                p.write_field_begin("spaces", ::fbthrift::TType::List, 1);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::CreateBackupReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("spaces", ::fbthrift::TType::List, 1),
            ];
            let mut field_spaces = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::List, 1) => field_spaces = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                spaces: field_spaces,
            })
        }
    }


    impl ::std::default::Default for self::CreateBackupResp {
        fn default() -> Self {
            Self {
                code: ::std::default::Default::default(),
                leader: ::std::default::Default::default(),
                meta: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::CreateBackupResp {}
    unsafe impl ::std::marker::Sync for self::CreateBackupResp {}

    impl ::fbthrift::GetTType for self::CreateBackupResp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::CreateBackupResp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("CreateBackupResp");
            p.write_field_begin("code", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.code, p);
            p.write_field_end();
            p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.leader, p);
            p.write_field_end();
            p.write_field_begin("meta", ::fbthrift::TType::Struct, 3);
            ::fbthrift::Serialize::write(&self.meta, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::CreateBackupResp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
                ::fbthrift::Field::new("meta", ::fbthrift::TType::Struct, 3),
            ];
            let mut field_code = ::std::option::Option::None;
            let mut field_leader = ::std::option::Option::None;
            let mut field_meta = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 3) => field_meta = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                code: field_code.unwrap_or_default(),
                leader: field_leader.unwrap_or_default(),
                meta: field_meta.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::HostPair {
        fn default() -> Self {
            Self {
                from_host: ::std::default::Default::default(),
                to_host: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::HostPair {}
    unsafe impl ::std::marker::Sync for self::HostPair {}

    impl ::fbthrift::GetTType for self::HostPair {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::HostPair
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("HostPair");
            p.write_field_begin("from_host", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(&self.from_host, p);
            p.write_field_end();
            p.write_field_begin("to_host", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.to_host, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::HostPair
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("from_host", ::fbthrift::TType::Struct, 1),
                ::fbthrift::Field::new("to_host", ::fbthrift::TType::Struct, 2),
            ];
            let mut field_from_host = ::std::option::Option::None;
            let mut field_to_host = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_from_host = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_to_host = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                from_host: field_from_host.unwrap_or_default(),
                to_host: field_to_host.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::RestoreMetaReq {
        fn default() -> Self {
            Self {
                files: ::std::default::Default::default(),
                hosts: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::RestoreMetaReq {}
    unsafe impl ::std::marker::Sync for self::RestoreMetaReq {}

    impl ::fbthrift::GetTType for self::RestoreMetaReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::RestoreMetaReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("RestoreMetaReq");
            p.write_field_begin("files", ::fbthrift::TType::List, 1);
            ::fbthrift::Serialize::write(&self.files, p);
            p.write_field_end();
            p.write_field_begin("hosts", ::fbthrift::TType::List, 2);
            ::fbthrift::Serialize::write(&self.hosts, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::RestoreMetaReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("files", ::fbthrift::TType::List, 1),
                ::fbthrift::Field::new("hosts", ::fbthrift::TType::List, 2),
            ];
            let mut field_files = ::std::option::Option::None;
            let mut field_hosts = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::List, 1) => field_files = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 2) => field_hosts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                files: field_files.unwrap_or_default(),
                hosts: field_hosts.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::FTClient {
        fn default() -> Self {
            Self {
                host: ::std::default::Default::default(),
                user: ::std::option::Option::None,
                pwd: ::std::option::Option::None,
            }
        }
    }

    unsafe impl ::std::marker::Send for self::FTClient {}
    unsafe impl ::std::marker::Sync for self::FTClient {}

    impl ::fbthrift::GetTType for self::FTClient {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::FTClient
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("FTClient");
            p.write_field_begin("host", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(&self.host, p);
            p.write_field_end();
            if let ::std::option::Option::Some(some) = &self.user {
                p.write_field_begin("user", ::fbthrift::TType::String, 2);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.pwd {
                p.write_field_begin("pwd", ::fbthrift::TType::String, 3);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::FTClient
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("host", ::fbthrift::TType::Struct, 1),
                ::fbthrift::Field::new("pwd", ::fbthrift::TType::String, 3),
                ::fbthrift::Field::new("user", ::fbthrift::TType::String, 2),
            ];
            let mut field_host = ::std::option::Option::None;
            let mut field_user = ::std::option::Option::None;
            let mut field_pwd = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_host = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_user = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 3) => field_pwd = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                host: field_host.unwrap_or_default(),
                user: field_user,
                pwd: field_pwd,
            })
        }
    }


    impl ::std::default::Default for self::SignInFTServiceReq {
        fn default() -> Self {
            Self {
                type_: ::std::default::Default::default(),
                clients: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::SignInFTServiceReq {}
    unsafe impl ::std::marker::Sync for self::SignInFTServiceReq {}

    impl ::fbthrift::GetTType for self::SignInFTServiceReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::SignInFTServiceReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("SignInFTServiceReq");
            p.write_field_begin("type", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.type_, p);
            p.write_field_end();
            p.write_field_begin("clients", ::fbthrift::TType::List, 2);
            ::fbthrift::Serialize::write(&self.clients, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::SignInFTServiceReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("clients", ::fbthrift::TType::List, 2),
                ::fbthrift::Field::new("type", ::fbthrift::TType::I32, 1),
            ];
            let mut field_type = ::std::option::Option::None;
            let mut field_clients = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_type = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 2) => field_clients = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                type_: field_type.unwrap_or_default(),
                clients: field_clients.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::SignOutFTServiceReq {
        fn default() -> Self {
            Self {
            }
        }
    }

    unsafe impl ::std::marker::Send for self::SignOutFTServiceReq {}
    unsafe impl ::std::marker::Sync for self::SignOutFTServiceReq {}

    impl ::fbthrift::GetTType for self::SignOutFTServiceReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::SignOutFTServiceReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("SignOutFTServiceReq");
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::SignOutFTServiceReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
            ];
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
            })
        }
    }


    impl ::std::default::Default for self::ListFTClientsReq {
        fn default() -> Self {
            Self {
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ListFTClientsReq {}
    unsafe impl ::std::marker::Sync for self::ListFTClientsReq {}

    impl ::fbthrift::GetTType for self::ListFTClientsReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ListFTClientsReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ListFTClientsReq");
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ListFTClientsReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
            ];
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
            })
        }
    }


    impl ::std::default::Default for self::ListFTClientsResp {
        fn default() -> Self {
            Self {
                code: ::std::default::Default::default(),
                leader: ::std::default::Default::default(),
                clients: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ListFTClientsResp {}
    unsafe impl ::std::marker::Sync for self::ListFTClientsResp {}

    impl ::fbthrift::GetTType for self::ListFTClientsResp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ListFTClientsResp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ListFTClientsResp");
            p.write_field_begin("code", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.code, p);
            p.write_field_end();
            p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.leader, p);
            p.write_field_end();
            p.write_field_begin("clients", ::fbthrift::TType::List, 3);
            ::fbthrift::Serialize::write(&self.clients, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ListFTClientsResp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("clients", ::fbthrift::TType::List, 3),
                ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
            ];
            let mut field_code = ::std::option::Option::None;
            let mut field_leader = ::std::option::Option::None;
            let mut field_clients = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 3) => field_clients = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                code: field_code.unwrap_or_default(),
                leader: field_leader.unwrap_or_default(),
                clients: field_clients.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::Session {
        fn default() -> Self {
            Self {
                session_id: ::std::default::Default::default(),
                create_time: ::std::default::Default::default(),
                update_time: ::std::default::Default::default(),
                user_name: ::std::default::Default::default(),
                space_name: ::std::default::Default::default(),
                graph_addr: ::std::default::Default::default(),
                timezone: ::std::default::Default::default(),
                client_ip: ::std::default::Default::default(),
                configs: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::Session {}
    unsafe impl ::std::marker::Sync for self::Session {}

    impl ::fbthrift::GetTType for self::Session {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::Session
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("Session");
            p.write_field_begin("session_id", ::fbthrift::TType::I64, 1);
            ::fbthrift::Serialize::write(&self.session_id, p);
            p.write_field_end();
            p.write_field_begin("create_time", ::fbthrift::TType::I64, 2);
            ::fbthrift::Serialize::write(&self.create_time, p);
            p.write_field_end();
            p.write_field_begin("update_time", ::fbthrift::TType::I64, 3);
            ::fbthrift::Serialize::write(&self.update_time, p);
            p.write_field_end();
            p.write_field_begin("user_name", ::fbthrift::TType::String, 4);
            ::fbthrift::Serialize::write(&self.user_name, p);
            p.write_field_end();
            p.write_field_begin("space_name", ::fbthrift::TType::String, 5);
            ::fbthrift::Serialize::write(&self.space_name, p);
            p.write_field_end();
            p.write_field_begin("graph_addr", ::fbthrift::TType::Struct, 6);
            ::fbthrift::Serialize::write(&self.graph_addr, p);
            p.write_field_end();
            p.write_field_begin("timezone", ::fbthrift::TType::I32, 7);
            ::fbthrift::Serialize::write(&self.timezone, p);
            p.write_field_end();
            p.write_field_begin("client_ip", ::fbthrift::TType::String, 8);
            ::fbthrift::Serialize::write(&self.client_ip, p);
            p.write_field_end();
            p.write_field_begin("configs", ::fbthrift::TType::Map, 9);
            ::fbthrift::Serialize::write(&self.configs, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::Session
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("client_ip", ::fbthrift::TType::String, 8),
                ::fbthrift::Field::new("configs", ::fbthrift::TType::Map, 9),
                ::fbthrift::Field::new("create_time", ::fbthrift::TType::I64, 2),
                ::fbthrift::Field::new("graph_addr", ::fbthrift::TType::Struct, 6),
                ::fbthrift::Field::new("session_id", ::fbthrift::TType::I64, 1),
                ::fbthrift::Field::new("space_name", ::fbthrift::TType::String, 5),
                ::fbthrift::Field::new("timezone", ::fbthrift::TType::I32, 7),
                ::fbthrift::Field::new("update_time", ::fbthrift::TType::I64, 3),
                ::fbthrift::Field::new("user_name", ::fbthrift::TType::String, 4),
            ];
            let mut field_session_id = ::std::option::Option::None;
            let mut field_create_time = ::std::option::Option::None;
            let mut field_update_time = ::std::option::Option::None;
            let mut field_user_name = ::std::option::Option::None;
            let mut field_space_name = ::std::option::Option::None;
            let mut field_graph_addr = ::std::option::Option::None;
            let mut field_timezone = ::std::option::Option::None;
            let mut field_client_ip = ::std::option::Option::None;
            let mut field_configs = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I64, 1) => field_session_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 2) => field_create_time = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 3) => field_update_time = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 4) => field_user_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 5) => field_space_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 6) => field_graph_addr = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 7) => field_timezone = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 8) => field_client_ip = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 9) => field_configs = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                session_id: field_session_id.unwrap_or_default(),
                create_time: field_create_time.unwrap_or_default(),
                update_time: field_update_time.unwrap_or_default(),
                user_name: field_user_name.unwrap_or_default(),
                space_name: field_space_name.unwrap_or_default(),
                graph_addr: field_graph_addr.unwrap_or_default(),
                timezone: field_timezone.unwrap_or_default(),
                client_ip: field_client_ip.unwrap_or_default(),
                configs: field_configs.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::CreateSessionReq {
        fn default() -> Self {
            Self {
                user: ::std::default::Default::default(),
                graph_addr: ::std::default::Default::default(),
                client_ip: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::CreateSessionReq {}
    unsafe impl ::std::marker::Sync for self::CreateSessionReq {}

    impl ::fbthrift::GetTType for self::CreateSessionReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::CreateSessionReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("CreateSessionReq");
            p.write_field_begin("user", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.user, p);
            p.write_field_end();
            p.write_field_begin("graph_addr", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.graph_addr, p);
            p.write_field_end();
            p.write_field_begin("client_ip", ::fbthrift::TType::String, 3);
            ::fbthrift::Serialize::write(&self.client_ip, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::CreateSessionReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("client_ip", ::fbthrift::TType::String, 3),
                ::fbthrift::Field::new("graph_addr", ::fbthrift::TType::Struct, 2),
                ::fbthrift::Field::new("user", ::fbthrift::TType::String, 1),
            ];
            let mut field_user = ::std::option::Option::None;
            let mut field_graph_addr = ::std::option::Option::None;
            let mut field_client_ip = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_user = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_graph_addr = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 3) => field_client_ip = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                user: field_user.unwrap_or_default(),
                graph_addr: field_graph_addr.unwrap_or_default(),
                client_ip: field_client_ip.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::CreateSessionResp {
        fn default() -> Self {
            Self {
                code: ::std::default::Default::default(),
                leader: ::std::default::Default::default(),
                session: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::CreateSessionResp {}
    unsafe impl ::std::marker::Sync for self::CreateSessionResp {}

    impl ::fbthrift::GetTType for self::CreateSessionResp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::CreateSessionResp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("CreateSessionResp");
            p.write_field_begin("code", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.code, p);
            p.write_field_end();
            p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.leader, p);
            p.write_field_end();
            p.write_field_begin("session", ::fbthrift::TType::Struct, 3);
            ::fbthrift::Serialize::write(&self.session, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::CreateSessionResp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
                ::fbthrift::Field::new("session", ::fbthrift::TType::Struct, 3),
            ];
            let mut field_code = ::std::option::Option::None;
            let mut field_leader = ::std::option::Option::None;
            let mut field_session = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 3) => field_session = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                code: field_code.unwrap_or_default(),
                leader: field_leader.unwrap_or_default(),
                session: field_session.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::UpdateSessionsReq {
        fn default() -> Self {
            Self {
                sessions: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::UpdateSessionsReq {}
    unsafe impl ::std::marker::Sync for self::UpdateSessionsReq {}

    impl ::fbthrift::GetTType for self::UpdateSessionsReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::UpdateSessionsReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("UpdateSessionsReq");
            p.write_field_begin("sessions", ::fbthrift::TType::List, 1);
            ::fbthrift::Serialize::write(&self.sessions, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::UpdateSessionsReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("sessions", ::fbthrift::TType::List, 1),
            ];
            let mut field_sessions = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::List, 1) => field_sessions = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                sessions: field_sessions.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ListSessionsReq {
        fn default() -> Self {
            Self {
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ListSessionsReq {}
    unsafe impl ::std::marker::Sync for self::ListSessionsReq {}

    impl ::fbthrift::GetTType for self::ListSessionsReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ListSessionsReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ListSessionsReq");
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ListSessionsReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
            ];
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
            })
        }
    }


    impl ::std::default::Default for self::ListSessionsResp {
        fn default() -> Self {
            Self {
                code: ::std::default::Default::default(),
                leader: ::std::default::Default::default(),
                sessions: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ListSessionsResp {}
    unsafe impl ::std::marker::Sync for self::ListSessionsResp {}

    impl ::fbthrift::GetTType for self::ListSessionsResp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ListSessionsResp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ListSessionsResp");
            p.write_field_begin("code", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.code, p);
            p.write_field_end();
            p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.leader, p);
            p.write_field_end();
            p.write_field_begin("sessions", ::fbthrift::TType::List, 3);
            ::fbthrift::Serialize::write(&self.sessions, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ListSessionsResp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
                ::fbthrift::Field::new("sessions", ::fbthrift::TType::List, 3),
            ];
            let mut field_code = ::std::option::Option::None;
            let mut field_leader = ::std::option::Option::None;
            let mut field_sessions = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 3) => field_sessions = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                code: field_code.unwrap_or_default(),
                leader: field_leader.unwrap_or_default(),
                sessions: field_sessions.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::GetSessionReq {
        fn default() -> Self {
            Self {
                session_id: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::GetSessionReq {}
    unsafe impl ::std::marker::Sync for self::GetSessionReq {}

    impl ::fbthrift::GetTType for self::GetSessionReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GetSessionReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetSessionReq");
            p.write_field_begin("session_id", ::fbthrift::TType::I64, 1);
            ::fbthrift::Serialize::write(&self.session_id, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GetSessionReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("session_id", ::fbthrift::TType::I64, 1),
            ];
            let mut field_session_id = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I64, 1) => field_session_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                session_id: field_session_id.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::GetSessionResp {
        fn default() -> Self {
            Self {
                code: ::std::default::Default::default(),
                leader: ::std::default::Default::default(),
                session: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::GetSessionResp {}
    unsafe impl ::std::marker::Sync for self::GetSessionResp {}

    impl ::fbthrift::GetTType for self::GetSessionResp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GetSessionResp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetSessionResp");
            p.write_field_begin("code", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.code, p);
            p.write_field_end();
            p.write_field_begin("leader", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.leader, p);
            p.write_field_end();
            p.write_field_begin("session", ::fbthrift::TType::Struct, 3);
            ::fbthrift::Serialize::write(&self.session, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GetSessionResp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("leader", ::fbthrift::TType::Struct, 2),
                ::fbthrift::Field::new("session", ::fbthrift::TType::Struct, 3),
            ];
            let mut field_code = ::std::option::Option::None;
            let mut field_leader = ::std::option::Option::None;
            let mut field_session = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 3) => field_session = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                code: field_code.unwrap_or_default(),
                leader: field_leader.unwrap_or_default(),
                session: field_session.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::RemoveSessionReq {
        fn default() -> Self {
            Self {
                session_id: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::RemoveSessionReq {}
    unsafe impl ::std::marker::Sync for self::RemoveSessionReq {}

    impl ::fbthrift::GetTType for self::RemoveSessionReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::RemoveSessionReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("RemoveSessionReq");
            p.write_field_begin("session_id", ::fbthrift::TType::I64, 1);
            ::fbthrift::Serialize::write(&self.session_id, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::RemoveSessionReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("session_id", ::fbthrift::TType::I64, 1),
            ];
            let mut field_session_id = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I64, 1) => field_session_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                session_id: field_session_id.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ReportTaskReq {
        fn default() -> Self {
            Self {
                code: ::std::default::Default::default(),
                job_id: ::std::default::Default::default(),
                task_id: ::std::default::Default::default(),
                statis: ::std::option::Option::None,
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ReportTaskReq {}
    unsafe impl ::std::marker::Sync for self::ReportTaskReq {}

    impl ::fbthrift::GetTType for self::ReportTaskReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ReportTaskReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ReportTaskReq");
            p.write_field_begin("code", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.code, p);
            p.write_field_end();
            p.write_field_begin("job_id", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.job_id, p);
            p.write_field_end();
            p.write_field_begin("task_id", ::fbthrift::TType::I32, 3);
            ::fbthrift::Serialize::write(&self.task_id, p);
            p.write_field_end();
            if let ::std::option::Option::Some(some) = &self.statis {
                p.write_field_begin("statis", ::fbthrift::TType::Struct, 4);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ReportTaskReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("code", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("job_id", ::fbthrift::TType::I32, 2),
                ::fbthrift::Field::new("statis", ::fbthrift::TType::Struct, 4),
                ::fbthrift::Field::new("task_id", ::fbthrift::TType::I32, 3),
            ];
            let mut field_code = ::std::option::Option::None;
            let mut field_job_id = ::std::option::Option::None;
            let mut field_task_id = ::std::option::Option::None;
            let mut field_statis = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_job_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 3) => field_task_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 4) => field_statis = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                code: field_code.unwrap_or_default(),
                job_id: field_job_id.unwrap_or_default(),
                task_id: field_task_id.unwrap_or_default(),
                statis: field_statis,
            })
        }
    }

}

pub mod dependencies {
    pub use common as common;
}

pub mod services {
    pub mod meta_service {

        #[derive(Clone, Debug)]
        pub enum CreateSpaceExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for CreateSpaceExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                CreateSpaceExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for CreateSpaceExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for CreateSpaceExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("CreateSpace");
                match self {
                    CreateSpaceExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    CreateSpaceExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for CreateSpaceExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(CreateSpaceExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "CreateSpaceExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "CreateSpaceExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DropSpaceExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DropSpaceExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                DropSpaceExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for DropSpaceExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DropSpaceExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("DropSpace");
                match self {
                    DropSpaceExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DropSpaceExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DropSpaceExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(DropSpaceExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DropSpaceExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DropSpaceExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetSpaceExn {
            Success(crate::types::GetSpaceResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetSpaceExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetSpaceExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetSpaceExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetSpaceExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetSpace");
                match self {
                    GetSpaceExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetSpaceExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetSpaceExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetSpaceExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetSpaceExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetSpaceExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListSpacesExn {
            Success(crate::types::ListSpacesResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ListSpacesExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                ListSpacesExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for ListSpacesExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ListSpacesExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("ListSpaces");
                match self {
                    ListSpacesExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    ListSpacesExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ListSpacesExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(ListSpacesExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListSpacesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListSpacesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum CreateTagExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for CreateTagExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                CreateTagExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for CreateTagExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for CreateTagExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("CreateTag");
                match self {
                    CreateTagExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    CreateTagExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for CreateTagExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(CreateTagExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "CreateTagExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "CreateTagExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum AlterTagExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for AlterTagExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                AlterTagExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for AlterTagExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for AlterTagExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("AlterTag");
                match self {
                    AlterTagExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    AlterTagExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for AlterTagExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(AlterTagExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "AlterTagExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "AlterTagExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DropTagExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DropTagExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                DropTagExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for DropTagExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DropTagExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("DropTag");
                match self {
                    DropTagExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DropTagExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DropTagExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(DropTagExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DropTagExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DropTagExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetTagExn {
            Success(crate::types::GetTagResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetTagExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetTagExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetTagExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetTagExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetTag");
                match self {
                    GetTagExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetTagExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetTagExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetTagExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetTagExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetTagExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListTagsExn {
            Success(crate::types::ListTagsResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ListTagsExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                ListTagsExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for ListTagsExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ListTagsExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("ListTags");
                match self {
                    ListTagsExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    ListTagsExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ListTagsExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(ListTagsExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListTagsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListTagsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum CreateEdgeExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for CreateEdgeExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                CreateEdgeExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for CreateEdgeExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for CreateEdgeExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("CreateEdge");
                match self {
                    CreateEdgeExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    CreateEdgeExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for CreateEdgeExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(CreateEdgeExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "CreateEdgeExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "CreateEdgeExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum AlterEdgeExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for AlterEdgeExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                AlterEdgeExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for AlterEdgeExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for AlterEdgeExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("AlterEdge");
                match self {
                    AlterEdgeExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    AlterEdgeExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for AlterEdgeExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(AlterEdgeExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "AlterEdgeExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "AlterEdgeExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DropEdgeExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DropEdgeExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                DropEdgeExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for DropEdgeExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DropEdgeExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("DropEdge");
                match self {
                    DropEdgeExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DropEdgeExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DropEdgeExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(DropEdgeExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DropEdgeExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DropEdgeExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetEdgeExn {
            Success(crate::types::GetEdgeResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetEdgeExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetEdgeExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetEdgeExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetEdgeExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetEdge");
                match self {
                    GetEdgeExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetEdgeExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetEdgeExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetEdgeExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetEdgeExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetEdgeExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListEdgesExn {
            Success(crate::types::ListEdgesResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ListEdgesExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                ListEdgesExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for ListEdgesExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ListEdgesExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("ListEdges");
                match self {
                    ListEdgesExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    ListEdgesExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ListEdgesExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(ListEdgesExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListEdgesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListEdgesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListHostsExn {
            Success(crate::types::ListHostsResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ListHostsExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                ListHostsExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for ListHostsExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ListHostsExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("ListHosts");
                match self {
                    ListHostsExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    ListHostsExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ListHostsExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(ListHostsExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListHostsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListHostsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetPartsAllocExn {
            Success(crate::types::GetPartsAllocResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetPartsAllocExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetPartsAllocExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetPartsAllocExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetPartsAllocExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetPartsAlloc");
                match self {
                    GetPartsAllocExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetPartsAllocExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetPartsAllocExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetPartsAllocExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetPartsAllocExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetPartsAllocExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListPartsExn {
            Success(crate::types::ListPartsResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ListPartsExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                ListPartsExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for ListPartsExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ListPartsExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("ListParts");
                match self {
                    ListPartsExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    ListPartsExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ListPartsExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(ListPartsExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListPartsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListPartsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum MultiPutExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for MultiPutExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                MultiPutExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for MultiPutExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for MultiPutExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("MultiPut");
                match self {
                    MultiPutExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    MultiPutExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for MultiPutExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(MultiPutExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "MultiPutExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "MultiPutExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetExn {
            Success(crate::types::GetResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("Get");
                match self {
                    GetExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum MultiGetExn {
            Success(crate::types::MultiGetResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for MultiGetExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                MultiGetExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for MultiGetExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for MultiGetExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("MultiGet");
                match self {
                    MultiGetExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    MultiGetExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for MultiGetExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(MultiGetExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "MultiGetExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "MultiGetExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum RemoveExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for RemoveExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                RemoveExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for RemoveExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for RemoveExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("Remove");
                match self {
                    RemoveExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    RemoveExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for RemoveExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(RemoveExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "RemoveExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "RemoveExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum RemoveRangeExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for RemoveRangeExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                RemoveRangeExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for RemoveRangeExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for RemoveRangeExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("RemoveRange");
                match self {
                    RemoveRangeExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    RemoveRangeExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for RemoveRangeExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(RemoveRangeExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "RemoveRangeExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "RemoveRangeExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ScanExn {
            Success(crate::types::ScanResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ScanExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                ScanExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for ScanExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ScanExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("Scan");
                match self {
                    ScanExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    ScanExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ScanExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(ScanExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ScanExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ScanExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum CreateTagIndexExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for CreateTagIndexExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                CreateTagIndexExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for CreateTagIndexExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for CreateTagIndexExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("CreateTagIndex");
                match self {
                    CreateTagIndexExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    CreateTagIndexExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for CreateTagIndexExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(CreateTagIndexExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "CreateTagIndexExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "CreateTagIndexExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DropTagIndexExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DropTagIndexExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                DropTagIndexExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for DropTagIndexExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DropTagIndexExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("DropTagIndex");
                match self {
                    DropTagIndexExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DropTagIndexExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DropTagIndexExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(DropTagIndexExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DropTagIndexExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DropTagIndexExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetTagIndexExn {
            Success(crate::types::GetTagIndexResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetTagIndexExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetTagIndexExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetTagIndexExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetTagIndexExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetTagIndex");
                match self {
                    GetTagIndexExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetTagIndexExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetTagIndexExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetTagIndexExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetTagIndexExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetTagIndexExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListTagIndexesExn {
            Success(crate::types::ListTagIndexesResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ListTagIndexesExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                ListTagIndexesExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for ListTagIndexesExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ListTagIndexesExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("ListTagIndexes");
                match self {
                    ListTagIndexesExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    ListTagIndexesExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ListTagIndexesExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(ListTagIndexesExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListTagIndexesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListTagIndexesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum RebuildTagIndexExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for RebuildTagIndexExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                RebuildTagIndexExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for RebuildTagIndexExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for RebuildTagIndexExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("RebuildTagIndex");
                match self {
                    RebuildTagIndexExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    RebuildTagIndexExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for RebuildTagIndexExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(RebuildTagIndexExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "RebuildTagIndexExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "RebuildTagIndexExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListTagIndexStatusExn {
            Success(crate::types::ListIndexStatusResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ListTagIndexStatusExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                ListTagIndexStatusExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for ListTagIndexStatusExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ListTagIndexStatusExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("ListTagIndexStatus");
                match self {
                    ListTagIndexStatusExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    ListTagIndexStatusExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ListTagIndexStatusExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(ListTagIndexStatusExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListTagIndexStatusExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListTagIndexStatusExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum CreateEdgeIndexExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for CreateEdgeIndexExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                CreateEdgeIndexExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for CreateEdgeIndexExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for CreateEdgeIndexExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("CreateEdgeIndex");
                match self {
                    CreateEdgeIndexExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    CreateEdgeIndexExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for CreateEdgeIndexExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(CreateEdgeIndexExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "CreateEdgeIndexExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "CreateEdgeIndexExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DropEdgeIndexExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DropEdgeIndexExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                DropEdgeIndexExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for DropEdgeIndexExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DropEdgeIndexExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("DropEdgeIndex");
                match self {
                    DropEdgeIndexExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DropEdgeIndexExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DropEdgeIndexExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(DropEdgeIndexExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DropEdgeIndexExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DropEdgeIndexExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetEdgeIndexExn {
            Success(crate::types::GetEdgeIndexResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetEdgeIndexExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetEdgeIndexExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetEdgeIndexExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetEdgeIndexExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetEdgeIndex");
                match self {
                    GetEdgeIndexExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetEdgeIndexExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetEdgeIndexExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetEdgeIndexExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetEdgeIndexExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetEdgeIndexExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListEdgeIndexesExn {
            Success(crate::types::ListEdgeIndexesResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ListEdgeIndexesExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                ListEdgeIndexesExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for ListEdgeIndexesExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ListEdgeIndexesExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("ListEdgeIndexes");
                match self {
                    ListEdgeIndexesExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    ListEdgeIndexesExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ListEdgeIndexesExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(ListEdgeIndexesExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListEdgeIndexesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListEdgeIndexesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum RebuildEdgeIndexExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for RebuildEdgeIndexExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                RebuildEdgeIndexExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for RebuildEdgeIndexExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for RebuildEdgeIndexExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("RebuildEdgeIndex");
                match self {
                    RebuildEdgeIndexExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    RebuildEdgeIndexExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for RebuildEdgeIndexExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(RebuildEdgeIndexExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "RebuildEdgeIndexExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "RebuildEdgeIndexExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListEdgeIndexStatusExn {
            Success(crate::types::ListIndexStatusResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ListEdgeIndexStatusExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                ListEdgeIndexStatusExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for ListEdgeIndexStatusExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ListEdgeIndexStatusExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("ListEdgeIndexStatus");
                match self {
                    ListEdgeIndexStatusExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    ListEdgeIndexStatusExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ListEdgeIndexStatusExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(ListEdgeIndexStatusExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListEdgeIndexStatusExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListEdgeIndexStatusExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum CreateUserExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for CreateUserExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                CreateUserExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for CreateUserExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for CreateUserExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("CreateUser");
                match self {
                    CreateUserExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    CreateUserExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for CreateUserExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(CreateUserExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "CreateUserExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "CreateUserExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DropUserExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DropUserExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                DropUserExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for DropUserExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DropUserExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("DropUser");
                match self {
                    DropUserExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DropUserExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DropUserExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(DropUserExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DropUserExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DropUserExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum AlterUserExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for AlterUserExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                AlterUserExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for AlterUserExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for AlterUserExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("AlterUser");
                match self {
                    AlterUserExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    AlterUserExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for AlterUserExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(AlterUserExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "AlterUserExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "AlterUserExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GrantRoleExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GrantRoleExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GrantRoleExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GrantRoleExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GrantRoleExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GrantRole");
                match self {
                    GrantRoleExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GrantRoleExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GrantRoleExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GrantRoleExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GrantRoleExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GrantRoleExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum RevokeRoleExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for RevokeRoleExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                RevokeRoleExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for RevokeRoleExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for RevokeRoleExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("RevokeRole");
                match self {
                    RevokeRoleExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    RevokeRoleExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for RevokeRoleExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(RevokeRoleExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "RevokeRoleExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "RevokeRoleExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListUsersExn {
            Success(crate::types::ListUsersResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ListUsersExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                ListUsersExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for ListUsersExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ListUsersExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("ListUsers");
                match self {
                    ListUsersExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    ListUsersExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ListUsersExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(ListUsersExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListUsersExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListUsersExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListRolesExn {
            Success(crate::types::ListRolesResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ListRolesExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                ListRolesExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for ListRolesExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ListRolesExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("ListRoles");
                match self {
                    ListRolesExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    ListRolesExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ListRolesExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(ListRolesExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListRolesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListRolesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetUserRolesExn {
            Success(crate::types::ListRolesResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetUserRolesExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetUserRolesExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetUserRolesExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetUserRolesExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetUserRoles");
                match self {
                    GetUserRolesExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetUserRolesExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetUserRolesExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetUserRolesExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetUserRolesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetUserRolesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ChangePasswordExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ChangePasswordExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                ChangePasswordExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for ChangePasswordExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ChangePasswordExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("ChangePassword");
                match self {
                    ChangePasswordExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    ChangePasswordExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ChangePasswordExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(ChangePasswordExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ChangePasswordExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ChangePasswordExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum HeartBeatExn {
            Success(crate::types::HBResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for HeartBeatExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                HeartBeatExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for HeartBeatExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for HeartBeatExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("HeartBeat");
                match self {
                    HeartBeatExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    HeartBeatExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for HeartBeatExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(HeartBeatExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "HeartBeatExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "HeartBeatExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum BalanceExn {
            Success(crate::types::BalanceResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for BalanceExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                BalanceExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for BalanceExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for BalanceExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("Balance");
                match self {
                    BalanceExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    BalanceExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for BalanceExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(BalanceExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "BalanceExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "BalanceExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum LeaderBalanceExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for LeaderBalanceExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                LeaderBalanceExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for LeaderBalanceExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for LeaderBalanceExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("LeaderBalance");
                match self {
                    LeaderBalanceExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    LeaderBalanceExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for LeaderBalanceExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(LeaderBalanceExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "LeaderBalanceExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "LeaderBalanceExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum RegConfigExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for RegConfigExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                RegConfigExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for RegConfigExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for RegConfigExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("RegConfig");
                match self {
                    RegConfigExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    RegConfigExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for RegConfigExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(RegConfigExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "RegConfigExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "RegConfigExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetConfigExn {
            Success(crate::types::GetConfigResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetConfigExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetConfigExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetConfigExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetConfigExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetConfig");
                match self {
                    GetConfigExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetConfigExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetConfigExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetConfigExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetConfigExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetConfigExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum SetConfigExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for SetConfigExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                SetConfigExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for SetConfigExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for SetConfigExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("SetConfig");
                match self {
                    SetConfigExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    SetConfigExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for SetConfigExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(SetConfigExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "SetConfigExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "SetConfigExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListConfigsExn {
            Success(crate::types::ListConfigsResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ListConfigsExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                ListConfigsExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for ListConfigsExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ListConfigsExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("ListConfigs");
                match self {
                    ListConfigsExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    ListConfigsExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ListConfigsExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(ListConfigsExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListConfigsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListConfigsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum CreateSnapshotExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for CreateSnapshotExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                CreateSnapshotExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for CreateSnapshotExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for CreateSnapshotExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("CreateSnapshot");
                match self {
                    CreateSnapshotExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    CreateSnapshotExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for CreateSnapshotExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(CreateSnapshotExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "CreateSnapshotExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "CreateSnapshotExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DropSnapshotExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DropSnapshotExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                DropSnapshotExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for DropSnapshotExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DropSnapshotExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("DropSnapshot");
                match self {
                    DropSnapshotExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DropSnapshotExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DropSnapshotExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(DropSnapshotExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DropSnapshotExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DropSnapshotExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListSnapshotsExn {
            Success(crate::types::ListSnapshotsResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ListSnapshotsExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                ListSnapshotsExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for ListSnapshotsExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ListSnapshotsExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("ListSnapshots");
                match self {
                    ListSnapshotsExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    ListSnapshotsExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ListSnapshotsExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(ListSnapshotsExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListSnapshotsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListSnapshotsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum RunAdminJobExn {
            Success(crate::types::AdminJobResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for RunAdminJobExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                RunAdminJobExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for RunAdminJobExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for RunAdminJobExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("RunAdminJob");
                match self {
                    RunAdminJobExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    RunAdminJobExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for RunAdminJobExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(RunAdminJobExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "RunAdminJobExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "RunAdminJobExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum AddZoneExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for AddZoneExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                AddZoneExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for AddZoneExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for AddZoneExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("AddZone");
                match self {
                    AddZoneExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    AddZoneExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for AddZoneExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(AddZoneExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "AddZoneExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "AddZoneExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DropZoneExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DropZoneExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                DropZoneExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for DropZoneExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DropZoneExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("DropZone");
                match self {
                    DropZoneExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DropZoneExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DropZoneExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(DropZoneExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DropZoneExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DropZoneExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum AddHostIntoZoneExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for AddHostIntoZoneExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                AddHostIntoZoneExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for AddHostIntoZoneExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for AddHostIntoZoneExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("AddHostIntoZone");
                match self {
                    AddHostIntoZoneExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    AddHostIntoZoneExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for AddHostIntoZoneExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(AddHostIntoZoneExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "AddHostIntoZoneExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "AddHostIntoZoneExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DropHostFromZoneExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DropHostFromZoneExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                DropHostFromZoneExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for DropHostFromZoneExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DropHostFromZoneExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("DropHostFromZone");
                match self {
                    DropHostFromZoneExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DropHostFromZoneExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DropHostFromZoneExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(DropHostFromZoneExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DropHostFromZoneExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DropHostFromZoneExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetZoneExn {
            Success(crate::types::GetZoneResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetZoneExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetZoneExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetZoneExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetZoneExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetZone");
                match self {
                    GetZoneExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetZoneExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetZoneExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetZoneExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetZoneExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetZoneExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListZonesExn {
            Success(crate::types::ListZonesResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ListZonesExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                ListZonesExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for ListZonesExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ListZonesExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("ListZones");
                match self {
                    ListZonesExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    ListZonesExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ListZonesExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(ListZonesExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListZonesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListZonesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum AddGroupExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for AddGroupExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                AddGroupExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for AddGroupExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for AddGroupExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("AddGroup");
                match self {
                    AddGroupExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    AddGroupExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for AddGroupExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(AddGroupExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "AddGroupExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "AddGroupExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DropGroupExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DropGroupExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                DropGroupExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for DropGroupExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DropGroupExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("DropGroup");
                match self {
                    DropGroupExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DropGroupExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DropGroupExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(DropGroupExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DropGroupExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DropGroupExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum AddZoneIntoGroupExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for AddZoneIntoGroupExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                AddZoneIntoGroupExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for AddZoneIntoGroupExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for AddZoneIntoGroupExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("AddZoneIntoGroup");
                match self {
                    AddZoneIntoGroupExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    AddZoneIntoGroupExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for AddZoneIntoGroupExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(AddZoneIntoGroupExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "AddZoneIntoGroupExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "AddZoneIntoGroupExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DropZoneFromGroupExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DropZoneFromGroupExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                DropZoneFromGroupExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for DropZoneFromGroupExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DropZoneFromGroupExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("DropZoneFromGroup");
                match self {
                    DropZoneFromGroupExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DropZoneFromGroupExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DropZoneFromGroupExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(DropZoneFromGroupExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DropZoneFromGroupExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DropZoneFromGroupExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetGroupExn {
            Success(crate::types::GetGroupResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetGroupExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetGroupExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetGroupExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetGroupExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetGroup");
                match self {
                    GetGroupExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetGroupExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetGroupExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetGroupExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetGroupExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetGroupExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListGroupsExn {
            Success(crate::types::ListGroupsResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ListGroupsExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                ListGroupsExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for ListGroupsExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ListGroupsExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("ListGroups");
                match self {
                    ListGroupsExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    ListGroupsExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ListGroupsExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(ListGroupsExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListGroupsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListGroupsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum CreateBackupExn {
            Success(crate::types::CreateBackupResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for CreateBackupExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                CreateBackupExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for CreateBackupExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for CreateBackupExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("CreateBackup");
                match self {
                    CreateBackupExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    CreateBackupExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for CreateBackupExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(CreateBackupExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "CreateBackupExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "CreateBackupExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum RestoreMetaExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for RestoreMetaExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                RestoreMetaExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for RestoreMetaExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for RestoreMetaExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("RestoreMeta");
                match self {
                    RestoreMetaExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    RestoreMetaExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for RestoreMetaExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(RestoreMetaExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "RestoreMetaExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "RestoreMetaExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum AddListenerExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for AddListenerExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                AddListenerExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for AddListenerExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for AddListenerExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("AddListener");
                match self {
                    AddListenerExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    AddListenerExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for AddListenerExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(AddListenerExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "AddListenerExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "AddListenerExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum RemoveListenerExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for RemoveListenerExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                RemoveListenerExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for RemoveListenerExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for RemoveListenerExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("RemoveListener");
                match self {
                    RemoveListenerExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    RemoveListenerExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for RemoveListenerExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(RemoveListenerExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "RemoveListenerExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "RemoveListenerExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListListenerExn {
            Success(crate::types::ListListenerResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ListListenerExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                ListListenerExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for ListListenerExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ListListenerExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("ListListener");
                match self {
                    ListListenerExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    ListListenerExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ListListenerExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(ListListenerExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListListenerExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListListenerExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetStatisExn {
            Success(crate::types::GetStatisResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetStatisExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetStatisExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetStatisExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetStatisExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetStatis");
                match self {
                    GetStatisExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetStatisExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetStatisExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetStatisExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetStatisExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetStatisExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum SignInFTServiceExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for SignInFTServiceExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                SignInFTServiceExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for SignInFTServiceExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for SignInFTServiceExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("SignInFTService");
                match self {
                    SignInFTServiceExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    SignInFTServiceExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for SignInFTServiceExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(SignInFTServiceExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "SignInFTServiceExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "SignInFTServiceExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum SignOutFTServiceExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for SignOutFTServiceExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                SignOutFTServiceExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for SignOutFTServiceExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for SignOutFTServiceExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("SignOutFTService");
                match self {
                    SignOutFTServiceExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    SignOutFTServiceExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for SignOutFTServiceExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(SignOutFTServiceExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "SignOutFTServiceExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "SignOutFTServiceExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListFTClientsExn {
            Success(crate::types::ListFTClientsResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ListFTClientsExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                ListFTClientsExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for ListFTClientsExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ListFTClientsExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("ListFTClients");
                match self {
                    ListFTClientsExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    ListFTClientsExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ListFTClientsExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(ListFTClientsExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListFTClientsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListFTClientsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum CreateSessionExn {
            Success(crate::types::CreateSessionResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for CreateSessionExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                CreateSessionExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for CreateSessionExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for CreateSessionExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("CreateSession");
                match self {
                    CreateSessionExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    CreateSessionExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for CreateSessionExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(CreateSessionExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "CreateSessionExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "CreateSessionExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum UpdateSessionsExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for UpdateSessionsExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                UpdateSessionsExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for UpdateSessionsExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for UpdateSessionsExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("UpdateSessions");
                match self {
                    UpdateSessionsExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    UpdateSessionsExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for UpdateSessionsExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(UpdateSessionsExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "UpdateSessionsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "UpdateSessionsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListSessionsExn {
            Success(crate::types::ListSessionsResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ListSessionsExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                ListSessionsExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for ListSessionsExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ListSessionsExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("ListSessions");
                match self {
                    ListSessionsExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    ListSessionsExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ListSessionsExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(ListSessionsExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListSessionsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListSessionsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetSessionExn {
            Success(crate::types::GetSessionResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetSessionExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetSessionExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetSessionExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetSessionExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetSession");
                match self {
                    GetSessionExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetSessionExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetSessionExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetSessionExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetSessionExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetSessionExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum RemoveSessionExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for RemoveSessionExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                RemoveSessionExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for RemoveSessionExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for RemoveSessionExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("RemoveSession");
                match self {
                    RemoveSessionExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    RemoveSessionExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for RemoveSessionExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(RemoveSessionExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "RemoveSessionExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "RemoveSessionExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ReportTaskFinishExn {
            Success(crate::types::ExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ReportTaskFinishExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                ReportTaskFinishExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for ReportTaskFinishExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ReportTaskFinishExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("ReportTaskFinish");
                match self {
                    ReportTaskFinishExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    ReportTaskFinishExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ReportTaskFinishExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(ReportTaskFinishExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ReportTaskFinishExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ReportTaskFinishExn"),
                    )
                    .into(),
                )
            }
        }
    }
}

pub mod client {

    pub struct MetaServiceImpl<P, T> {
        transport: T,
        _phantom: ::std::marker::PhantomData<fn() -> P>,
    }

    impl<P, T> MetaServiceImpl<P, T> {
        pub fn new(
            transport: T,
        ) -> Self {
            Self {
                transport,
                _phantom: ::std::marker::PhantomData,
            }
        }

        pub fn transport(&self) -> &T {
            &self.transport
        }
    }

    pub trait MetaService: ::std::marker::Send {
        fn createSpace(
            &self,
            arg_req: &crate::types::CreateSpaceReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateSpaceError>> + ::std::marker::Send + 'static>>;
        fn dropSpace(
            &self,
            arg_req: &crate::types::DropSpaceReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropSpaceError>> + ::std::marker::Send + 'static>>;
        fn getSpace(
            &self,
            arg_req: &crate::types::GetSpaceReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetSpaceResp, crate::errors::meta_service::GetSpaceError>> + ::std::marker::Send + 'static>>;
        fn listSpaces(
            &self,
            arg_req: &crate::types::ListSpacesReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListSpacesResp, crate::errors::meta_service::ListSpacesError>> + ::std::marker::Send + 'static>>;
        fn createTag(
            &self,
            arg_req: &crate::types::CreateTagReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateTagError>> + ::std::marker::Send + 'static>>;
        fn alterTag(
            &self,
            arg_req: &crate::types::AlterTagReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterTagError>> + ::std::marker::Send + 'static>>;
        fn dropTag(
            &self,
            arg_req: &crate::types::DropTagReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropTagError>> + ::std::marker::Send + 'static>>;
        fn getTag(
            &self,
            arg_req: &crate::types::GetTagReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetTagResp, crate::errors::meta_service::GetTagError>> + ::std::marker::Send + 'static>>;
        fn listTags(
            &self,
            arg_req: &crate::types::ListTagsReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListTagsResp, crate::errors::meta_service::ListTagsError>> + ::std::marker::Send + 'static>>;
        fn createEdge(
            &self,
            arg_req: &crate::types::CreateEdgeReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateEdgeError>> + ::std::marker::Send + 'static>>;
        fn alterEdge(
            &self,
            arg_req: &crate::types::AlterEdgeReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterEdgeError>> + ::std::marker::Send + 'static>>;
        fn dropEdge(
            &self,
            arg_req: &crate::types::DropEdgeReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropEdgeError>> + ::std::marker::Send + 'static>>;
        fn getEdge(
            &self,
            arg_req: &crate::types::GetEdgeReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetEdgeResp, crate::errors::meta_service::GetEdgeError>> + ::std::marker::Send + 'static>>;
        fn listEdges(
            &self,
            arg_req: &crate::types::ListEdgesReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListEdgesResp, crate::errors::meta_service::ListEdgesError>> + ::std::marker::Send + 'static>>;
        fn listHosts(
            &self,
            arg_req: &crate::types::ListHostsReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListHostsResp, crate::errors::meta_service::ListHostsError>> + ::std::marker::Send + 'static>>;
        fn getPartsAlloc(
            &self,
            arg_req: &crate::types::GetPartsAllocReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetPartsAllocResp, crate::errors::meta_service::GetPartsAllocError>> + ::std::marker::Send + 'static>>;
        fn listParts(
            &self,
            arg_req: &crate::types::ListPartsReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListPartsResp, crate::errors::meta_service::ListPartsError>> + ::std::marker::Send + 'static>>;
        fn multiPut(
            &self,
            arg_req: &crate::types::MultiPutReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::MultiPutError>> + ::std::marker::Send + 'static>>;
        fn get(
            &self,
            arg_req: &crate::types::GetReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetResp, crate::errors::meta_service::GetError>> + ::std::marker::Send + 'static>>;
        fn multiGet(
            &self,
            arg_req: &crate::types::MultiGetReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::MultiGetResp, crate::errors::meta_service::MultiGetError>> + ::std::marker::Send + 'static>>;
        fn remove(
            &self,
            arg_req: &crate::types::RemoveReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveError>> + ::std::marker::Send + 'static>>;
        fn removeRange(
            &self,
            arg_req: &crate::types::RemoveRangeReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveRangeError>> + ::std::marker::Send + 'static>>;
        fn scan(
            &self,
            arg_req: &crate::types::ScanReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ScanResp, crate::errors::meta_service::ScanError>> + ::std::marker::Send + 'static>>;
        fn createTagIndex(
            &self,
            arg_req: &crate::types::CreateTagIndexReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateTagIndexError>> + ::std::marker::Send + 'static>>;
        fn dropTagIndex(
            &self,
            arg_req: &crate::types::DropTagIndexReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropTagIndexError>> + ::std::marker::Send + 'static>>;
        fn getTagIndex(
            &self,
            arg_req: &crate::types::GetTagIndexReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetTagIndexResp, crate::errors::meta_service::GetTagIndexError>> + ::std::marker::Send + 'static>>;
        fn listTagIndexes(
            &self,
            arg_req: &crate::types::ListTagIndexesReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListTagIndexesResp, crate::errors::meta_service::ListTagIndexesError>> + ::std::marker::Send + 'static>>;
        fn rebuildTagIndex(
            &self,
            arg_req: &crate::types::RebuildIndexReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RebuildTagIndexError>> + ::std::marker::Send + 'static>>;
        fn listTagIndexStatus(
            &self,
            arg_req: &crate::types::ListIndexStatusReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListIndexStatusResp, crate::errors::meta_service::ListTagIndexStatusError>> + ::std::marker::Send + 'static>>;
        fn createEdgeIndex(
            &self,
            arg_req: &crate::types::CreateEdgeIndexReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateEdgeIndexError>> + ::std::marker::Send + 'static>>;
        fn dropEdgeIndex(
            &self,
            arg_req: &crate::types::DropEdgeIndexReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropEdgeIndexError>> + ::std::marker::Send + 'static>>;
        fn getEdgeIndex(
            &self,
            arg_req: &crate::types::GetEdgeIndexReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetEdgeIndexResp, crate::errors::meta_service::GetEdgeIndexError>> + ::std::marker::Send + 'static>>;
        fn listEdgeIndexes(
            &self,
            arg_req: &crate::types::ListEdgeIndexesReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListEdgeIndexesResp, crate::errors::meta_service::ListEdgeIndexesError>> + ::std::marker::Send + 'static>>;
        fn rebuildEdgeIndex(
            &self,
            arg_req: &crate::types::RebuildIndexReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RebuildEdgeIndexError>> + ::std::marker::Send + 'static>>;
        fn listEdgeIndexStatus(
            &self,
            arg_req: &crate::types::ListIndexStatusReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListIndexStatusResp, crate::errors::meta_service::ListEdgeIndexStatusError>> + ::std::marker::Send + 'static>>;
        fn createUser(
            &self,
            arg_req: &crate::types::CreateUserReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateUserError>> + ::std::marker::Send + 'static>>;
        fn dropUser(
            &self,
            arg_req: &crate::types::DropUserReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropUserError>> + ::std::marker::Send + 'static>>;
        fn alterUser(
            &self,
            arg_req: &crate::types::AlterUserReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterUserError>> + ::std::marker::Send + 'static>>;
        fn grantRole(
            &self,
            arg_req: &crate::types::GrantRoleReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::GrantRoleError>> + ::std::marker::Send + 'static>>;
        fn revokeRole(
            &self,
            arg_req: &crate::types::RevokeRoleReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RevokeRoleError>> + ::std::marker::Send + 'static>>;
        fn listUsers(
            &self,
            arg_req: &crate::types::ListUsersReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListUsersResp, crate::errors::meta_service::ListUsersError>> + ::std::marker::Send + 'static>>;
        fn listRoles(
            &self,
            arg_req: &crate::types::ListRolesReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListRolesResp, crate::errors::meta_service::ListRolesError>> + ::std::marker::Send + 'static>>;
        fn getUserRoles(
            &self,
            arg_req: &crate::types::GetUserRolesReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListRolesResp, crate::errors::meta_service::GetUserRolesError>> + ::std::marker::Send + 'static>>;
        fn changePassword(
            &self,
            arg_req: &crate::types::ChangePasswordReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::ChangePasswordError>> + ::std::marker::Send + 'static>>;
        fn heartBeat(
            &self,
            arg_req: &crate::types::HBReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::HBResp, crate::errors::meta_service::HeartBeatError>> + ::std::marker::Send + 'static>>;
        fn balance(
            &self,
            arg_req: &crate::types::BalanceReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::BalanceResp, crate::errors::meta_service::BalanceError>> + ::std::marker::Send + 'static>>;
        fn leaderBalance(
            &self,
            arg_req: &crate::types::LeaderBalanceReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::LeaderBalanceError>> + ::std::marker::Send + 'static>>;
        fn regConfig(
            &self,
            arg_req: &crate::types::RegConfigReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RegConfigError>> + ::std::marker::Send + 'static>>;
        fn getConfig(
            &self,
            arg_req: &crate::types::GetConfigReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetConfigResp, crate::errors::meta_service::GetConfigError>> + ::std::marker::Send + 'static>>;
        fn setConfig(
            &self,
            arg_req: &crate::types::SetConfigReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::SetConfigError>> + ::std::marker::Send + 'static>>;
        fn listConfigs(
            &self,
            arg_req: &crate::types::ListConfigsReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListConfigsResp, crate::errors::meta_service::ListConfigsError>> + ::std::marker::Send + 'static>>;
        fn createSnapshot(
            &self,
            arg_req: &crate::types::CreateSnapshotReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateSnapshotError>> + ::std::marker::Send + 'static>>;
        fn dropSnapshot(
            &self,
            arg_req: &crate::types::DropSnapshotReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropSnapshotError>> + ::std::marker::Send + 'static>>;
        fn listSnapshots(
            &self,
            arg_req: &crate::types::ListSnapshotsReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListSnapshotsResp, crate::errors::meta_service::ListSnapshotsError>> + ::std::marker::Send + 'static>>;
        fn runAdminJob(
            &self,
            arg_req: &crate::types::AdminJobReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminJobResp, crate::errors::meta_service::RunAdminJobError>> + ::std::marker::Send + 'static>>;
        fn addZone(
            &self,
            arg_req: &crate::types::AddZoneReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddZoneError>> + ::std::marker::Send + 'static>>;
        fn dropZone(
            &self,
            arg_req: &crate::types::DropZoneReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropZoneError>> + ::std::marker::Send + 'static>>;
        fn addHostIntoZone(
            &self,
            arg_req: &crate::types::AddHostIntoZoneReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddHostIntoZoneError>> + ::std::marker::Send + 'static>>;
        fn dropHostFromZone(
            &self,
            arg_req: &crate::types::DropHostFromZoneReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropHostFromZoneError>> + ::std::marker::Send + 'static>>;
        fn getZone(
            &self,
            arg_req: &crate::types::GetZoneReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetZoneResp, crate::errors::meta_service::GetZoneError>> + ::std::marker::Send + 'static>>;
        fn listZones(
            &self,
            arg_req: &crate::types::ListZonesReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListZonesResp, crate::errors::meta_service::ListZonesError>> + ::std::marker::Send + 'static>>;
        fn addGroup(
            &self,
            arg_req: &crate::types::AddGroupReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddGroupError>> + ::std::marker::Send + 'static>>;
        fn dropGroup(
            &self,
            arg_req: &crate::types::DropGroupReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropGroupError>> + ::std::marker::Send + 'static>>;
        fn addZoneIntoGroup(
            &self,
            arg_req: &crate::types::AddZoneIntoGroupReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddZoneIntoGroupError>> + ::std::marker::Send + 'static>>;
        fn dropZoneFromGroup(
            &self,
            arg_req: &crate::types::DropZoneFromGroupReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropZoneFromGroupError>> + ::std::marker::Send + 'static>>;
        fn getGroup(
            &self,
            arg_req: &crate::types::GetGroupReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetGroupResp, crate::errors::meta_service::GetGroupError>> + ::std::marker::Send + 'static>>;
        fn listGroups(
            &self,
            arg_req: &crate::types::ListGroupsReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListGroupsResp, crate::errors::meta_service::ListGroupsError>> + ::std::marker::Send + 'static>>;
        fn createBackup(
            &self,
            arg_req: &crate::types::CreateBackupReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::CreateBackupResp, crate::errors::meta_service::CreateBackupError>> + ::std::marker::Send + 'static>>;
        fn restoreMeta(
            &self,
            arg_req: &crate::types::RestoreMetaReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RestoreMetaError>> + ::std::marker::Send + 'static>>;
        fn addListener(
            &self,
            arg_req: &crate::types::AddListenerReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddListenerError>> + ::std::marker::Send + 'static>>;
        fn removeListener(
            &self,
            arg_req: &crate::types::RemoveListenerReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveListenerError>> + ::std::marker::Send + 'static>>;
        fn listListener(
            &self,
            arg_req: &crate::types::ListListenerReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListListenerResp, crate::errors::meta_service::ListListenerError>> + ::std::marker::Send + 'static>>;
        fn getStatis(
            &self,
            arg_req: &crate::types::GetStatisReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetStatisResp, crate::errors::meta_service::GetStatisError>> + ::std::marker::Send + 'static>>;
        fn signInFTService(
            &self,
            arg_req: &crate::types::SignInFTServiceReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::SignInFTServiceError>> + ::std::marker::Send + 'static>>;
        fn signOutFTService(
            &self,
            arg_req: &crate::types::SignOutFTServiceReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::SignOutFTServiceError>> + ::std::marker::Send + 'static>>;
        fn listFTClients(
            &self,
            arg_req: &crate::types::ListFTClientsReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListFTClientsResp, crate::errors::meta_service::ListFTClientsError>> + ::std::marker::Send + 'static>>;
        fn createSession(
            &self,
            arg_req: &crate::types::CreateSessionReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::CreateSessionResp, crate::errors::meta_service::CreateSessionError>> + ::std::marker::Send + 'static>>;
        fn updateSessions(
            &self,
            arg_req: &crate::types::UpdateSessionsReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::UpdateSessionsError>> + ::std::marker::Send + 'static>>;
        fn listSessions(
            &self,
            arg_req: &crate::types::ListSessionsReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListSessionsResp, crate::errors::meta_service::ListSessionsError>> + ::std::marker::Send + 'static>>;
        fn getSession(
            &self,
            arg_req: &crate::types::GetSessionReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetSessionResp, crate::errors::meta_service::GetSessionError>> + ::std::marker::Send + 'static>>;
        fn removeSession(
            &self,
            arg_req: &crate::types::RemoveSessionReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveSessionError>> + ::std::marker::Send + 'static>>;
        fn reportTaskFinish(
            &self,
            arg_req: &crate::types::ReportTaskReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::ReportTaskFinishError>> + ::std::marker::Send + 'static>>;
    }

    impl<P, T> MetaService for MetaServiceImpl<P, T>
    where
        P: ::fbthrift::Protocol,
        T: ::fbthrift::Transport,
        P::Frame: ::fbthrift::Framing<DecBuf = ::fbthrift::FramingDecoded<T>>,
        ::fbthrift::ProtocolEncoded<P>: ::fbthrift::BufMutExt<Final = ::fbthrift::FramingEncodedFinal<T>>,
    {        fn createSpace(
            &self,
            arg_req: &crate::types::CreateSpaceReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateSpaceError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "createSpace",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateSpaceError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::CreateSpaceExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::CreateSpaceExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::CreateSpaceExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::CreateSpaceError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::CreateSpaceError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::CreateSpaceError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn dropSpace(
            &self,
            arg_req: &crate::types::DropSpaceReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropSpaceError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "dropSpace",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropSpaceError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::DropSpaceExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::DropSpaceExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::DropSpaceExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::DropSpaceError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::DropSpaceError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::DropSpaceError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getSpace(
            &self,
            arg_req: &crate::types::GetSpaceReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetSpaceResp, crate::errors::meta_service::GetSpaceError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getSpace",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::GetSpaceResp, crate::errors::meta_service::GetSpaceError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::GetSpaceExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::GetSpaceExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::GetSpaceExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::GetSpaceError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::GetSpaceError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::GetSpaceError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn listSpaces(
            &self,
            arg_req: &crate::types::ListSpacesReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListSpacesResp, crate::errors::meta_service::ListSpacesError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "listSpaces",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ListSpacesResp, crate::errors::meta_service::ListSpacesError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::ListSpacesExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::ListSpacesExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::ListSpacesExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::ListSpacesError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::ListSpacesError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::ListSpacesError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn createTag(
            &self,
            arg_req: &crate::types::CreateTagReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateTagError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "createTag",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateTagError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::CreateTagExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::CreateTagExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::CreateTagExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::CreateTagError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::CreateTagError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::CreateTagError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn alterTag(
            &self,
            arg_req: &crate::types::AlterTagReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterTagError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "alterTag",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterTagError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::AlterTagExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::AlterTagExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::AlterTagExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::AlterTagError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::AlterTagError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::AlterTagError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn dropTag(
            &self,
            arg_req: &crate::types::DropTagReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropTagError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "dropTag",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropTagError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::DropTagExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::DropTagExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::DropTagExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::DropTagError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::DropTagError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::DropTagError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getTag(
            &self,
            arg_req: &crate::types::GetTagReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetTagResp, crate::errors::meta_service::GetTagError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getTag",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::GetTagResp, crate::errors::meta_service::GetTagError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::GetTagExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::GetTagExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::GetTagExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::GetTagError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::GetTagError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::GetTagError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn listTags(
            &self,
            arg_req: &crate::types::ListTagsReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListTagsResp, crate::errors::meta_service::ListTagsError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "listTags",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ListTagsResp, crate::errors::meta_service::ListTagsError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::ListTagsExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::ListTagsExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::ListTagsExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::ListTagsError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::ListTagsError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::ListTagsError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn createEdge(
            &self,
            arg_req: &crate::types::CreateEdgeReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateEdgeError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "createEdge",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateEdgeError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::CreateEdgeExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::CreateEdgeExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::CreateEdgeExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::CreateEdgeError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::CreateEdgeError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::CreateEdgeError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn alterEdge(
            &self,
            arg_req: &crate::types::AlterEdgeReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterEdgeError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "alterEdge",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterEdgeError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::AlterEdgeExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::AlterEdgeExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::AlterEdgeExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::AlterEdgeError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::AlterEdgeError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::AlterEdgeError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn dropEdge(
            &self,
            arg_req: &crate::types::DropEdgeReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropEdgeError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "dropEdge",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropEdgeError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::DropEdgeExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::DropEdgeExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::DropEdgeExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::DropEdgeError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::DropEdgeError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::DropEdgeError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getEdge(
            &self,
            arg_req: &crate::types::GetEdgeReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetEdgeResp, crate::errors::meta_service::GetEdgeError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getEdge",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::GetEdgeResp, crate::errors::meta_service::GetEdgeError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::GetEdgeExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::GetEdgeExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::GetEdgeExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::GetEdgeError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::GetEdgeError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::GetEdgeError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn listEdges(
            &self,
            arg_req: &crate::types::ListEdgesReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListEdgesResp, crate::errors::meta_service::ListEdgesError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "listEdges",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ListEdgesResp, crate::errors::meta_service::ListEdgesError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::ListEdgesExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::ListEdgesExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::ListEdgesExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::ListEdgesError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::ListEdgesError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::ListEdgesError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn listHosts(
            &self,
            arg_req: &crate::types::ListHostsReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListHostsResp, crate::errors::meta_service::ListHostsError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "listHosts",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ListHostsResp, crate::errors::meta_service::ListHostsError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::ListHostsExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::ListHostsExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::ListHostsExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::ListHostsError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::ListHostsError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::ListHostsError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getPartsAlloc(
            &self,
            arg_req: &crate::types::GetPartsAllocReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetPartsAllocResp, crate::errors::meta_service::GetPartsAllocError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getPartsAlloc",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::GetPartsAllocResp, crate::errors::meta_service::GetPartsAllocError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::GetPartsAllocExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::GetPartsAllocExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::GetPartsAllocExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::GetPartsAllocError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::GetPartsAllocError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::GetPartsAllocError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn listParts(
            &self,
            arg_req: &crate::types::ListPartsReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListPartsResp, crate::errors::meta_service::ListPartsError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "listParts",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ListPartsResp, crate::errors::meta_service::ListPartsError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::ListPartsExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::ListPartsExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::ListPartsExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::ListPartsError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::ListPartsError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::ListPartsError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn multiPut(
            &self,
            arg_req: &crate::types::MultiPutReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::MultiPutError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "multiPut",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::MultiPutError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::MultiPutExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::MultiPutExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::MultiPutExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::MultiPutError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::MultiPutError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::MultiPutError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn get(
            &self,
            arg_req: &crate::types::GetReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetResp, crate::errors::meta_service::GetError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "get",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::GetResp, crate::errors::meta_service::GetError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::GetExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::GetExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::GetExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::GetError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::GetError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::GetError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn multiGet(
            &self,
            arg_req: &crate::types::MultiGetReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::MultiGetResp, crate::errors::meta_service::MultiGetError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "multiGet",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::MultiGetResp, crate::errors::meta_service::MultiGetError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::MultiGetExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::MultiGetExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::MultiGetExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::MultiGetError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::MultiGetError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::MultiGetError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn remove(
            &self,
            arg_req: &crate::types::RemoveReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "remove",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::RemoveExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::RemoveExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::RemoveExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::RemoveError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::RemoveError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::RemoveError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn removeRange(
            &self,
            arg_req: &crate::types::RemoveRangeReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveRangeError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "removeRange",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveRangeError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::RemoveRangeExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::RemoveRangeExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::RemoveRangeExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::RemoveRangeError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::RemoveRangeError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::RemoveRangeError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn scan(
            &self,
            arg_req: &crate::types::ScanReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ScanResp, crate::errors::meta_service::ScanError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "scan",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ScanResp, crate::errors::meta_service::ScanError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::ScanExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::ScanExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::ScanExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::ScanError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::ScanError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::ScanError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn createTagIndex(
            &self,
            arg_req: &crate::types::CreateTagIndexReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateTagIndexError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "createTagIndex",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateTagIndexError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::CreateTagIndexExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::CreateTagIndexExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::CreateTagIndexExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::CreateTagIndexError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::CreateTagIndexError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::CreateTagIndexError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn dropTagIndex(
            &self,
            arg_req: &crate::types::DropTagIndexReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropTagIndexError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "dropTagIndex",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropTagIndexError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::DropTagIndexExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::DropTagIndexExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::DropTagIndexExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::DropTagIndexError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::DropTagIndexError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::DropTagIndexError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getTagIndex(
            &self,
            arg_req: &crate::types::GetTagIndexReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetTagIndexResp, crate::errors::meta_service::GetTagIndexError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getTagIndex",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::GetTagIndexResp, crate::errors::meta_service::GetTagIndexError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::GetTagIndexExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::GetTagIndexExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::GetTagIndexExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::GetTagIndexError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::GetTagIndexError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::GetTagIndexError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn listTagIndexes(
            &self,
            arg_req: &crate::types::ListTagIndexesReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListTagIndexesResp, crate::errors::meta_service::ListTagIndexesError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "listTagIndexes",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ListTagIndexesResp, crate::errors::meta_service::ListTagIndexesError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::ListTagIndexesExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::ListTagIndexesExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::ListTagIndexesExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::ListTagIndexesError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::ListTagIndexesError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::ListTagIndexesError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn rebuildTagIndex(
            &self,
            arg_req: &crate::types::RebuildIndexReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RebuildTagIndexError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "rebuildTagIndex",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RebuildTagIndexError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::RebuildTagIndexExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::RebuildTagIndexExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::RebuildTagIndexExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::RebuildTagIndexError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::RebuildTagIndexError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::RebuildTagIndexError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn listTagIndexStatus(
            &self,
            arg_req: &crate::types::ListIndexStatusReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListIndexStatusResp, crate::errors::meta_service::ListTagIndexStatusError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "listTagIndexStatus",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ListIndexStatusResp, crate::errors::meta_service::ListTagIndexStatusError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::ListTagIndexStatusExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::ListTagIndexStatusExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::ListTagIndexStatusExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::ListTagIndexStatusError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::ListTagIndexStatusError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::ListTagIndexStatusError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn createEdgeIndex(
            &self,
            arg_req: &crate::types::CreateEdgeIndexReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateEdgeIndexError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "createEdgeIndex",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateEdgeIndexError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::CreateEdgeIndexExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::CreateEdgeIndexExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::CreateEdgeIndexExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::CreateEdgeIndexError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::CreateEdgeIndexError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::CreateEdgeIndexError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn dropEdgeIndex(
            &self,
            arg_req: &crate::types::DropEdgeIndexReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropEdgeIndexError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "dropEdgeIndex",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropEdgeIndexError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::DropEdgeIndexExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::DropEdgeIndexExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::DropEdgeIndexExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::DropEdgeIndexError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::DropEdgeIndexError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::DropEdgeIndexError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getEdgeIndex(
            &self,
            arg_req: &crate::types::GetEdgeIndexReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetEdgeIndexResp, crate::errors::meta_service::GetEdgeIndexError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getEdgeIndex",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::GetEdgeIndexResp, crate::errors::meta_service::GetEdgeIndexError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::GetEdgeIndexExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::GetEdgeIndexExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::GetEdgeIndexExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::GetEdgeIndexError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::GetEdgeIndexError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::GetEdgeIndexError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn listEdgeIndexes(
            &self,
            arg_req: &crate::types::ListEdgeIndexesReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListEdgeIndexesResp, crate::errors::meta_service::ListEdgeIndexesError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "listEdgeIndexes",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ListEdgeIndexesResp, crate::errors::meta_service::ListEdgeIndexesError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::ListEdgeIndexesExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::ListEdgeIndexesExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::ListEdgeIndexesExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::ListEdgeIndexesError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::ListEdgeIndexesError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::ListEdgeIndexesError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn rebuildEdgeIndex(
            &self,
            arg_req: &crate::types::RebuildIndexReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RebuildEdgeIndexError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "rebuildEdgeIndex",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RebuildEdgeIndexError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::RebuildEdgeIndexExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::RebuildEdgeIndexExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::RebuildEdgeIndexExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::RebuildEdgeIndexError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::RebuildEdgeIndexError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::RebuildEdgeIndexError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn listEdgeIndexStatus(
            &self,
            arg_req: &crate::types::ListIndexStatusReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListIndexStatusResp, crate::errors::meta_service::ListEdgeIndexStatusError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "listEdgeIndexStatus",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ListIndexStatusResp, crate::errors::meta_service::ListEdgeIndexStatusError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::ListEdgeIndexStatusExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::ListEdgeIndexStatusExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::ListEdgeIndexStatusExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::ListEdgeIndexStatusError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::ListEdgeIndexStatusError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::ListEdgeIndexStatusError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn createUser(
            &self,
            arg_req: &crate::types::CreateUserReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateUserError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "createUser",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateUserError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::CreateUserExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::CreateUserExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::CreateUserExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::CreateUserError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::CreateUserError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::CreateUserError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn dropUser(
            &self,
            arg_req: &crate::types::DropUserReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropUserError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "dropUser",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropUserError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::DropUserExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::DropUserExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::DropUserExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::DropUserError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::DropUserError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::DropUserError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn alterUser(
            &self,
            arg_req: &crate::types::AlterUserReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterUserError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "alterUser",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterUserError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::AlterUserExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::AlterUserExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::AlterUserExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::AlterUserError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::AlterUserError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::AlterUserError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn grantRole(
            &self,
            arg_req: &crate::types::GrantRoleReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::GrantRoleError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "grantRole",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::GrantRoleError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::GrantRoleExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::GrantRoleExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::GrantRoleExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::GrantRoleError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::GrantRoleError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::GrantRoleError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn revokeRole(
            &self,
            arg_req: &crate::types::RevokeRoleReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RevokeRoleError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "revokeRole",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RevokeRoleError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::RevokeRoleExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::RevokeRoleExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::RevokeRoleExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::RevokeRoleError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::RevokeRoleError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::RevokeRoleError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn listUsers(
            &self,
            arg_req: &crate::types::ListUsersReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListUsersResp, crate::errors::meta_service::ListUsersError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "listUsers",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ListUsersResp, crate::errors::meta_service::ListUsersError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::ListUsersExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::ListUsersExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::ListUsersExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::ListUsersError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::ListUsersError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::ListUsersError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn listRoles(
            &self,
            arg_req: &crate::types::ListRolesReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListRolesResp, crate::errors::meta_service::ListRolesError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "listRoles",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ListRolesResp, crate::errors::meta_service::ListRolesError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::ListRolesExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::ListRolesExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::ListRolesExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::ListRolesError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::ListRolesError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::ListRolesError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getUserRoles(
            &self,
            arg_req: &crate::types::GetUserRolesReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListRolesResp, crate::errors::meta_service::GetUserRolesError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getUserRoles",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ListRolesResp, crate::errors::meta_service::GetUserRolesError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::GetUserRolesExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::GetUserRolesExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::GetUserRolesExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::GetUserRolesError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::GetUserRolesError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::GetUserRolesError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn changePassword(
            &self,
            arg_req: &crate::types::ChangePasswordReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::ChangePasswordError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "changePassword",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::ChangePasswordError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::ChangePasswordExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::ChangePasswordExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::ChangePasswordExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::ChangePasswordError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::ChangePasswordError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::ChangePasswordError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn heartBeat(
            &self,
            arg_req: &crate::types::HBReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::HBResp, crate::errors::meta_service::HeartBeatError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "heartBeat",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::HBResp, crate::errors::meta_service::HeartBeatError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::HeartBeatExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::HeartBeatExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::HeartBeatExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::HeartBeatError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::HeartBeatError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::HeartBeatError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn balance(
            &self,
            arg_req: &crate::types::BalanceReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::BalanceResp, crate::errors::meta_service::BalanceError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "balance",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::BalanceResp, crate::errors::meta_service::BalanceError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::BalanceExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::BalanceExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::BalanceExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::BalanceError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::BalanceError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::BalanceError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn leaderBalance(
            &self,
            arg_req: &crate::types::LeaderBalanceReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::LeaderBalanceError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "leaderBalance",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::LeaderBalanceError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::LeaderBalanceExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::LeaderBalanceExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::LeaderBalanceExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::LeaderBalanceError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::LeaderBalanceError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::LeaderBalanceError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn regConfig(
            &self,
            arg_req: &crate::types::RegConfigReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RegConfigError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "regConfig",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RegConfigError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::RegConfigExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::RegConfigExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::RegConfigExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::RegConfigError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::RegConfigError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::RegConfigError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getConfig(
            &self,
            arg_req: &crate::types::GetConfigReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetConfigResp, crate::errors::meta_service::GetConfigError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getConfig",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::GetConfigResp, crate::errors::meta_service::GetConfigError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::GetConfigExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::GetConfigExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::GetConfigExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::GetConfigError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::GetConfigError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::GetConfigError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn setConfig(
            &self,
            arg_req: &crate::types::SetConfigReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::SetConfigError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "setConfig",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::SetConfigError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::SetConfigExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::SetConfigExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::SetConfigExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::SetConfigError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::SetConfigError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::SetConfigError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn listConfigs(
            &self,
            arg_req: &crate::types::ListConfigsReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListConfigsResp, crate::errors::meta_service::ListConfigsError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "listConfigs",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ListConfigsResp, crate::errors::meta_service::ListConfigsError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::ListConfigsExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::ListConfigsExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::ListConfigsExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::ListConfigsError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::ListConfigsError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::ListConfigsError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn createSnapshot(
            &self,
            arg_req: &crate::types::CreateSnapshotReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateSnapshotError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "createSnapshot",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateSnapshotError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::CreateSnapshotExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::CreateSnapshotExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::CreateSnapshotExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::CreateSnapshotError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::CreateSnapshotError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::CreateSnapshotError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn dropSnapshot(
            &self,
            arg_req: &crate::types::DropSnapshotReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropSnapshotError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "dropSnapshot",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropSnapshotError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::DropSnapshotExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::DropSnapshotExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::DropSnapshotExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::DropSnapshotError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::DropSnapshotError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::DropSnapshotError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn listSnapshots(
            &self,
            arg_req: &crate::types::ListSnapshotsReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListSnapshotsResp, crate::errors::meta_service::ListSnapshotsError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "listSnapshots",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ListSnapshotsResp, crate::errors::meta_service::ListSnapshotsError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::ListSnapshotsExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::ListSnapshotsExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::ListSnapshotsExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::ListSnapshotsError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::ListSnapshotsError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::ListSnapshotsError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn runAdminJob(
            &self,
            arg_req: &crate::types::AdminJobReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminJobResp, crate::errors::meta_service::RunAdminJobError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "runAdminJob",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::AdminJobResp, crate::errors::meta_service::RunAdminJobError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::RunAdminJobExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::RunAdminJobExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::RunAdminJobExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::RunAdminJobError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::RunAdminJobError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::RunAdminJobError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn addZone(
            &self,
            arg_req: &crate::types::AddZoneReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddZoneError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "addZone",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddZoneError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::AddZoneExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::AddZoneExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::AddZoneExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::AddZoneError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::AddZoneError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::AddZoneError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn dropZone(
            &self,
            arg_req: &crate::types::DropZoneReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropZoneError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "dropZone",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropZoneError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::DropZoneExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::DropZoneExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::DropZoneExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::DropZoneError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::DropZoneError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::DropZoneError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn addHostIntoZone(
            &self,
            arg_req: &crate::types::AddHostIntoZoneReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddHostIntoZoneError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "addHostIntoZone",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddHostIntoZoneError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::AddHostIntoZoneExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::AddHostIntoZoneExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::AddHostIntoZoneExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::AddHostIntoZoneError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::AddHostIntoZoneError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::AddHostIntoZoneError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn dropHostFromZone(
            &self,
            arg_req: &crate::types::DropHostFromZoneReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropHostFromZoneError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "dropHostFromZone",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropHostFromZoneError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::DropHostFromZoneExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::DropHostFromZoneExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::DropHostFromZoneExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::DropHostFromZoneError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::DropHostFromZoneError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::DropHostFromZoneError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getZone(
            &self,
            arg_req: &crate::types::GetZoneReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetZoneResp, crate::errors::meta_service::GetZoneError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getZone",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::GetZoneResp, crate::errors::meta_service::GetZoneError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::GetZoneExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::GetZoneExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::GetZoneExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::GetZoneError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::GetZoneError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::GetZoneError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn listZones(
            &self,
            arg_req: &crate::types::ListZonesReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListZonesResp, crate::errors::meta_service::ListZonesError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "listZones",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ListZonesResp, crate::errors::meta_service::ListZonesError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::ListZonesExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::ListZonesExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::ListZonesExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::ListZonesError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::ListZonesError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::ListZonesError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn addGroup(
            &self,
            arg_req: &crate::types::AddGroupReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddGroupError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "addGroup",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddGroupError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::AddGroupExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::AddGroupExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::AddGroupExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::AddGroupError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::AddGroupError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::AddGroupError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn dropGroup(
            &self,
            arg_req: &crate::types::DropGroupReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropGroupError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "dropGroup",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropGroupError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::DropGroupExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::DropGroupExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::DropGroupExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::DropGroupError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::DropGroupError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::DropGroupError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn addZoneIntoGroup(
            &self,
            arg_req: &crate::types::AddZoneIntoGroupReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddZoneIntoGroupError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "addZoneIntoGroup",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddZoneIntoGroupError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::AddZoneIntoGroupExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::AddZoneIntoGroupExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::AddZoneIntoGroupExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::AddZoneIntoGroupError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::AddZoneIntoGroupError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::AddZoneIntoGroupError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn dropZoneFromGroup(
            &self,
            arg_req: &crate::types::DropZoneFromGroupReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropZoneFromGroupError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "dropZoneFromGroup",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropZoneFromGroupError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::DropZoneFromGroupExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::DropZoneFromGroupExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::DropZoneFromGroupExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::DropZoneFromGroupError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::DropZoneFromGroupError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::DropZoneFromGroupError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getGroup(
            &self,
            arg_req: &crate::types::GetGroupReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetGroupResp, crate::errors::meta_service::GetGroupError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getGroup",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::GetGroupResp, crate::errors::meta_service::GetGroupError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::GetGroupExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::GetGroupExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::GetGroupExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::GetGroupError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::GetGroupError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::GetGroupError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn listGroups(
            &self,
            arg_req: &crate::types::ListGroupsReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListGroupsResp, crate::errors::meta_service::ListGroupsError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "listGroups",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ListGroupsResp, crate::errors::meta_service::ListGroupsError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::ListGroupsExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::ListGroupsExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::ListGroupsExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::ListGroupsError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::ListGroupsError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::ListGroupsError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn createBackup(
            &self,
            arg_req: &crate::types::CreateBackupReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::CreateBackupResp, crate::errors::meta_service::CreateBackupError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "createBackup",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::CreateBackupResp, crate::errors::meta_service::CreateBackupError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::CreateBackupExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::CreateBackupExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::CreateBackupExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::CreateBackupError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::CreateBackupError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::CreateBackupError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn restoreMeta(
            &self,
            arg_req: &crate::types::RestoreMetaReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RestoreMetaError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "restoreMeta",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RestoreMetaError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::RestoreMetaExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::RestoreMetaExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::RestoreMetaExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::RestoreMetaError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::RestoreMetaError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::RestoreMetaError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn addListener(
            &self,
            arg_req: &crate::types::AddListenerReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddListenerError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "addListener",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddListenerError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::AddListenerExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::AddListenerExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::AddListenerExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::AddListenerError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::AddListenerError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::AddListenerError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn removeListener(
            &self,
            arg_req: &crate::types::RemoveListenerReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveListenerError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "removeListener",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveListenerError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::RemoveListenerExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::RemoveListenerExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::RemoveListenerExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::RemoveListenerError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::RemoveListenerError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::RemoveListenerError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn listListener(
            &self,
            arg_req: &crate::types::ListListenerReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListListenerResp, crate::errors::meta_service::ListListenerError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "listListener",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ListListenerResp, crate::errors::meta_service::ListListenerError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::ListListenerExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::ListListenerExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::ListListenerExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::ListListenerError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::ListListenerError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::ListListenerError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getStatis(
            &self,
            arg_req: &crate::types::GetStatisReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetStatisResp, crate::errors::meta_service::GetStatisError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getStatis",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::GetStatisResp, crate::errors::meta_service::GetStatisError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::GetStatisExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::GetStatisExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::GetStatisExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::GetStatisError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::GetStatisError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::GetStatisError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn signInFTService(
            &self,
            arg_req: &crate::types::SignInFTServiceReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::SignInFTServiceError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "signInFTService",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::SignInFTServiceError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::SignInFTServiceExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::SignInFTServiceExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::SignInFTServiceExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::SignInFTServiceError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::SignInFTServiceError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::SignInFTServiceError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn signOutFTService(
            &self,
            arg_req: &crate::types::SignOutFTServiceReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::SignOutFTServiceError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "signOutFTService",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::SignOutFTServiceError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::SignOutFTServiceExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::SignOutFTServiceExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::SignOutFTServiceExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::SignOutFTServiceError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::SignOutFTServiceError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::SignOutFTServiceError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn listFTClients(
            &self,
            arg_req: &crate::types::ListFTClientsReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListFTClientsResp, crate::errors::meta_service::ListFTClientsError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "listFTClients",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ListFTClientsResp, crate::errors::meta_service::ListFTClientsError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::ListFTClientsExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::ListFTClientsExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::ListFTClientsExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::ListFTClientsError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::ListFTClientsError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::ListFTClientsError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn createSession(
            &self,
            arg_req: &crate::types::CreateSessionReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::CreateSessionResp, crate::errors::meta_service::CreateSessionError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "createSession",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::CreateSessionResp, crate::errors::meta_service::CreateSessionError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::CreateSessionExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::CreateSessionExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::CreateSessionExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::CreateSessionError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::CreateSessionError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::CreateSessionError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn updateSessions(
            &self,
            arg_req: &crate::types::UpdateSessionsReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::UpdateSessionsError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "updateSessions",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::UpdateSessionsError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::UpdateSessionsExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::UpdateSessionsExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::UpdateSessionsExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::UpdateSessionsError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::UpdateSessionsError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::UpdateSessionsError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn listSessions(
            &self,
            arg_req: &crate::types::ListSessionsReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListSessionsResp, crate::errors::meta_service::ListSessionsError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "listSessions",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ListSessionsResp, crate::errors::meta_service::ListSessionsError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::ListSessionsExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::ListSessionsExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::ListSessionsExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::ListSessionsError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::ListSessionsError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::ListSessionsError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getSession(
            &self,
            arg_req: &crate::types::GetSessionReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetSessionResp, crate::errors::meta_service::GetSessionError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getSession",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::GetSessionResp, crate::errors::meta_service::GetSessionError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::GetSessionExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::GetSessionExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::GetSessionExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::GetSessionError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::GetSessionError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::GetSessionError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn removeSession(
            &self,
            arg_req: &crate::types::RemoveSessionReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveSessionError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "removeSession",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveSessionError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::RemoveSessionExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::RemoveSessionExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::RemoveSessionExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::RemoveSessionError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::RemoveSessionError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::RemoveSessionError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn reportTaskFinish(
            &self,
            arg_req: &crate::types::ReportTaskReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::ReportTaskFinishError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "reportTaskFinish",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::ReportTaskFinishError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::meta_service::ReportTaskFinishExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::meta_service::ReportTaskFinishExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::meta_service::ReportTaskFinishExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::meta_service::ReportTaskFinishError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::meta_service::ReportTaskFinishError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::meta_service::ReportTaskFinishError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
    }

    impl<'a, T> MetaService for T
    where
        T: ::std::convert::AsRef<dyn MetaService + 'a>,
        T: ::std::marker::Send,
    {
        fn createSpace(
            &self,
            arg_req: &crate::types::CreateSpaceReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateSpaceError>> + ::std::marker::Send + 'static>> {
            self.as_ref().createSpace(
                arg_req,
            )
        }
        fn dropSpace(
            &self,
            arg_req: &crate::types::DropSpaceReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropSpaceError>> + ::std::marker::Send + 'static>> {
            self.as_ref().dropSpace(
                arg_req,
            )
        }
        fn getSpace(
            &self,
            arg_req: &crate::types::GetSpaceReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetSpaceResp, crate::errors::meta_service::GetSpaceError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getSpace(
                arg_req,
            )
        }
        fn listSpaces(
            &self,
            arg_req: &crate::types::ListSpacesReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListSpacesResp, crate::errors::meta_service::ListSpacesError>> + ::std::marker::Send + 'static>> {
            self.as_ref().listSpaces(
                arg_req,
            )
        }
        fn createTag(
            &self,
            arg_req: &crate::types::CreateTagReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateTagError>> + ::std::marker::Send + 'static>> {
            self.as_ref().createTag(
                arg_req,
            )
        }
        fn alterTag(
            &self,
            arg_req: &crate::types::AlterTagReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterTagError>> + ::std::marker::Send + 'static>> {
            self.as_ref().alterTag(
                arg_req,
            )
        }
        fn dropTag(
            &self,
            arg_req: &crate::types::DropTagReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropTagError>> + ::std::marker::Send + 'static>> {
            self.as_ref().dropTag(
                arg_req,
            )
        }
        fn getTag(
            &self,
            arg_req: &crate::types::GetTagReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetTagResp, crate::errors::meta_service::GetTagError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getTag(
                arg_req,
            )
        }
        fn listTags(
            &self,
            arg_req: &crate::types::ListTagsReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListTagsResp, crate::errors::meta_service::ListTagsError>> + ::std::marker::Send + 'static>> {
            self.as_ref().listTags(
                arg_req,
            )
        }
        fn createEdge(
            &self,
            arg_req: &crate::types::CreateEdgeReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateEdgeError>> + ::std::marker::Send + 'static>> {
            self.as_ref().createEdge(
                arg_req,
            )
        }
        fn alterEdge(
            &self,
            arg_req: &crate::types::AlterEdgeReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterEdgeError>> + ::std::marker::Send + 'static>> {
            self.as_ref().alterEdge(
                arg_req,
            )
        }
        fn dropEdge(
            &self,
            arg_req: &crate::types::DropEdgeReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropEdgeError>> + ::std::marker::Send + 'static>> {
            self.as_ref().dropEdge(
                arg_req,
            )
        }
        fn getEdge(
            &self,
            arg_req: &crate::types::GetEdgeReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetEdgeResp, crate::errors::meta_service::GetEdgeError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getEdge(
                arg_req,
            )
        }
        fn listEdges(
            &self,
            arg_req: &crate::types::ListEdgesReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListEdgesResp, crate::errors::meta_service::ListEdgesError>> + ::std::marker::Send + 'static>> {
            self.as_ref().listEdges(
                arg_req,
            )
        }
        fn listHosts(
            &self,
            arg_req: &crate::types::ListHostsReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListHostsResp, crate::errors::meta_service::ListHostsError>> + ::std::marker::Send + 'static>> {
            self.as_ref().listHosts(
                arg_req,
            )
        }
        fn getPartsAlloc(
            &self,
            arg_req: &crate::types::GetPartsAllocReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetPartsAllocResp, crate::errors::meta_service::GetPartsAllocError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getPartsAlloc(
                arg_req,
            )
        }
        fn listParts(
            &self,
            arg_req: &crate::types::ListPartsReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListPartsResp, crate::errors::meta_service::ListPartsError>> + ::std::marker::Send + 'static>> {
            self.as_ref().listParts(
                arg_req,
            )
        }
        fn multiPut(
            &self,
            arg_req: &crate::types::MultiPutReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::MultiPutError>> + ::std::marker::Send + 'static>> {
            self.as_ref().multiPut(
                arg_req,
            )
        }
        fn get(
            &self,
            arg_req: &crate::types::GetReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetResp, crate::errors::meta_service::GetError>> + ::std::marker::Send + 'static>> {
            self.as_ref().get(
                arg_req,
            )
        }
        fn multiGet(
            &self,
            arg_req: &crate::types::MultiGetReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::MultiGetResp, crate::errors::meta_service::MultiGetError>> + ::std::marker::Send + 'static>> {
            self.as_ref().multiGet(
                arg_req,
            )
        }
        fn remove(
            &self,
            arg_req: &crate::types::RemoveReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveError>> + ::std::marker::Send + 'static>> {
            self.as_ref().remove(
                arg_req,
            )
        }
        fn removeRange(
            &self,
            arg_req: &crate::types::RemoveRangeReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveRangeError>> + ::std::marker::Send + 'static>> {
            self.as_ref().removeRange(
                arg_req,
            )
        }
        fn scan(
            &self,
            arg_req: &crate::types::ScanReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ScanResp, crate::errors::meta_service::ScanError>> + ::std::marker::Send + 'static>> {
            self.as_ref().scan(
                arg_req,
            )
        }
        fn createTagIndex(
            &self,
            arg_req: &crate::types::CreateTagIndexReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateTagIndexError>> + ::std::marker::Send + 'static>> {
            self.as_ref().createTagIndex(
                arg_req,
            )
        }
        fn dropTagIndex(
            &self,
            arg_req: &crate::types::DropTagIndexReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropTagIndexError>> + ::std::marker::Send + 'static>> {
            self.as_ref().dropTagIndex(
                arg_req,
            )
        }
        fn getTagIndex(
            &self,
            arg_req: &crate::types::GetTagIndexReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetTagIndexResp, crate::errors::meta_service::GetTagIndexError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getTagIndex(
                arg_req,
            )
        }
        fn listTagIndexes(
            &self,
            arg_req: &crate::types::ListTagIndexesReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListTagIndexesResp, crate::errors::meta_service::ListTagIndexesError>> + ::std::marker::Send + 'static>> {
            self.as_ref().listTagIndexes(
                arg_req,
            )
        }
        fn rebuildTagIndex(
            &self,
            arg_req: &crate::types::RebuildIndexReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RebuildTagIndexError>> + ::std::marker::Send + 'static>> {
            self.as_ref().rebuildTagIndex(
                arg_req,
            )
        }
        fn listTagIndexStatus(
            &self,
            arg_req: &crate::types::ListIndexStatusReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListIndexStatusResp, crate::errors::meta_service::ListTagIndexStatusError>> + ::std::marker::Send + 'static>> {
            self.as_ref().listTagIndexStatus(
                arg_req,
            )
        }
        fn createEdgeIndex(
            &self,
            arg_req: &crate::types::CreateEdgeIndexReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateEdgeIndexError>> + ::std::marker::Send + 'static>> {
            self.as_ref().createEdgeIndex(
                arg_req,
            )
        }
        fn dropEdgeIndex(
            &self,
            arg_req: &crate::types::DropEdgeIndexReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropEdgeIndexError>> + ::std::marker::Send + 'static>> {
            self.as_ref().dropEdgeIndex(
                arg_req,
            )
        }
        fn getEdgeIndex(
            &self,
            arg_req: &crate::types::GetEdgeIndexReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetEdgeIndexResp, crate::errors::meta_service::GetEdgeIndexError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getEdgeIndex(
                arg_req,
            )
        }
        fn listEdgeIndexes(
            &self,
            arg_req: &crate::types::ListEdgeIndexesReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListEdgeIndexesResp, crate::errors::meta_service::ListEdgeIndexesError>> + ::std::marker::Send + 'static>> {
            self.as_ref().listEdgeIndexes(
                arg_req,
            )
        }
        fn rebuildEdgeIndex(
            &self,
            arg_req: &crate::types::RebuildIndexReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RebuildEdgeIndexError>> + ::std::marker::Send + 'static>> {
            self.as_ref().rebuildEdgeIndex(
                arg_req,
            )
        }
        fn listEdgeIndexStatus(
            &self,
            arg_req: &crate::types::ListIndexStatusReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListIndexStatusResp, crate::errors::meta_service::ListEdgeIndexStatusError>> + ::std::marker::Send + 'static>> {
            self.as_ref().listEdgeIndexStatus(
                arg_req,
            )
        }
        fn createUser(
            &self,
            arg_req: &crate::types::CreateUserReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateUserError>> + ::std::marker::Send + 'static>> {
            self.as_ref().createUser(
                arg_req,
            )
        }
        fn dropUser(
            &self,
            arg_req: &crate::types::DropUserReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropUserError>> + ::std::marker::Send + 'static>> {
            self.as_ref().dropUser(
                arg_req,
            )
        }
        fn alterUser(
            &self,
            arg_req: &crate::types::AlterUserReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterUserError>> + ::std::marker::Send + 'static>> {
            self.as_ref().alterUser(
                arg_req,
            )
        }
        fn grantRole(
            &self,
            arg_req: &crate::types::GrantRoleReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::GrantRoleError>> + ::std::marker::Send + 'static>> {
            self.as_ref().grantRole(
                arg_req,
            )
        }
        fn revokeRole(
            &self,
            arg_req: &crate::types::RevokeRoleReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RevokeRoleError>> + ::std::marker::Send + 'static>> {
            self.as_ref().revokeRole(
                arg_req,
            )
        }
        fn listUsers(
            &self,
            arg_req: &crate::types::ListUsersReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListUsersResp, crate::errors::meta_service::ListUsersError>> + ::std::marker::Send + 'static>> {
            self.as_ref().listUsers(
                arg_req,
            )
        }
        fn listRoles(
            &self,
            arg_req: &crate::types::ListRolesReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListRolesResp, crate::errors::meta_service::ListRolesError>> + ::std::marker::Send + 'static>> {
            self.as_ref().listRoles(
                arg_req,
            )
        }
        fn getUserRoles(
            &self,
            arg_req: &crate::types::GetUserRolesReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListRolesResp, crate::errors::meta_service::GetUserRolesError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getUserRoles(
                arg_req,
            )
        }
        fn changePassword(
            &self,
            arg_req: &crate::types::ChangePasswordReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::ChangePasswordError>> + ::std::marker::Send + 'static>> {
            self.as_ref().changePassword(
                arg_req,
            )
        }
        fn heartBeat(
            &self,
            arg_req: &crate::types::HBReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::HBResp, crate::errors::meta_service::HeartBeatError>> + ::std::marker::Send + 'static>> {
            self.as_ref().heartBeat(
                arg_req,
            )
        }
        fn balance(
            &self,
            arg_req: &crate::types::BalanceReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::BalanceResp, crate::errors::meta_service::BalanceError>> + ::std::marker::Send + 'static>> {
            self.as_ref().balance(
                arg_req,
            )
        }
        fn leaderBalance(
            &self,
            arg_req: &crate::types::LeaderBalanceReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::LeaderBalanceError>> + ::std::marker::Send + 'static>> {
            self.as_ref().leaderBalance(
                arg_req,
            )
        }
        fn regConfig(
            &self,
            arg_req: &crate::types::RegConfigReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RegConfigError>> + ::std::marker::Send + 'static>> {
            self.as_ref().regConfig(
                arg_req,
            )
        }
        fn getConfig(
            &self,
            arg_req: &crate::types::GetConfigReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetConfigResp, crate::errors::meta_service::GetConfigError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getConfig(
                arg_req,
            )
        }
        fn setConfig(
            &self,
            arg_req: &crate::types::SetConfigReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::SetConfigError>> + ::std::marker::Send + 'static>> {
            self.as_ref().setConfig(
                arg_req,
            )
        }
        fn listConfigs(
            &self,
            arg_req: &crate::types::ListConfigsReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListConfigsResp, crate::errors::meta_service::ListConfigsError>> + ::std::marker::Send + 'static>> {
            self.as_ref().listConfigs(
                arg_req,
            )
        }
        fn createSnapshot(
            &self,
            arg_req: &crate::types::CreateSnapshotReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateSnapshotError>> + ::std::marker::Send + 'static>> {
            self.as_ref().createSnapshot(
                arg_req,
            )
        }
        fn dropSnapshot(
            &self,
            arg_req: &crate::types::DropSnapshotReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropSnapshotError>> + ::std::marker::Send + 'static>> {
            self.as_ref().dropSnapshot(
                arg_req,
            )
        }
        fn listSnapshots(
            &self,
            arg_req: &crate::types::ListSnapshotsReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListSnapshotsResp, crate::errors::meta_service::ListSnapshotsError>> + ::std::marker::Send + 'static>> {
            self.as_ref().listSnapshots(
                arg_req,
            )
        }
        fn runAdminJob(
            &self,
            arg_req: &crate::types::AdminJobReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminJobResp, crate::errors::meta_service::RunAdminJobError>> + ::std::marker::Send + 'static>> {
            self.as_ref().runAdminJob(
                arg_req,
            )
        }
        fn addZone(
            &self,
            arg_req: &crate::types::AddZoneReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddZoneError>> + ::std::marker::Send + 'static>> {
            self.as_ref().addZone(
                arg_req,
            )
        }
        fn dropZone(
            &self,
            arg_req: &crate::types::DropZoneReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropZoneError>> + ::std::marker::Send + 'static>> {
            self.as_ref().dropZone(
                arg_req,
            )
        }
        fn addHostIntoZone(
            &self,
            arg_req: &crate::types::AddHostIntoZoneReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddHostIntoZoneError>> + ::std::marker::Send + 'static>> {
            self.as_ref().addHostIntoZone(
                arg_req,
            )
        }
        fn dropHostFromZone(
            &self,
            arg_req: &crate::types::DropHostFromZoneReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropHostFromZoneError>> + ::std::marker::Send + 'static>> {
            self.as_ref().dropHostFromZone(
                arg_req,
            )
        }
        fn getZone(
            &self,
            arg_req: &crate::types::GetZoneReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetZoneResp, crate::errors::meta_service::GetZoneError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getZone(
                arg_req,
            )
        }
        fn listZones(
            &self,
            arg_req: &crate::types::ListZonesReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListZonesResp, crate::errors::meta_service::ListZonesError>> + ::std::marker::Send + 'static>> {
            self.as_ref().listZones(
                arg_req,
            )
        }
        fn addGroup(
            &self,
            arg_req: &crate::types::AddGroupReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddGroupError>> + ::std::marker::Send + 'static>> {
            self.as_ref().addGroup(
                arg_req,
            )
        }
        fn dropGroup(
            &self,
            arg_req: &crate::types::DropGroupReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropGroupError>> + ::std::marker::Send + 'static>> {
            self.as_ref().dropGroup(
                arg_req,
            )
        }
        fn addZoneIntoGroup(
            &self,
            arg_req: &crate::types::AddZoneIntoGroupReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddZoneIntoGroupError>> + ::std::marker::Send + 'static>> {
            self.as_ref().addZoneIntoGroup(
                arg_req,
            )
        }
        fn dropZoneFromGroup(
            &self,
            arg_req: &crate::types::DropZoneFromGroupReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropZoneFromGroupError>> + ::std::marker::Send + 'static>> {
            self.as_ref().dropZoneFromGroup(
                arg_req,
            )
        }
        fn getGroup(
            &self,
            arg_req: &crate::types::GetGroupReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetGroupResp, crate::errors::meta_service::GetGroupError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getGroup(
                arg_req,
            )
        }
        fn listGroups(
            &self,
            arg_req: &crate::types::ListGroupsReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListGroupsResp, crate::errors::meta_service::ListGroupsError>> + ::std::marker::Send + 'static>> {
            self.as_ref().listGroups(
                arg_req,
            )
        }
        fn createBackup(
            &self,
            arg_req: &crate::types::CreateBackupReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::CreateBackupResp, crate::errors::meta_service::CreateBackupError>> + ::std::marker::Send + 'static>> {
            self.as_ref().createBackup(
                arg_req,
            )
        }
        fn restoreMeta(
            &self,
            arg_req: &crate::types::RestoreMetaReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RestoreMetaError>> + ::std::marker::Send + 'static>> {
            self.as_ref().restoreMeta(
                arg_req,
            )
        }
        fn addListener(
            &self,
            arg_req: &crate::types::AddListenerReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddListenerError>> + ::std::marker::Send + 'static>> {
            self.as_ref().addListener(
                arg_req,
            )
        }
        fn removeListener(
            &self,
            arg_req: &crate::types::RemoveListenerReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveListenerError>> + ::std::marker::Send + 'static>> {
            self.as_ref().removeListener(
                arg_req,
            )
        }
        fn listListener(
            &self,
            arg_req: &crate::types::ListListenerReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListListenerResp, crate::errors::meta_service::ListListenerError>> + ::std::marker::Send + 'static>> {
            self.as_ref().listListener(
                arg_req,
            )
        }
        fn getStatis(
            &self,
            arg_req: &crate::types::GetStatisReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetStatisResp, crate::errors::meta_service::GetStatisError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getStatis(
                arg_req,
            )
        }
        fn signInFTService(
            &self,
            arg_req: &crate::types::SignInFTServiceReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::SignInFTServiceError>> + ::std::marker::Send + 'static>> {
            self.as_ref().signInFTService(
                arg_req,
            )
        }
        fn signOutFTService(
            &self,
            arg_req: &crate::types::SignOutFTServiceReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::SignOutFTServiceError>> + ::std::marker::Send + 'static>> {
            self.as_ref().signOutFTService(
                arg_req,
            )
        }
        fn listFTClients(
            &self,
            arg_req: &crate::types::ListFTClientsReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListFTClientsResp, crate::errors::meta_service::ListFTClientsError>> + ::std::marker::Send + 'static>> {
            self.as_ref().listFTClients(
                arg_req,
            )
        }
        fn createSession(
            &self,
            arg_req: &crate::types::CreateSessionReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::CreateSessionResp, crate::errors::meta_service::CreateSessionError>> + ::std::marker::Send + 'static>> {
            self.as_ref().createSession(
                arg_req,
            )
        }
        fn updateSessions(
            &self,
            arg_req: &crate::types::UpdateSessionsReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::UpdateSessionsError>> + ::std::marker::Send + 'static>> {
            self.as_ref().updateSessions(
                arg_req,
            )
        }
        fn listSessions(
            &self,
            arg_req: &crate::types::ListSessionsReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListSessionsResp, crate::errors::meta_service::ListSessionsError>> + ::std::marker::Send + 'static>> {
            self.as_ref().listSessions(
                arg_req,
            )
        }
        fn getSession(
            &self,
            arg_req: &crate::types::GetSessionReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetSessionResp, crate::errors::meta_service::GetSessionError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getSession(
                arg_req,
            )
        }
        fn removeSession(
            &self,
            arg_req: &crate::types::RemoveSessionReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveSessionError>> + ::std::marker::Send + 'static>> {
            self.as_ref().removeSession(
                arg_req,
            )
        }
        fn reportTaskFinish(
            &self,
            arg_req: &crate::types::ReportTaskReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::ReportTaskFinishError>> + ::std::marker::Send + 'static>> {
            self.as_ref().reportTaskFinish(
                arg_req,
            )
        }
    }

    pub struct make_MetaService;

    /// To be called by user directly setting up a client. Avoids
    /// needing ClientFactory trait in scope, avoids unidiomatic
    /// make_Trait name.
    ///
    /// ```
    /// # const _: &str = stringify! {
    /// use bgs::client::BuckGraphService;
    ///
    /// let protocol = BinaryProtocol::new();
    /// let transport = HttpClient::new();
    /// let client = BuckGraphService::new(protocol, transport);
    /// # };
    /// ```
    impl dyn MetaService {
        pub fn new<P, T>(
            protocol: P,
            transport: T,
        ) -> ::std::sync::Arc<impl MetaService + ::std::marker::Send + 'static>
        where
            P: ::fbthrift::Protocol<Frame = T>,
            T: ::fbthrift::Transport,
        {
            let _ = protocol;
            ::std::sync::Arc::new(MetaServiceImpl::<P, T>::new(transport))
        }
    }

    /// The same thing, but to be called from generic contexts where we are
    /// working with a type parameter `C: ClientFactory` to produce clients.
    impl ::fbthrift::ClientFactory for make_MetaService {
        type Api = dyn MetaService + ::std::marker::Send + ::std::marker::Sync + 'static;

        fn new<P, T>(protocol: P, transport: T) -> ::std::sync::Arc<Self::Api>
        where
            P: ::fbthrift::Protocol<Frame = T>,
            T: ::fbthrift::Transport + ::std::marker::Sync,
        {
            MetaService::new(protocol, transport)
        }
    }
}

pub mod server {
    #[::async_trait::async_trait]
    pub trait MetaService: ::std::marker::Send + ::std::marker::Sync + 'static {
        async fn createSpace(
            &self,
            _req: crate::types::CreateSpaceReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::CreateSpaceExn> {
            ::std::result::Result::Err(crate::services::meta_service::CreateSpaceExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "createSpace",
                ),
            ))
        }
        async fn dropSpace(
            &self,
            _req: crate::types::DropSpaceReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::DropSpaceExn> {
            ::std::result::Result::Err(crate::services::meta_service::DropSpaceExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "dropSpace",
                ),
            ))
        }
        async fn getSpace(
            &self,
            _req: crate::types::GetSpaceReq,
        ) -> ::std::result::Result<crate::types::GetSpaceResp, crate::services::meta_service::GetSpaceExn> {
            ::std::result::Result::Err(crate::services::meta_service::GetSpaceExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "getSpace",
                ),
            ))
        }
        async fn listSpaces(
            &self,
            _req: crate::types::ListSpacesReq,
        ) -> ::std::result::Result<crate::types::ListSpacesResp, crate::services::meta_service::ListSpacesExn> {
            ::std::result::Result::Err(crate::services::meta_service::ListSpacesExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listSpaces",
                ),
            ))
        }
        async fn createTag(
            &self,
            _req: crate::types::CreateTagReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::CreateTagExn> {
            ::std::result::Result::Err(crate::services::meta_service::CreateTagExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "createTag",
                ),
            ))
        }
        async fn alterTag(
            &self,
            _req: crate::types::AlterTagReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::AlterTagExn> {
            ::std::result::Result::Err(crate::services::meta_service::AlterTagExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "alterTag",
                ),
            ))
        }
        async fn dropTag(
            &self,
            _req: crate::types::DropTagReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::DropTagExn> {
            ::std::result::Result::Err(crate::services::meta_service::DropTagExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "dropTag",
                ),
            ))
        }
        async fn getTag(
            &self,
            _req: crate::types::GetTagReq,
        ) -> ::std::result::Result<crate::types::GetTagResp, crate::services::meta_service::GetTagExn> {
            ::std::result::Result::Err(crate::services::meta_service::GetTagExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "getTag",
                ),
            ))
        }
        async fn listTags(
            &self,
            _req: crate::types::ListTagsReq,
        ) -> ::std::result::Result<crate::types::ListTagsResp, crate::services::meta_service::ListTagsExn> {
            ::std::result::Result::Err(crate::services::meta_service::ListTagsExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listTags",
                ),
            ))
        }
        async fn createEdge(
            &self,
            _req: crate::types::CreateEdgeReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::CreateEdgeExn> {
            ::std::result::Result::Err(crate::services::meta_service::CreateEdgeExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "createEdge",
                ),
            ))
        }
        async fn alterEdge(
            &self,
            _req: crate::types::AlterEdgeReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::AlterEdgeExn> {
            ::std::result::Result::Err(crate::services::meta_service::AlterEdgeExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "alterEdge",
                ),
            ))
        }
        async fn dropEdge(
            &self,
            _req: crate::types::DropEdgeReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::DropEdgeExn> {
            ::std::result::Result::Err(crate::services::meta_service::DropEdgeExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "dropEdge",
                ),
            ))
        }
        async fn getEdge(
            &self,
            _req: crate::types::GetEdgeReq,
        ) -> ::std::result::Result<crate::types::GetEdgeResp, crate::services::meta_service::GetEdgeExn> {
            ::std::result::Result::Err(crate::services::meta_service::GetEdgeExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "getEdge",
                ),
            ))
        }
        async fn listEdges(
            &self,
            _req: crate::types::ListEdgesReq,
        ) -> ::std::result::Result<crate::types::ListEdgesResp, crate::services::meta_service::ListEdgesExn> {
            ::std::result::Result::Err(crate::services::meta_service::ListEdgesExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listEdges",
                ),
            ))
        }
        async fn listHosts(
            &self,
            _req: crate::types::ListHostsReq,
        ) -> ::std::result::Result<crate::types::ListHostsResp, crate::services::meta_service::ListHostsExn> {
            ::std::result::Result::Err(crate::services::meta_service::ListHostsExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listHosts",
                ),
            ))
        }
        async fn getPartsAlloc(
            &self,
            _req: crate::types::GetPartsAllocReq,
        ) -> ::std::result::Result<crate::types::GetPartsAllocResp, crate::services::meta_service::GetPartsAllocExn> {
            ::std::result::Result::Err(crate::services::meta_service::GetPartsAllocExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "getPartsAlloc",
                ),
            ))
        }
        async fn listParts(
            &self,
            _req: crate::types::ListPartsReq,
        ) -> ::std::result::Result<crate::types::ListPartsResp, crate::services::meta_service::ListPartsExn> {
            ::std::result::Result::Err(crate::services::meta_service::ListPartsExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listParts",
                ),
            ))
        }
        async fn multiPut(
            &self,
            _req: crate::types::MultiPutReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::MultiPutExn> {
            ::std::result::Result::Err(crate::services::meta_service::MultiPutExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "multiPut",
                ),
            ))
        }
        async fn get(
            &self,
            _req: crate::types::GetReq,
        ) -> ::std::result::Result<crate::types::GetResp, crate::services::meta_service::GetExn> {
            ::std::result::Result::Err(crate::services::meta_service::GetExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "get",
                ),
            ))
        }
        async fn multiGet(
            &self,
            _req: crate::types::MultiGetReq,
        ) -> ::std::result::Result<crate::types::MultiGetResp, crate::services::meta_service::MultiGetExn> {
            ::std::result::Result::Err(crate::services::meta_service::MultiGetExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "multiGet",
                ),
            ))
        }
        async fn remove(
            &self,
            _req: crate::types::RemoveReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::RemoveExn> {
            ::std::result::Result::Err(crate::services::meta_service::RemoveExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "remove",
                ),
            ))
        }
        async fn removeRange(
            &self,
            _req: crate::types::RemoveRangeReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::RemoveRangeExn> {
            ::std::result::Result::Err(crate::services::meta_service::RemoveRangeExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "removeRange",
                ),
            ))
        }
        async fn scan(
            &self,
            _req: crate::types::ScanReq,
        ) -> ::std::result::Result<crate::types::ScanResp, crate::services::meta_service::ScanExn> {
            ::std::result::Result::Err(crate::services::meta_service::ScanExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "scan",
                ),
            ))
        }
        async fn createTagIndex(
            &self,
            _req: crate::types::CreateTagIndexReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::CreateTagIndexExn> {
            ::std::result::Result::Err(crate::services::meta_service::CreateTagIndexExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "createTagIndex",
                ),
            ))
        }
        async fn dropTagIndex(
            &self,
            _req: crate::types::DropTagIndexReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::DropTagIndexExn> {
            ::std::result::Result::Err(crate::services::meta_service::DropTagIndexExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "dropTagIndex",
                ),
            ))
        }
        async fn getTagIndex(
            &self,
            _req: crate::types::GetTagIndexReq,
        ) -> ::std::result::Result<crate::types::GetTagIndexResp, crate::services::meta_service::GetTagIndexExn> {
            ::std::result::Result::Err(crate::services::meta_service::GetTagIndexExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "getTagIndex",
                ),
            ))
        }
        async fn listTagIndexes(
            &self,
            _req: crate::types::ListTagIndexesReq,
        ) -> ::std::result::Result<crate::types::ListTagIndexesResp, crate::services::meta_service::ListTagIndexesExn> {
            ::std::result::Result::Err(crate::services::meta_service::ListTagIndexesExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listTagIndexes",
                ),
            ))
        }
        async fn rebuildTagIndex(
            &self,
            _req: crate::types::RebuildIndexReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::RebuildTagIndexExn> {
            ::std::result::Result::Err(crate::services::meta_service::RebuildTagIndexExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "rebuildTagIndex",
                ),
            ))
        }
        async fn listTagIndexStatus(
            &self,
            _req: crate::types::ListIndexStatusReq,
        ) -> ::std::result::Result<crate::types::ListIndexStatusResp, crate::services::meta_service::ListTagIndexStatusExn> {
            ::std::result::Result::Err(crate::services::meta_service::ListTagIndexStatusExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listTagIndexStatus",
                ),
            ))
        }
        async fn createEdgeIndex(
            &self,
            _req: crate::types::CreateEdgeIndexReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::CreateEdgeIndexExn> {
            ::std::result::Result::Err(crate::services::meta_service::CreateEdgeIndexExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "createEdgeIndex",
                ),
            ))
        }
        async fn dropEdgeIndex(
            &self,
            _req: crate::types::DropEdgeIndexReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::DropEdgeIndexExn> {
            ::std::result::Result::Err(crate::services::meta_service::DropEdgeIndexExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "dropEdgeIndex",
                ),
            ))
        }
        async fn getEdgeIndex(
            &self,
            _req: crate::types::GetEdgeIndexReq,
        ) -> ::std::result::Result<crate::types::GetEdgeIndexResp, crate::services::meta_service::GetEdgeIndexExn> {
            ::std::result::Result::Err(crate::services::meta_service::GetEdgeIndexExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "getEdgeIndex",
                ),
            ))
        }
        async fn listEdgeIndexes(
            &self,
            _req: crate::types::ListEdgeIndexesReq,
        ) -> ::std::result::Result<crate::types::ListEdgeIndexesResp, crate::services::meta_service::ListEdgeIndexesExn> {
            ::std::result::Result::Err(crate::services::meta_service::ListEdgeIndexesExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listEdgeIndexes",
                ),
            ))
        }
        async fn rebuildEdgeIndex(
            &self,
            _req: crate::types::RebuildIndexReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::RebuildEdgeIndexExn> {
            ::std::result::Result::Err(crate::services::meta_service::RebuildEdgeIndexExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "rebuildEdgeIndex",
                ),
            ))
        }
        async fn listEdgeIndexStatus(
            &self,
            _req: crate::types::ListIndexStatusReq,
        ) -> ::std::result::Result<crate::types::ListIndexStatusResp, crate::services::meta_service::ListEdgeIndexStatusExn> {
            ::std::result::Result::Err(crate::services::meta_service::ListEdgeIndexStatusExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listEdgeIndexStatus",
                ),
            ))
        }
        async fn createUser(
            &self,
            _req: crate::types::CreateUserReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::CreateUserExn> {
            ::std::result::Result::Err(crate::services::meta_service::CreateUserExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "createUser",
                ),
            ))
        }
        async fn dropUser(
            &self,
            _req: crate::types::DropUserReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::DropUserExn> {
            ::std::result::Result::Err(crate::services::meta_service::DropUserExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "dropUser",
                ),
            ))
        }
        async fn alterUser(
            &self,
            _req: crate::types::AlterUserReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::AlterUserExn> {
            ::std::result::Result::Err(crate::services::meta_service::AlterUserExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "alterUser",
                ),
            ))
        }
        async fn grantRole(
            &self,
            _req: crate::types::GrantRoleReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::GrantRoleExn> {
            ::std::result::Result::Err(crate::services::meta_service::GrantRoleExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "grantRole",
                ),
            ))
        }
        async fn revokeRole(
            &self,
            _req: crate::types::RevokeRoleReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::RevokeRoleExn> {
            ::std::result::Result::Err(crate::services::meta_service::RevokeRoleExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "revokeRole",
                ),
            ))
        }
        async fn listUsers(
            &self,
            _req: crate::types::ListUsersReq,
        ) -> ::std::result::Result<crate::types::ListUsersResp, crate::services::meta_service::ListUsersExn> {
            ::std::result::Result::Err(crate::services::meta_service::ListUsersExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listUsers",
                ),
            ))
        }
        async fn listRoles(
            &self,
            _req: crate::types::ListRolesReq,
        ) -> ::std::result::Result<crate::types::ListRolesResp, crate::services::meta_service::ListRolesExn> {
            ::std::result::Result::Err(crate::services::meta_service::ListRolesExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listRoles",
                ),
            ))
        }
        async fn getUserRoles(
            &self,
            _req: crate::types::GetUserRolesReq,
        ) -> ::std::result::Result<crate::types::ListRolesResp, crate::services::meta_service::GetUserRolesExn> {
            ::std::result::Result::Err(crate::services::meta_service::GetUserRolesExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "getUserRoles",
                ),
            ))
        }
        async fn changePassword(
            &self,
            _req: crate::types::ChangePasswordReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::ChangePasswordExn> {
            ::std::result::Result::Err(crate::services::meta_service::ChangePasswordExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "changePassword",
                ),
            ))
        }
        async fn heartBeat(
            &self,
            _req: crate::types::HBReq,
        ) -> ::std::result::Result<crate::types::HBResp, crate::services::meta_service::HeartBeatExn> {
            ::std::result::Result::Err(crate::services::meta_service::HeartBeatExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "heartBeat",
                ),
            ))
        }
        async fn balance(
            &self,
            _req: crate::types::BalanceReq,
        ) -> ::std::result::Result<crate::types::BalanceResp, crate::services::meta_service::BalanceExn> {
            ::std::result::Result::Err(crate::services::meta_service::BalanceExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "balance",
                ),
            ))
        }
        async fn leaderBalance(
            &self,
            _req: crate::types::LeaderBalanceReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::LeaderBalanceExn> {
            ::std::result::Result::Err(crate::services::meta_service::LeaderBalanceExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "leaderBalance",
                ),
            ))
        }
        async fn regConfig(
            &self,
            _req: crate::types::RegConfigReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::RegConfigExn> {
            ::std::result::Result::Err(crate::services::meta_service::RegConfigExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "regConfig",
                ),
            ))
        }
        async fn getConfig(
            &self,
            _req: crate::types::GetConfigReq,
        ) -> ::std::result::Result<crate::types::GetConfigResp, crate::services::meta_service::GetConfigExn> {
            ::std::result::Result::Err(crate::services::meta_service::GetConfigExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "getConfig",
                ),
            ))
        }
        async fn setConfig(
            &self,
            _req: crate::types::SetConfigReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::SetConfigExn> {
            ::std::result::Result::Err(crate::services::meta_service::SetConfigExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "setConfig",
                ),
            ))
        }
        async fn listConfigs(
            &self,
            _req: crate::types::ListConfigsReq,
        ) -> ::std::result::Result<crate::types::ListConfigsResp, crate::services::meta_service::ListConfigsExn> {
            ::std::result::Result::Err(crate::services::meta_service::ListConfigsExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listConfigs",
                ),
            ))
        }
        async fn createSnapshot(
            &self,
            _req: crate::types::CreateSnapshotReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::CreateSnapshotExn> {
            ::std::result::Result::Err(crate::services::meta_service::CreateSnapshotExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "createSnapshot",
                ),
            ))
        }
        async fn dropSnapshot(
            &self,
            _req: crate::types::DropSnapshotReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::DropSnapshotExn> {
            ::std::result::Result::Err(crate::services::meta_service::DropSnapshotExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "dropSnapshot",
                ),
            ))
        }
        async fn listSnapshots(
            &self,
            _req: crate::types::ListSnapshotsReq,
        ) -> ::std::result::Result<crate::types::ListSnapshotsResp, crate::services::meta_service::ListSnapshotsExn> {
            ::std::result::Result::Err(crate::services::meta_service::ListSnapshotsExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listSnapshots",
                ),
            ))
        }
        async fn runAdminJob(
            &self,
            _req: crate::types::AdminJobReq,
        ) -> ::std::result::Result<crate::types::AdminJobResp, crate::services::meta_service::RunAdminJobExn> {
            ::std::result::Result::Err(crate::services::meta_service::RunAdminJobExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "runAdminJob",
                ),
            ))
        }
        async fn addZone(
            &self,
            _req: crate::types::AddZoneReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::AddZoneExn> {
            ::std::result::Result::Err(crate::services::meta_service::AddZoneExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "addZone",
                ),
            ))
        }
        async fn dropZone(
            &self,
            _req: crate::types::DropZoneReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::DropZoneExn> {
            ::std::result::Result::Err(crate::services::meta_service::DropZoneExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "dropZone",
                ),
            ))
        }
        async fn addHostIntoZone(
            &self,
            _req: crate::types::AddHostIntoZoneReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::AddHostIntoZoneExn> {
            ::std::result::Result::Err(crate::services::meta_service::AddHostIntoZoneExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "addHostIntoZone",
                ),
            ))
        }
        async fn dropHostFromZone(
            &self,
            _req: crate::types::DropHostFromZoneReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::DropHostFromZoneExn> {
            ::std::result::Result::Err(crate::services::meta_service::DropHostFromZoneExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "dropHostFromZone",
                ),
            ))
        }
        async fn getZone(
            &self,
            _req: crate::types::GetZoneReq,
        ) -> ::std::result::Result<crate::types::GetZoneResp, crate::services::meta_service::GetZoneExn> {
            ::std::result::Result::Err(crate::services::meta_service::GetZoneExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "getZone",
                ),
            ))
        }
        async fn listZones(
            &self,
            _req: crate::types::ListZonesReq,
        ) -> ::std::result::Result<crate::types::ListZonesResp, crate::services::meta_service::ListZonesExn> {
            ::std::result::Result::Err(crate::services::meta_service::ListZonesExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listZones",
                ),
            ))
        }
        async fn addGroup(
            &self,
            _req: crate::types::AddGroupReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::AddGroupExn> {
            ::std::result::Result::Err(crate::services::meta_service::AddGroupExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "addGroup",
                ),
            ))
        }
        async fn dropGroup(
            &self,
            _req: crate::types::DropGroupReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::DropGroupExn> {
            ::std::result::Result::Err(crate::services::meta_service::DropGroupExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "dropGroup",
                ),
            ))
        }
        async fn addZoneIntoGroup(
            &self,
            _req: crate::types::AddZoneIntoGroupReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::AddZoneIntoGroupExn> {
            ::std::result::Result::Err(crate::services::meta_service::AddZoneIntoGroupExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "addZoneIntoGroup",
                ),
            ))
        }
        async fn dropZoneFromGroup(
            &self,
            _req: crate::types::DropZoneFromGroupReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::DropZoneFromGroupExn> {
            ::std::result::Result::Err(crate::services::meta_service::DropZoneFromGroupExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "dropZoneFromGroup",
                ),
            ))
        }
        async fn getGroup(
            &self,
            _req: crate::types::GetGroupReq,
        ) -> ::std::result::Result<crate::types::GetGroupResp, crate::services::meta_service::GetGroupExn> {
            ::std::result::Result::Err(crate::services::meta_service::GetGroupExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "getGroup",
                ),
            ))
        }
        async fn listGroups(
            &self,
            _req: crate::types::ListGroupsReq,
        ) -> ::std::result::Result<crate::types::ListGroupsResp, crate::services::meta_service::ListGroupsExn> {
            ::std::result::Result::Err(crate::services::meta_service::ListGroupsExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listGroups",
                ),
            ))
        }
        async fn createBackup(
            &self,
            _req: crate::types::CreateBackupReq,
        ) -> ::std::result::Result<crate::types::CreateBackupResp, crate::services::meta_service::CreateBackupExn> {
            ::std::result::Result::Err(crate::services::meta_service::CreateBackupExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "createBackup",
                ),
            ))
        }
        async fn restoreMeta(
            &self,
            _req: crate::types::RestoreMetaReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::RestoreMetaExn> {
            ::std::result::Result::Err(crate::services::meta_service::RestoreMetaExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "restoreMeta",
                ),
            ))
        }
        async fn addListener(
            &self,
            _req: crate::types::AddListenerReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::AddListenerExn> {
            ::std::result::Result::Err(crate::services::meta_service::AddListenerExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "addListener",
                ),
            ))
        }
        async fn removeListener(
            &self,
            _req: crate::types::RemoveListenerReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::RemoveListenerExn> {
            ::std::result::Result::Err(crate::services::meta_service::RemoveListenerExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "removeListener",
                ),
            ))
        }
        async fn listListener(
            &self,
            _req: crate::types::ListListenerReq,
        ) -> ::std::result::Result<crate::types::ListListenerResp, crate::services::meta_service::ListListenerExn> {
            ::std::result::Result::Err(crate::services::meta_service::ListListenerExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listListener",
                ),
            ))
        }
        async fn getStatis(
            &self,
            _req: crate::types::GetStatisReq,
        ) -> ::std::result::Result<crate::types::GetStatisResp, crate::services::meta_service::GetStatisExn> {
            ::std::result::Result::Err(crate::services::meta_service::GetStatisExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "getStatis",
                ),
            ))
        }
        async fn signInFTService(
            &self,
            _req: crate::types::SignInFTServiceReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::SignInFTServiceExn> {
            ::std::result::Result::Err(crate::services::meta_service::SignInFTServiceExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "signInFTService",
                ),
            ))
        }
        async fn signOutFTService(
            &self,
            _req: crate::types::SignOutFTServiceReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::SignOutFTServiceExn> {
            ::std::result::Result::Err(crate::services::meta_service::SignOutFTServiceExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "signOutFTService",
                ),
            ))
        }
        async fn listFTClients(
            &self,
            _req: crate::types::ListFTClientsReq,
        ) -> ::std::result::Result<crate::types::ListFTClientsResp, crate::services::meta_service::ListFTClientsExn> {
            ::std::result::Result::Err(crate::services::meta_service::ListFTClientsExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listFTClients",
                ),
            ))
        }
        async fn createSession(
            &self,
            _req: crate::types::CreateSessionReq,
        ) -> ::std::result::Result<crate::types::CreateSessionResp, crate::services::meta_service::CreateSessionExn> {
            ::std::result::Result::Err(crate::services::meta_service::CreateSessionExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "createSession",
                ),
            ))
        }
        async fn updateSessions(
            &self,
            _req: crate::types::UpdateSessionsReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::UpdateSessionsExn> {
            ::std::result::Result::Err(crate::services::meta_service::UpdateSessionsExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "updateSessions",
                ),
            ))
        }
        async fn listSessions(
            &self,
            _req: crate::types::ListSessionsReq,
        ) -> ::std::result::Result<crate::types::ListSessionsResp, crate::services::meta_service::ListSessionsExn> {
            ::std::result::Result::Err(crate::services::meta_service::ListSessionsExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listSessions",
                ),
            ))
        }
        async fn getSession(
            &self,
            _req: crate::types::GetSessionReq,
        ) -> ::std::result::Result<crate::types::GetSessionResp, crate::services::meta_service::GetSessionExn> {
            ::std::result::Result::Err(crate::services::meta_service::GetSessionExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "getSession",
                ),
            ))
        }
        async fn removeSession(
            &self,
            _req: crate::types::RemoveSessionReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::RemoveSessionExn> {
            ::std::result::Result::Err(crate::services::meta_service::RemoveSessionExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "removeSession",
                ),
            ))
        }
        async fn reportTaskFinish(
            &self,
            _req: crate::types::ReportTaskReq,
        ) -> ::std::result::Result<crate::types::ExecResp, crate::services::meta_service::ReportTaskFinishExn> {
            ::std::result::Result::Err(crate::services::meta_service::ReportTaskFinishExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "reportTaskFinish",
                ),
            ))
        }
    }

    #[derive(Clone, Debug)]
    pub struct MetaServiceProcessor<P, H, R> {
        service: H,
        supa: ::fbthrift::NullServiceProcessor<P, R>,
        _phantom: ::std::marker::PhantomData<(P, H, R)>,
    }

    impl<P, H, R> MetaServiceProcessor<P, H, R>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Deserializer: ::std::marker::Send,
        H: MetaService,
        R: ::fbthrift::RequestContext<Name = ::const_cstr::ConstCStr> + ::std::marker::Sync,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack + ::std::marker::Send + ::std::marker::Sync,
    {
        pub fn new(service: H) -> Self {
            Self {
                service,
                supa: ::fbthrift::NullServiceProcessor::new(),
                _phantom: ::std::marker::PhantomData,
            }
        }

        pub fn into_inner(self) -> H {
            self.service
        }

        async fn handle_createSpace<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createSpace";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.createSpace(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "createSpace",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::CreateSpaceExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::CreateSpaceExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::CreateSpaceExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "createSpace",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "createSpace",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_dropSpace<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropSpace";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.dropSpace(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "dropSpace",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::DropSpaceExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::DropSpaceExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::DropSpaceExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "dropSpace",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "dropSpace",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_getSpace<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getSpace";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.getSpace(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "getSpace",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::GetSpaceExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::GetSpaceExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::GetSpaceExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getSpace",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getSpace",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_listSpaces<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listSpaces";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.listSpaces(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "listSpaces",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::ListSpacesExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::ListSpacesExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::ListSpacesExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listSpaces",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "listSpaces",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_createTag<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createTag";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.createTag(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "createTag",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::CreateTagExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::CreateTagExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::CreateTagExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "createTag",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "createTag",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_alterTag<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.alterTag";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.alterTag(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "alterTag",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::AlterTagExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::AlterTagExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::AlterTagExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "alterTag",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "alterTag",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_dropTag<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropTag";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.dropTag(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "dropTag",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::DropTagExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::DropTagExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::DropTagExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "dropTag",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "dropTag",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_getTag<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getTag";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.getTag(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "getTag",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::GetTagExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::GetTagExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::GetTagExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getTag",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getTag",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_listTags<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listTags";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.listTags(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "listTags",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::ListTagsExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::ListTagsExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::ListTagsExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listTags",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "listTags",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_createEdge<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createEdge";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.createEdge(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "createEdge",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::CreateEdgeExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::CreateEdgeExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::CreateEdgeExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "createEdge",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "createEdge",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_alterEdge<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.alterEdge";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.alterEdge(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "alterEdge",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::AlterEdgeExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::AlterEdgeExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::AlterEdgeExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "alterEdge",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "alterEdge",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_dropEdge<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropEdge";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.dropEdge(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "dropEdge",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::DropEdgeExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::DropEdgeExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::DropEdgeExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "dropEdge",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "dropEdge",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_getEdge<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getEdge";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.getEdge(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "getEdge",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::GetEdgeExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::GetEdgeExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::GetEdgeExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getEdge",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getEdge",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_listEdges<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listEdges";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.listEdges(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "listEdges",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::ListEdgesExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::ListEdgesExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::ListEdgesExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listEdges",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "listEdges",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_listHosts<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listHosts";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.listHosts(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "listHosts",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::ListHostsExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::ListHostsExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::ListHostsExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listHosts",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "listHosts",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_getPartsAlloc<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getPartsAlloc";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.getPartsAlloc(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "getPartsAlloc",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::GetPartsAllocExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::GetPartsAllocExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::GetPartsAllocExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getPartsAlloc",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getPartsAlloc",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_listParts<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listParts";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.listParts(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "listParts",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::ListPartsExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::ListPartsExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::ListPartsExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listParts",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "listParts",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_multiPut<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.multiPut";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.multiPut(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "multiPut",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::MultiPutExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::MultiPutExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::MultiPutExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "multiPut",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "multiPut",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_get<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.get";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.get(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "get",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::GetExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::GetExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::GetExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "get",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "get",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_multiGet<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.multiGet";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.multiGet(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "multiGet",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::MultiGetExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::MultiGetExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::MultiGetExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "multiGet",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "multiGet",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_remove<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.remove";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.remove(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "remove",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::RemoveExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::RemoveExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::RemoveExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "remove",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "remove",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_removeRange<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.removeRange";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.removeRange(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "removeRange",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::RemoveRangeExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::RemoveRangeExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::RemoveRangeExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "removeRange",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "removeRange",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_scan<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.scan";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.scan(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "scan",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::ScanExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::ScanExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::ScanExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "scan",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "scan",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_createTagIndex<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createTagIndex";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.createTagIndex(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "createTagIndex",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::CreateTagIndexExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::CreateTagIndexExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::CreateTagIndexExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "createTagIndex",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "createTagIndex",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_dropTagIndex<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropTagIndex";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.dropTagIndex(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "dropTagIndex",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::DropTagIndexExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::DropTagIndexExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::DropTagIndexExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "dropTagIndex",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "dropTagIndex",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_getTagIndex<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getTagIndex";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.getTagIndex(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "getTagIndex",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::GetTagIndexExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::GetTagIndexExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::GetTagIndexExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getTagIndex",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getTagIndex",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_listTagIndexes<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listTagIndexes";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.listTagIndexes(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "listTagIndexes",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::ListTagIndexesExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::ListTagIndexesExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::ListTagIndexesExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listTagIndexes",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "listTagIndexes",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_rebuildTagIndex<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.rebuildTagIndex";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.rebuildTagIndex(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "rebuildTagIndex",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::RebuildTagIndexExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::RebuildTagIndexExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::RebuildTagIndexExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "rebuildTagIndex",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "rebuildTagIndex",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_listTagIndexStatus<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listTagIndexStatus";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.listTagIndexStatus(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "listTagIndexStatus",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::ListTagIndexStatusExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::ListTagIndexStatusExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::ListTagIndexStatusExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listTagIndexStatus",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "listTagIndexStatus",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_createEdgeIndex<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createEdgeIndex";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.createEdgeIndex(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "createEdgeIndex",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::CreateEdgeIndexExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::CreateEdgeIndexExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::CreateEdgeIndexExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "createEdgeIndex",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "createEdgeIndex",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_dropEdgeIndex<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropEdgeIndex";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.dropEdgeIndex(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "dropEdgeIndex",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::DropEdgeIndexExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::DropEdgeIndexExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::DropEdgeIndexExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "dropEdgeIndex",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "dropEdgeIndex",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_getEdgeIndex<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getEdgeIndex";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.getEdgeIndex(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "getEdgeIndex",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::GetEdgeIndexExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::GetEdgeIndexExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::GetEdgeIndexExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getEdgeIndex",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getEdgeIndex",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_listEdgeIndexes<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listEdgeIndexes";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.listEdgeIndexes(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "listEdgeIndexes",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::ListEdgeIndexesExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::ListEdgeIndexesExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::ListEdgeIndexesExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listEdgeIndexes",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "listEdgeIndexes",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_rebuildEdgeIndex<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.rebuildEdgeIndex";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.rebuildEdgeIndex(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "rebuildEdgeIndex",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::RebuildEdgeIndexExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::RebuildEdgeIndexExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::RebuildEdgeIndexExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "rebuildEdgeIndex",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "rebuildEdgeIndex",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_listEdgeIndexStatus<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listEdgeIndexStatus";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.listEdgeIndexStatus(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "listEdgeIndexStatus",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::ListEdgeIndexStatusExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::ListEdgeIndexStatusExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::ListEdgeIndexStatusExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listEdgeIndexStatus",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "listEdgeIndexStatus",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_createUser<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createUser";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.createUser(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "createUser",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::CreateUserExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::CreateUserExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::CreateUserExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "createUser",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "createUser",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_dropUser<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropUser";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.dropUser(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "dropUser",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::DropUserExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::DropUserExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::DropUserExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "dropUser",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "dropUser",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_alterUser<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.alterUser";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.alterUser(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "alterUser",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::AlterUserExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::AlterUserExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::AlterUserExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "alterUser",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "alterUser",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_grantRole<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.grantRole";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.grantRole(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "grantRole",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::GrantRoleExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::GrantRoleExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::GrantRoleExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "grantRole",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "grantRole",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_revokeRole<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.revokeRole";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.revokeRole(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "revokeRole",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::RevokeRoleExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::RevokeRoleExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::RevokeRoleExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "revokeRole",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "revokeRole",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_listUsers<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listUsers";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.listUsers(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "listUsers",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::ListUsersExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::ListUsersExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::ListUsersExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listUsers",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "listUsers",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_listRoles<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listRoles";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.listRoles(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "listRoles",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::ListRolesExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::ListRolesExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::ListRolesExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listRoles",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "listRoles",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_getUserRoles<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getUserRoles";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.getUserRoles(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "getUserRoles",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::GetUserRolesExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::GetUserRolesExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::GetUserRolesExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getUserRoles",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getUserRoles",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_changePassword<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.changePassword";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.changePassword(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "changePassword",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::ChangePasswordExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::ChangePasswordExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::ChangePasswordExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "changePassword",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "changePassword",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_heartBeat<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.heartBeat";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.heartBeat(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "heartBeat",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::HeartBeatExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::HeartBeatExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::HeartBeatExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "heartBeat",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "heartBeat",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_balance<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.balance";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.balance(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "balance",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::BalanceExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::BalanceExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::BalanceExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "balance",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "balance",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_leaderBalance<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.leaderBalance";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.leaderBalance(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "leaderBalance",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::LeaderBalanceExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::LeaderBalanceExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::LeaderBalanceExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "leaderBalance",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "leaderBalance",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_regConfig<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.regConfig";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.regConfig(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "regConfig",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::RegConfigExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::RegConfigExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::RegConfigExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "regConfig",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "regConfig",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_getConfig<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getConfig";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.getConfig(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "getConfig",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::GetConfigExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::GetConfigExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::GetConfigExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getConfig",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getConfig",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_setConfig<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.setConfig";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.setConfig(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "setConfig",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::SetConfigExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::SetConfigExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::SetConfigExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "setConfig",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "setConfig",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_listConfigs<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listConfigs";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.listConfigs(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "listConfigs",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::ListConfigsExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::ListConfigsExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::ListConfigsExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listConfigs",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "listConfigs",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_createSnapshot<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createSnapshot";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.createSnapshot(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "createSnapshot",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::CreateSnapshotExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::CreateSnapshotExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::CreateSnapshotExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "createSnapshot",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "createSnapshot",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_dropSnapshot<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropSnapshot";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.dropSnapshot(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "dropSnapshot",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::DropSnapshotExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::DropSnapshotExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::DropSnapshotExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "dropSnapshot",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "dropSnapshot",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_listSnapshots<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listSnapshots";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.listSnapshots(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "listSnapshots",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::ListSnapshotsExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::ListSnapshotsExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::ListSnapshotsExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listSnapshots",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "listSnapshots",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_runAdminJob<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.runAdminJob";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.runAdminJob(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "runAdminJob",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::RunAdminJobExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::RunAdminJobExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::RunAdminJobExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "runAdminJob",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "runAdminJob",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_addZone<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.addZone";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.addZone(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "addZone",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::AddZoneExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::AddZoneExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::AddZoneExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "addZone",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "addZone",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_dropZone<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropZone";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.dropZone(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "dropZone",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::DropZoneExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::DropZoneExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::DropZoneExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "dropZone",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "dropZone",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_addHostIntoZone<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.addHostIntoZone";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.addHostIntoZone(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "addHostIntoZone",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::AddHostIntoZoneExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::AddHostIntoZoneExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::AddHostIntoZoneExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "addHostIntoZone",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "addHostIntoZone",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_dropHostFromZone<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropHostFromZone";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.dropHostFromZone(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "dropHostFromZone",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::DropHostFromZoneExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::DropHostFromZoneExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::DropHostFromZoneExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "dropHostFromZone",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "dropHostFromZone",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_getZone<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getZone";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.getZone(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "getZone",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::GetZoneExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::GetZoneExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::GetZoneExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getZone",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getZone",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_listZones<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listZones";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.listZones(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "listZones",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::ListZonesExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::ListZonesExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::ListZonesExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listZones",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "listZones",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_addGroup<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.addGroup";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.addGroup(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "addGroup",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::AddGroupExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::AddGroupExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::AddGroupExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "addGroup",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "addGroup",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_dropGroup<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropGroup";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.dropGroup(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "dropGroup",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::DropGroupExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::DropGroupExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::DropGroupExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "dropGroup",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "dropGroup",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_addZoneIntoGroup<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.addZoneIntoGroup";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.addZoneIntoGroup(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "addZoneIntoGroup",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::AddZoneIntoGroupExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::AddZoneIntoGroupExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::AddZoneIntoGroupExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "addZoneIntoGroup",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "addZoneIntoGroup",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_dropZoneFromGroup<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropZoneFromGroup";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.dropZoneFromGroup(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "dropZoneFromGroup",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::DropZoneFromGroupExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::DropZoneFromGroupExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::DropZoneFromGroupExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "dropZoneFromGroup",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "dropZoneFromGroup",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_getGroup<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getGroup";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.getGroup(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "getGroup",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::GetGroupExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::GetGroupExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::GetGroupExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getGroup",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getGroup",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_listGroups<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listGroups";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.listGroups(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "listGroups",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::ListGroupsExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::ListGroupsExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::ListGroupsExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listGroups",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "listGroups",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_createBackup<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createBackup";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.createBackup(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "createBackup",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::CreateBackupExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::CreateBackupExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::CreateBackupExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "createBackup",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "createBackup",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_restoreMeta<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.restoreMeta";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.restoreMeta(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "restoreMeta",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::RestoreMetaExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::RestoreMetaExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::RestoreMetaExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "restoreMeta",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "restoreMeta",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_addListener<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.addListener";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.addListener(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "addListener",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::AddListenerExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::AddListenerExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::AddListenerExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "addListener",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "addListener",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_removeListener<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.removeListener";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.removeListener(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "removeListener",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::RemoveListenerExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::RemoveListenerExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::RemoveListenerExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "removeListener",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "removeListener",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_listListener<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listListener";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.listListener(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "listListener",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::ListListenerExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::ListListenerExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::ListListenerExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listListener",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "listListener",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_getStatis<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getStatis";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.getStatis(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "getStatis",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::GetStatisExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::GetStatisExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::GetStatisExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getStatis",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getStatis",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_signInFTService<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.signInFTService";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.signInFTService(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "signInFTService",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::SignInFTServiceExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::SignInFTServiceExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::SignInFTServiceExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "signInFTService",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "signInFTService",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_signOutFTService<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.signOutFTService";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.signOutFTService(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "signOutFTService",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::SignOutFTServiceExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::SignOutFTServiceExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::SignOutFTServiceExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "signOutFTService",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "signOutFTService",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_listFTClients<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listFTClients";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.listFTClients(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "listFTClients",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::ListFTClientsExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::ListFTClientsExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::ListFTClientsExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listFTClients",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "listFTClients",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_createSession<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createSession";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.createSession(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "createSession",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::CreateSessionExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::CreateSessionExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::CreateSessionExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "createSession",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "createSession",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_updateSessions<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.updateSessions";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.updateSessions(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "updateSessions",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::UpdateSessionsExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::UpdateSessionsExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::UpdateSessionsExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "updateSessions",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "updateSessions",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_listSessions<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listSessions";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.listSessions(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "listSessions",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::ListSessionsExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::ListSessionsExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::ListSessionsExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listSessions",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "listSessions",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_getSession<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getSession";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.getSession(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "getSession",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::GetSessionExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::GetSessionExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::GetSessionExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getSession",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getSession",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_removeSession<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.removeSession";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.removeSession(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "removeSession",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::RemoveSessionExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::RemoveSessionExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::RemoveSessionExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "removeSession",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "removeSession",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }

        async fn handle_reportTaskFinish<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::ProtocolReader as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.reportTaskFinish";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                &SERVICE_NAME,
                &METHOD_NAME,
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;

            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;

            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;
            let res = self.service.reportTaskFinish(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "reportTaskFinish",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::meta_service::ReportTaskFinishExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::meta_service::ReportTaskFinishExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::meta_service::ReportTaskFinishExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "reportTaskFinish",
                    )
                }
            };
            ::fbthrift::ContextStack::pre_write(&mut ctx_stack)?;
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "reportTaskFinish",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::fbthrift::ContextStack::post_write(&mut ctx_stack, 0)?;
            ::std::result::Result::Ok(res)
        }
    }

    #[::async_trait::async_trait]
    impl<P, H, R> ::fbthrift::ServiceProcessor<P> for MetaServiceProcessor<P, H, R>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Deserializer: ::std::marker::Send,
        H: MetaService,
        R: ::fbthrift::RequestContext<Name = ::const_cstr::ConstCStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack + ::std::marker::Send + ::std::marker::Sync + 'static
    {
        type RequestContext = R;

        #[inline]
        fn method_idx(&self, name: &[::std::primitive::u8]) -> ::std::result::Result<::std::primitive::usize, ::fbthrift::ApplicationException> {
            match name {
                b"createSpace" => ::std::result::Result::Ok(0usize),
                b"dropSpace" => ::std::result::Result::Ok(1usize),
                b"getSpace" => ::std::result::Result::Ok(2usize),
                b"listSpaces" => ::std::result::Result::Ok(3usize),
                b"createTag" => ::std::result::Result::Ok(4usize),
                b"alterTag" => ::std::result::Result::Ok(5usize),
                b"dropTag" => ::std::result::Result::Ok(6usize),
                b"getTag" => ::std::result::Result::Ok(7usize),
                b"listTags" => ::std::result::Result::Ok(8usize),
                b"createEdge" => ::std::result::Result::Ok(9usize),
                b"alterEdge" => ::std::result::Result::Ok(10usize),
                b"dropEdge" => ::std::result::Result::Ok(11usize),
                b"getEdge" => ::std::result::Result::Ok(12usize),
                b"listEdges" => ::std::result::Result::Ok(13usize),
                b"listHosts" => ::std::result::Result::Ok(14usize),
                b"getPartsAlloc" => ::std::result::Result::Ok(15usize),
                b"listParts" => ::std::result::Result::Ok(16usize),
                b"multiPut" => ::std::result::Result::Ok(17usize),
                b"get" => ::std::result::Result::Ok(18usize),
                b"multiGet" => ::std::result::Result::Ok(19usize),
                b"remove" => ::std::result::Result::Ok(20usize),
                b"removeRange" => ::std::result::Result::Ok(21usize),
                b"scan" => ::std::result::Result::Ok(22usize),
                b"createTagIndex" => ::std::result::Result::Ok(23usize),
                b"dropTagIndex" => ::std::result::Result::Ok(24usize),
                b"getTagIndex" => ::std::result::Result::Ok(25usize),
                b"listTagIndexes" => ::std::result::Result::Ok(26usize),
                b"rebuildTagIndex" => ::std::result::Result::Ok(27usize),
                b"listTagIndexStatus" => ::std::result::Result::Ok(28usize),
                b"createEdgeIndex" => ::std::result::Result::Ok(29usize),
                b"dropEdgeIndex" => ::std::result::Result::Ok(30usize),
                b"getEdgeIndex" => ::std::result::Result::Ok(31usize),
                b"listEdgeIndexes" => ::std::result::Result::Ok(32usize),
                b"rebuildEdgeIndex" => ::std::result::Result::Ok(33usize),
                b"listEdgeIndexStatus" => ::std::result::Result::Ok(34usize),
                b"createUser" => ::std::result::Result::Ok(35usize),
                b"dropUser" => ::std::result::Result::Ok(36usize),
                b"alterUser" => ::std::result::Result::Ok(37usize),
                b"grantRole" => ::std::result::Result::Ok(38usize),
                b"revokeRole" => ::std::result::Result::Ok(39usize),
                b"listUsers" => ::std::result::Result::Ok(40usize),
                b"listRoles" => ::std::result::Result::Ok(41usize),
                b"getUserRoles" => ::std::result::Result::Ok(42usize),
                b"changePassword" => ::std::result::Result::Ok(43usize),
                b"heartBeat" => ::std::result::Result::Ok(44usize),
                b"balance" => ::std::result::Result::Ok(45usize),
                b"leaderBalance" => ::std::result::Result::Ok(46usize),
                b"regConfig" => ::std::result::Result::Ok(47usize),
                b"getConfig" => ::std::result::Result::Ok(48usize),
                b"setConfig" => ::std::result::Result::Ok(49usize),
                b"listConfigs" => ::std::result::Result::Ok(50usize),
                b"createSnapshot" => ::std::result::Result::Ok(51usize),
                b"dropSnapshot" => ::std::result::Result::Ok(52usize),
                b"listSnapshots" => ::std::result::Result::Ok(53usize),
                b"runAdminJob" => ::std::result::Result::Ok(54usize),
                b"addZone" => ::std::result::Result::Ok(55usize),
                b"dropZone" => ::std::result::Result::Ok(56usize),
                b"addHostIntoZone" => ::std::result::Result::Ok(57usize),
                b"dropHostFromZone" => ::std::result::Result::Ok(58usize),
                b"getZone" => ::std::result::Result::Ok(59usize),
                b"listZones" => ::std::result::Result::Ok(60usize),
                b"addGroup" => ::std::result::Result::Ok(61usize),
                b"dropGroup" => ::std::result::Result::Ok(62usize),
                b"addZoneIntoGroup" => ::std::result::Result::Ok(63usize),
                b"dropZoneFromGroup" => ::std::result::Result::Ok(64usize),
                b"getGroup" => ::std::result::Result::Ok(65usize),
                b"listGroups" => ::std::result::Result::Ok(66usize),
                b"createBackup" => ::std::result::Result::Ok(67usize),
                b"restoreMeta" => ::std::result::Result::Ok(68usize),
                b"addListener" => ::std::result::Result::Ok(69usize),
                b"removeListener" => ::std::result::Result::Ok(70usize),
                b"listListener" => ::std::result::Result::Ok(71usize),
                b"getStatis" => ::std::result::Result::Ok(72usize),
                b"signInFTService" => ::std::result::Result::Ok(73usize),
                b"signOutFTService" => ::std::result::Result::Ok(74usize),
                b"listFTClients" => ::std::result::Result::Ok(75usize),
                b"createSession" => ::std::result::Result::Ok(76usize),
                b"updateSessions" => ::std::result::Result::Ok(77usize),
                b"listSessions" => ::std::result::Result::Ok(78usize),
                b"getSession" => ::std::result::Result::Ok(79usize),
                b"removeSession" => ::std::result::Result::Ok(80usize),
                b"reportTaskFinish" => ::std::result::Result::Ok(81usize),
                _ => ::std::result::Result::Err(::fbthrift::ApplicationException::unknown_method()),
            }
        }

        async fn handle_method(
            &self,
            idx: ::std::primitive::usize,
            _p: &mut P::Deserializer,
            _r: &R,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            match idx {
                0usize => self.handle_createSpace(_p, _r, _seqid).await,
                1usize => self.handle_dropSpace(_p, _r, _seqid).await,
                2usize => self.handle_getSpace(_p, _r, _seqid).await,
                3usize => self.handle_listSpaces(_p, _r, _seqid).await,
                4usize => self.handle_createTag(_p, _r, _seqid).await,
                5usize => self.handle_alterTag(_p, _r, _seqid).await,
                6usize => self.handle_dropTag(_p, _r, _seqid).await,
                7usize => self.handle_getTag(_p, _r, _seqid).await,
                8usize => self.handle_listTags(_p, _r, _seqid).await,
                9usize => self.handle_createEdge(_p, _r, _seqid).await,
                10usize => self.handle_alterEdge(_p, _r, _seqid).await,
                11usize => self.handle_dropEdge(_p, _r, _seqid).await,
                12usize => self.handle_getEdge(_p, _r, _seqid).await,
                13usize => self.handle_listEdges(_p, _r, _seqid).await,
                14usize => self.handle_listHosts(_p, _r, _seqid).await,
                15usize => self.handle_getPartsAlloc(_p, _r, _seqid).await,
                16usize => self.handle_listParts(_p, _r, _seqid).await,
                17usize => self.handle_multiPut(_p, _r, _seqid).await,
                18usize => self.handle_get(_p, _r, _seqid).await,
                19usize => self.handle_multiGet(_p, _r, _seqid).await,
                20usize => self.handle_remove(_p, _r, _seqid).await,
                21usize => self.handle_removeRange(_p, _r, _seqid).await,
                22usize => self.handle_scan(_p, _r, _seqid).await,
                23usize => self.handle_createTagIndex(_p, _r, _seqid).await,
                24usize => self.handle_dropTagIndex(_p, _r, _seqid).await,
                25usize => self.handle_getTagIndex(_p, _r, _seqid).await,
                26usize => self.handle_listTagIndexes(_p, _r, _seqid).await,
                27usize => self.handle_rebuildTagIndex(_p, _r, _seqid).await,
                28usize => self.handle_listTagIndexStatus(_p, _r, _seqid).await,
                29usize => self.handle_createEdgeIndex(_p, _r, _seqid).await,
                30usize => self.handle_dropEdgeIndex(_p, _r, _seqid).await,
                31usize => self.handle_getEdgeIndex(_p, _r, _seqid).await,
                32usize => self.handle_listEdgeIndexes(_p, _r, _seqid).await,
                33usize => self.handle_rebuildEdgeIndex(_p, _r, _seqid).await,
                34usize => self.handle_listEdgeIndexStatus(_p, _r, _seqid).await,
                35usize => self.handle_createUser(_p, _r, _seqid).await,
                36usize => self.handle_dropUser(_p, _r, _seqid).await,
                37usize => self.handle_alterUser(_p, _r, _seqid).await,
                38usize => self.handle_grantRole(_p, _r, _seqid).await,
                39usize => self.handle_revokeRole(_p, _r, _seqid).await,
                40usize => self.handle_listUsers(_p, _r, _seqid).await,
                41usize => self.handle_listRoles(_p, _r, _seqid).await,
                42usize => self.handle_getUserRoles(_p, _r, _seqid).await,
                43usize => self.handle_changePassword(_p, _r, _seqid).await,
                44usize => self.handle_heartBeat(_p, _r, _seqid).await,
                45usize => self.handle_balance(_p, _r, _seqid).await,
                46usize => self.handle_leaderBalance(_p, _r, _seqid).await,
                47usize => self.handle_regConfig(_p, _r, _seqid).await,
                48usize => self.handle_getConfig(_p, _r, _seqid).await,
                49usize => self.handle_setConfig(_p, _r, _seqid).await,
                50usize => self.handle_listConfigs(_p, _r, _seqid).await,
                51usize => self.handle_createSnapshot(_p, _r, _seqid).await,
                52usize => self.handle_dropSnapshot(_p, _r, _seqid).await,
                53usize => self.handle_listSnapshots(_p, _r, _seqid).await,
                54usize => self.handle_runAdminJob(_p, _r, _seqid).await,
                55usize => self.handle_addZone(_p, _r, _seqid).await,
                56usize => self.handle_dropZone(_p, _r, _seqid).await,
                57usize => self.handle_addHostIntoZone(_p, _r, _seqid).await,
                58usize => self.handle_dropHostFromZone(_p, _r, _seqid).await,
                59usize => self.handle_getZone(_p, _r, _seqid).await,
                60usize => self.handle_listZones(_p, _r, _seqid).await,
                61usize => self.handle_addGroup(_p, _r, _seqid).await,
                62usize => self.handle_dropGroup(_p, _r, _seqid).await,
                63usize => self.handle_addZoneIntoGroup(_p, _r, _seqid).await,
                64usize => self.handle_dropZoneFromGroup(_p, _r, _seqid).await,
                65usize => self.handle_getGroup(_p, _r, _seqid).await,
                66usize => self.handle_listGroups(_p, _r, _seqid).await,
                67usize => self.handle_createBackup(_p, _r, _seqid).await,
                68usize => self.handle_restoreMeta(_p, _r, _seqid).await,
                69usize => self.handle_addListener(_p, _r, _seqid).await,
                70usize => self.handle_removeListener(_p, _r, _seqid).await,
                71usize => self.handle_listListener(_p, _r, _seqid).await,
                72usize => self.handle_getStatis(_p, _r, _seqid).await,
                73usize => self.handle_signInFTService(_p, _r, _seqid).await,
                74usize => self.handle_signOutFTService(_p, _r, _seqid).await,
                75usize => self.handle_listFTClients(_p, _r, _seqid).await,
                76usize => self.handle_createSession(_p, _r, _seqid).await,
                77usize => self.handle_updateSessions(_p, _r, _seqid).await,
                78usize => self.handle_listSessions(_p, _r, _seqid).await,
                79usize => self.handle_getSession(_p, _r, _seqid).await,
                80usize => self.handle_removeSession(_p, _r, _seqid).await,
                81usize => self.handle_reportTaskFinish(_p, _r, _seqid).await,
                bad => panic!(
                    "{}: unexpected method idx {}",
                    "MetaServiceProcessor",
                    bad
                ),
            }
        }
    }

    #[::async_trait::async_trait]
    impl<P, H, R> ::fbthrift::ThriftService<P::Frame> for MetaServiceProcessor<P, H, R>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Deserializer: ::std::marker::Send,
        P::Frame: ::std::marker::Send + 'static,
        H: MetaService,
        R: ::fbthrift::RequestContext<Name = ::const_cstr::ConstCStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack + ::std::marker::Send + ::std::marker::Sync + 'static
    {
        type Handler = H;
        type RequestContext = R;

        async fn call(
            &self,
            req: ::fbthrift::ProtocolDecoded<P>,
            req_ctxt: &R,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::{BufExt as _, ProtocolReader as _, ServiceProcessor as _};
            let mut p = P::deserializer(req);
            let (idx, mty, seqid) = p.read_message_begin(|name| self.method_idx(name))?;
            if mty != ::fbthrift::MessageType::Call {
                return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::InvalidMessageType,
                    format!("message type {:?} not handled", mty)
                )));
            }
            let idx = match idx {
                ::std::result::Result::Ok(idx) => idx,
                ::std::result::Result::Err(_) => {
                    let cur = P::into_buffer(p).reset();
                    return self.supa.call(cur, req_ctxt).await;
                }
            };
            let res = self.handle_method(idx, &mut p, req_ctxt, seqid).await;
            p.read_message_end()?;
            match res {
                ::std::result::Result::Ok(bytes) => ::std::result::Result::Ok(bytes),
                ::std::result::Result::Err(err) => match err.downcast_ref::<::fbthrift::ProtocolError>() {
                    ::std::option::Option::Some(::fbthrift::ProtocolError::ApplicationException(ae)) => {
                        let res = ::fbthrift::serialize!(P, |p| {
                            ::fbthrift::protocol::write_message(
                                p,
                                "MetaServiceProcessor",
                                ::fbthrift::MessageType::Exception,
                                seqid,
                                |p| ::fbthrift::Serialize::write(&ae, p),
                            )
                        });
                        ::std::result::Result::Ok(res)
                    }
                    _ => ::std::result::Result::Err(err),
                },
            }
        }
    }

    pub fn make_MetaService_server<F, H, R>(
        proto: ::fbthrift::ProtocolID,
        handler: H,
    ) -> ::std::result::Result<::std::boxed::Box<dyn ::fbthrift::ThriftService<F, Handler = H, RequestContext = R> + ::std::marker::Send + 'static>, ::fbthrift::ApplicationException>
    where
        F: ::fbthrift::Framing + ::std::marker::Send + ::std::marker::Sync + 'static,
        H: MetaService,
        R: ::fbthrift::RequestContext<Name = ::const_cstr::ConstCStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack + ::std::marker::Send + ::std::marker::Sync + 'static
    {
        match proto {
            ::fbthrift::ProtocolID::BinaryProtocol => {
                ::std::result::Result::Ok(::std::boxed::Box::new(MetaServiceProcessor::<::fbthrift::BinaryProtocol<F>, H, R>::new(handler)))
            }
            ::fbthrift::ProtocolID::CompactProtocol => {
                ::std::result::Result::Ok(::std::boxed::Box::new(MetaServiceProcessor::<::fbthrift::CompactProtocol<F>, H, R>::new(handler)))
            }
            bad => ::std::result::Result::Err(::fbthrift::ApplicationException::invalid_protocol(bad)),
        }
    }
}

/// Client mocks. For every service, a struct mock::TheService that implements
/// client::TheService.
///
/// As an example of the generated API, for the following thrift service:
///
/// ```thrift
/// service MyService {
///     FunctionResponse myFunction(
///         1: FunctionRequest request,
///     ) throws {
///         1: StorageException s,
///         2: NotFoundException n,
///     ),
///
///     // other functions
/// }
/// ```
///
/// we would end up with this mock object under crate::mock::MyService:
///
/// ```
/// # const _: &str = stringify! {
/// impl crate::client::MyService for MyService<'mock> {...}
///
/// pub struct MyService<'mock> {
///     pub myFunction: myFunction<'mock>,
///     // ...
/// }
///
/// impl dyn crate::client::MyService {
///     pub fn mock<'mock>() -> MyService<'mock>;
/// }
///
/// impl myFunction<'mock> {
///     // directly return the given success response
///     pub fn ret(&self, value: FunctionResponse);
///
///     // invoke closure to compute success response
///     pub fn mock(
///         &self,
///         mock: impl FnMut(FunctionRequest) -> FunctionResponse + Send + Sync + 'mock,
///     );
///
///     // invoke closure to compute response
///     pub fn mock_result(
///         &self,
///         mock: impl FnMut(FunctionRequest) -> Result<FunctionResponse, crate::services::MyService::MyFunctionExn> + Send + Sync + 'mock,
///     );
///
///     // return one of the function's declared exceptions
///     pub fn throw<E>(&self, exception: E)
///     where
///         E: Clone + Into<crate::services::MyService::MyFunctionExn> + Send + Sync + 'mock;
/// }
///
/// impl From<StorageException> for MyFunctionExn {...}
/// impl From<NotFoundException> for MyFunctionExn {...}
/// # };
/// ```
///
/// The intended usage from a test would be:
///
/// ```
/// # const _: &str = stringify! {
/// use std::sync::Arc;
/// use thrift_if::client::MyService;
///
/// #[test]
/// fn test_my_client() {
///     let mock = Arc::new(MyService::mock());
///
///     // directly return a success response
///     let resp = FunctionResponse {...};
///     mock.myFunction.ret(resp);
///
///     // or give a closure to compute the success response
///     mock.myFunction.mock(|request| FunctionResponse {...});
///
///     // or throw one of the function's exceptions
///     mock.myFunction.throw(StorageException::ItFailed);
///
///     // or compute a Result (useful if your exceptions aren't Clone)
///     mock.myFunction.mock_result(|request| Err(...));
///
///     let out = do_the_thing(mock).wait().unwrap();
///     assert!(out.what_i_expected());
/// }
///
/// fn do_the_thing(
///     client: Arc<dyn MyService + Send + Sync + 'static>,
/// ) -> impl Future<Item = Out> {...}
/// # };
/// ```
pub mod mock {
    pub struct MetaService<'mock> {
        pub createSpace: r#impl::meta_service::createSpace<'mock>,
        pub dropSpace: r#impl::meta_service::dropSpace<'mock>,
        pub getSpace: r#impl::meta_service::getSpace<'mock>,
        pub listSpaces: r#impl::meta_service::listSpaces<'mock>,
        pub createTag: r#impl::meta_service::createTag<'mock>,
        pub alterTag: r#impl::meta_service::alterTag<'mock>,
        pub dropTag: r#impl::meta_service::dropTag<'mock>,
        pub getTag: r#impl::meta_service::getTag<'mock>,
        pub listTags: r#impl::meta_service::listTags<'mock>,
        pub createEdge: r#impl::meta_service::createEdge<'mock>,
        pub alterEdge: r#impl::meta_service::alterEdge<'mock>,
        pub dropEdge: r#impl::meta_service::dropEdge<'mock>,
        pub getEdge: r#impl::meta_service::getEdge<'mock>,
        pub listEdges: r#impl::meta_service::listEdges<'mock>,
        pub listHosts: r#impl::meta_service::listHosts<'mock>,
        pub getPartsAlloc: r#impl::meta_service::getPartsAlloc<'mock>,
        pub listParts: r#impl::meta_service::listParts<'mock>,
        pub multiPut: r#impl::meta_service::multiPut<'mock>,
        pub get: r#impl::meta_service::get<'mock>,
        pub multiGet: r#impl::meta_service::multiGet<'mock>,
        pub remove: r#impl::meta_service::remove<'mock>,
        pub removeRange: r#impl::meta_service::removeRange<'mock>,
        pub scan: r#impl::meta_service::scan<'mock>,
        pub createTagIndex: r#impl::meta_service::createTagIndex<'mock>,
        pub dropTagIndex: r#impl::meta_service::dropTagIndex<'mock>,
        pub getTagIndex: r#impl::meta_service::getTagIndex<'mock>,
        pub listTagIndexes: r#impl::meta_service::listTagIndexes<'mock>,
        pub rebuildTagIndex: r#impl::meta_service::rebuildTagIndex<'mock>,
        pub listTagIndexStatus: r#impl::meta_service::listTagIndexStatus<'mock>,
        pub createEdgeIndex: r#impl::meta_service::createEdgeIndex<'mock>,
        pub dropEdgeIndex: r#impl::meta_service::dropEdgeIndex<'mock>,
        pub getEdgeIndex: r#impl::meta_service::getEdgeIndex<'mock>,
        pub listEdgeIndexes: r#impl::meta_service::listEdgeIndexes<'mock>,
        pub rebuildEdgeIndex: r#impl::meta_service::rebuildEdgeIndex<'mock>,
        pub listEdgeIndexStatus: r#impl::meta_service::listEdgeIndexStatus<'mock>,
        pub createUser: r#impl::meta_service::createUser<'mock>,
        pub dropUser: r#impl::meta_service::dropUser<'mock>,
        pub alterUser: r#impl::meta_service::alterUser<'mock>,
        pub grantRole: r#impl::meta_service::grantRole<'mock>,
        pub revokeRole: r#impl::meta_service::revokeRole<'mock>,
        pub listUsers: r#impl::meta_service::listUsers<'mock>,
        pub listRoles: r#impl::meta_service::listRoles<'mock>,
        pub getUserRoles: r#impl::meta_service::getUserRoles<'mock>,
        pub changePassword: r#impl::meta_service::changePassword<'mock>,
        pub heartBeat: r#impl::meta_service::heartBeat<'mock>,
        pub balance: r#impl::meta_service::balance<'mock>,
        pub leaderBalance: r#impl::meta_service::leaderBalance<'mock>,
        pub regConfig: r#impl::meta_service::regConfig<'mock>,
        pub getConfig: r#impl::meta_service::getConfig<'mock>,
        pub setConfig: r#impl::meta_service::setConfig<'mock>,
        pub listConfigs: r#impl::meta_service::listConfigs<'mock>,
        pub createSnapshot: r#impl::meta_service::createSnapshot<'mock>,
        pub dropSnapshot: r#impl::meta_service::dropSnapshot<'mock>,
        pub listSnapshots: r#impl::meta_service::listSnapshots<'mock>,
        pub runAdminJob: r#impl::meta_service::runAdminJob<'mock>,
        pub addZone: r#impl::meta_service::addZone<'mock>,
        pub dropZone: r#impl::meta_service::dropZone<'mock>,
        pub addHostIntoZone: r#impl::meta_service::addHostIntoZone<'mock>,
        pub dropHostFromZone: r#impl::meta_service::dropHostFromZone<'mock>,
        pub getZone: r#impl::meta_service::getZone<'mock>,
        pub listZones: r#impl::meta_service::listZones<'mock>,
        pub addGroup: r#impl::meta_service::addGroup<'mock>,
        pub dropGroup: r#impl::meta_service::dropGroup<'mock>,
        pub addZoneIntoGroup: r#impl::meta_service::addZoneIntoGroup<'mock>,
        pub dropZoneFromGroup: r#impl::meta_service::dropZoneFromGroup<'mock>,
        pub getGroup: r#impl::meta_service::getGroup<'mock>,
        pub listGroups: r#impl::meta_service::listGroups<'mock>,
        pub createBackup: r#impl::meta_service::createBackup<'mock>,
        pub restoreMeta: r#impl::meta_service::restoreMeta<'mock>,
        pub addListener: r#impl::meta_service::addListener<'mock>,
        pub removeListener: r#impl::meta_service::removeListener<'mock>,
        pub listListener: r#impl::meta_service::listListener<'mock>,
        pub getStatis: r#impl::meta_service::getStatis<'mock>,
        pub signInFTService: r#impl::meta_service::signInFTService<'mock>,
        pub signOutFTService: r#impl::meta_service::signOutFTService<'mock>,
        pub listFTClients: r#impl::meta_service::listFTClients<'mock>,
        pub createSession: r#impl::meta_service::createSession<'mock>,
        pub updateSessions: r#impl::meta_service::updateSessions<'mock>,
        pub listSessions: r#impl::meta_service::listSessions<'mock>,
        pub getSession: r#impl::meta_service::getSession<'mock>,
        pub removeSession: r#impl::meta_service::removeSession<'mock>,
        pub reportTaskFinish: r#impl::meta_service::reportTaskFinish<'mock>,
        _marker: ::std::marker::PhantomData<&'mock ()>,
    }

    impl dyn super::client::MetaService {
        pub fn mock<'mock>() -> MetaService<'mock> {
            MetaService {
                createSpace: r#impl::meta_service::createSpace::unimplemented(),
                dropSpace: r#impl::meta_service::dropSpace::unimplemented(),
                getSpace: r#impl::meta_service::getSpace::unimplemented(),
                listSpaces: r#impl::meta_service::listSpaces::unimplemented(),
                createTag: r#impl::meta_service::createTag::unimplemented(),
                alterTag: r#impl::meta_service::alterTag::unimplemented(),
                dropTag: r#impl::meta_service::dropTag::unimplemented(),
                getTag: r#impl::meta_service::getTag::unimplemented(),
                listTags: r#impl::meta_service::listTags::unimplemented(),
                createEdge: r#impl::meta_service::createEdge::unimplemented(),
                alterEdge: r#impl::meta_service::alterEdge::unimplemented(),
                dropEdge: r#impl::meta_service::dropEdge::unimplemented(),
                getEdge: r#impl::meta_service::getEdge::unimplemented(),
                listEdges: r#impl::meta_service::listEdges::unimplemented(),
                listHosts: r#impl::meta_service::listHosts::unimplemented(),
                getPartsAlloc: r#impl::meta_service::getPartsAlloc::unimplemented(),
                listParts: r#impl::meta_service::listParts::unimplemented(),
                multiPut: r#impl::meta_service::multiPut::unimplemented(),
                get: r#impl::meta_service::get::unimplemented(),
                multiGet: r#impl::meta_service::multiGet::unimplemented(),
                remove: r#impl::meta_service::remove::unimplemented(),
                removeRange: r#impl::meta_service::removeRange::unimplemented(),
                scan: r#impl::meta_service::scan::unimplemented(),
                createTagIndex: r#impl::meta_service::createTagIndex::unimplemented(),
                dropTagIndex: r#impl::meta_service::dropTagIndex::unimplemented(),
                getTagIndex: r#impl::meta_service::getTagIndex::unimplemented(),
                listTagIndexes: r#impl::meta_service::listTagIndexes::unimplemented(),
                rebuildTagIndex: r#impl::meta_service::rebuildTagIndex::unimplemented(),
                listTagIndexStatus: r#impl::meta_service::listTagIndexStatus::unimplemented(),
                createEdgeIndex: r#impl::meta_service::createEdgeIndex::unimplemented(),
                dropEdgeIndex: r#impl::meta_service::dropEdgeIndex::unimplemented(),
                getEdgeIndex: r#impl::meta_service::getEdgeIndex::unimplemented(),
                listEdgeIndexes: r#impl::meta_service::listEdgeIndexes::unimplemented(),
                rebuildEdgeIndex: r#impl::meta_service::rebuildEdgeIndex::unimplemented(),
                listEdgeIndexStatus: r#impl::meta_service::listEdgeIndexStatus::unimplemented(),
                createUser: r#impl::meta_service::createUser::unimplemented(),
                dropUser: r#impl::meta_service::dropUser::unimplemented(),
                alterUser: r#impl::meta_service::alterUser::unimplemented(),
                grantRole: r#impl::meta_service::grantRole::unimplemented(),
                revokeRole: r#impl::meta_service::revokeRole::unimplemented(),
                listUsers: r#impl::meta_service::listUsers::unimplemented(),
                listRoles: r#impl::meta_service::listRoles::unimplemented(),
                getUserRoles: r#impl::meta_service::getUserRoles::unimplemented(),
                changePassword: r#impl::meta_service::changePassword::unimplemented(),
                heartBeat: r#impl::meta_service::heartBeat::unimplemented(),
                balance: r#impl::meta_service::balance::unimplemented(),
                leaderBalance: r#impl::meta_service::leaderBalance::unimplemented(),
                regConfig: r#impl::meta_service::regConfig::unimplemented(),
                getConfig: r#impl::meta_service::getConfig::unimplemented(),
                setConfig: r#impl::meta_service::setConfig::unimplemented(),
                listConfigs: r#impl::meta_service::listConfigs::unimplemented(),
                createSnapshot: r#impl::meta_service::createSnapshot::unimplemented(),
                dropSnapshot: r#impl::meta_service::dropSnapshot::unimplemented(),
                listSnapshots: r#impl::meta_service::listSnapshots::unimplemented(),
                runAdminJob: r#impl::meta_service::runAdminJob::unimplemented(),
                addZone: r#impl::meta_service::addZone::unimplemented(),
                dropZone: r#impl::meta_service::dropZone::unimplemented(),
                addHostIntoZone: r#impl::meta_service::addHostIntoZone::unimplemented(),
                dropHostFromZone: r#impl::meta_service::dropHostFromZone::unimplemented(),
                getZone: r#impl::meta_service::getZone::unimplemented(),
                listZones: r#impl::meta_service::listZones::unimplemented(),
                addGroup: r#impl::meta_service::addGroup::unimplemented(),
                dropGroup: r#impl::meta_service::dropGroup::unimplemented(),
                addZoneIntoGroup: r#impl::meta_service::addZoneIntoGroup::unimplemented(),
                dropZoneFromGroup: r#impl::meta_service::dropZoneFromGroup::unimplemented(),
                getGroup: r#impl::meta_service::getGroup::unimplemented(),
                listGroups: r#impl::meta_service::listGroups::unimplemented(),
                createBackup: r#impl::meta_service::createBackup::unimplemented(),
                restoreMeta: r#impl::meta_service::restoreMeta::unimplemented(),
                addListener: r#impl::meta_service::addListener::unimplemented(),
                removeListener: r#impl::meta_service::removeListener::unimplemented(),
                listListener: r#impl::meta_service::listListener::unimplemented(),
                getStatis: r#impl::meta_service::getStatis::unimplemented(),
                signInFTService: r#impl::meta_service::signInFTService::unimplemented(),
                signOutFTService: r#impl::meta_service::signOutFTService::unimplemented(),
                listFTClients: r#impl::meta_service::listFTClients::unimplemented(),
                createSession: r#impl::meta_service::createSession::unimplemented(),
                updateSessions: r#impl::meta_service::updateSessions::unimplemented(),
                listSessions: r#impl::meta_service::listSessions::unimplemented(),
                getSession: r#impl::meta_service::getSession::unimplemented(),
                removeSession: r#impl::meta_service::removeSession::unimplemented(),
                reportTaskFinish: r#impl::meta_service::reportTaskFinish::unimplemented(),
                _marker: ::std::marker::PhantomData,
            }
        }
    }

    #[::async_trait::async_trait]
    impl<'mock> super::client::MetaService for MetaService<'mock> {
        fn createSpace(
            &self,
            arg_req: &crate::types::CreateSpaceReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateSpaceError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.createSpace.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::CreateSpaceReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn dropSpace(
            &self,
            arg_req: &crate::types::DropSpaceReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropSpaceError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.dropSpace.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::DropSpaceReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn getSpace(
            &self,
            arg_req: &crate::types::GetSpaceReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetSpaceResp, crate::errors::meta_service::GetSpaceError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getSpace.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GetSpaceReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listSpaces(
            &self,
            arg_req: &crate::types::ListSpacesReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListSpacesResp, crate::errors::meta_service::ListSpacesError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.listSpaces.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ListSpacesReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn createTag(
            &self,
            arg_req: &crate::types::CreateTagReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateTagError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.createTag.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::CreateTagReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn alterTag(
            &self,
            arg_req: &crate::types::AlterTagReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterTagError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.alterTag.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::AlterTagReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn dropTag(
            &self,
            arg_req: &crate::types::DropTagReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropTagError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.dropTag.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::DropTagReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn getTag(
            &self,
            arg_req: &crate::types::GetTagReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetTagResp, crate::errors::meta_service::GetTagError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getTag.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GetTagReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listTags(
            &self,
            arg_req: &crate::types::ListTagsReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListTagsResp, crate::errors::meta_service::ListTagsError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.listTags.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ListTagsReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn createEdge(
            &self,
            arg_req: &crate::types::CreateEdgeReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateEdgeError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.createEdge.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::CreateEdgeReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn alterEdge(
            &self,
            arg_req: &crate::types::AlterEdgeReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterEdgeError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.alterEdge.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::AlterEdgeReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn dropEdge(
            &self,
            arg_req: &crate::types::DropEdgeReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropEdgeError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.dropEdge.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::DropEdgeReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn getEdge(
            &self,
            arg_req: &crate::types::GetEdgeReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetEdgeResp, crate::errors::meta_service::GetEdgeError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getEdge.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GetEdgeReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listEdges(
            &self,
            arg_req: &crate::types::ListEdgesReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListEdgesResp, crate::errors::meta_service::ListEdgesError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.listEdges.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ListEdgesReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listHosts(
            &self,
            arg_req: &crate::types::ListHostsReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListHostsResp, crate::errors::meta_service::ListHostsError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.listHosts.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ListHostsReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn getPartsAlloc(
            &self,
            arg_req: &crate::types::GetPartsAllocReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetPartsAllocResp, crate::errors::meta_service::GetPartsAllocError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getPartsAlloc.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GetPartsAllocReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listParts(
            &self,
            arg_req: &crate::types::ListPartsReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListPartsResp, crate::errors::meta_service::ListPartsError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.listParts.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ListPartsReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn multiPut(
            &self,
            arg_req: &crate::types::MultiPutReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::MultiPutError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.multiPut.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::MultiPutReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn get(
            &self,
            arg_req: &crate::types::GetReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetResp, crate::errors::meta_service::GetError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.get.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GetReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn multiGet(
            &self,
            arg_req: &crate::types::MultiGetReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::MultiGetResp, crate::errors::meta_service::MultiGetError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.multiGet.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::MultiGetReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn remove(
            &self,
            arg_req: &crate::types::RemoveReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.remove.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::RemoveReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn removeRange(
            &self,
            arg_req: &crate::types::RemoveRangeReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveRangeError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.removeRange.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::RemoveRangeReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn scan(
            &self,
            arg_req: &crate::types::ScanReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ScanResp, crate::errors::meta_service::ScanError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.scan.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ScanReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn createTagIndex(
            &self,
            arg_req: &crate::types::CreateTagIndexReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateTagIndexError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.createTagIndex.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::CreateTagIndexReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn dropTagIndex(
            &self,
            arg_req: &crate::types::DropTagIndexReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropTagIndexError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.dropTagIndex.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::DropTagIndexReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn getTagIndex(
            &self,
            arg_req: &crate::types::GetTagIndexReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetTagIndexResp, crate::errors::meta_service::GetTagIndexError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getTagIndex.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GetTagIndexReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listTagIndexes(
            &self,
            arg_req: &crate::types::ListTagIndexesReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListTagIndexesResp, crate::errors::meta_service::ListTagIndexesError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.listTagIndexes.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ListTagIndexesReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn rebuildTagIndex(
            &self,
            arg_req: &crate::types::RebuildIndexReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RebuildTagIndexError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.rebuildTagIndex.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::RebuildIndexReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listTagIndexStatus(
            &self,
            arg_req: &crate::types::ListIndexStatusReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListIndexStatusResp, crate::errors::meta_service::ListTagIndexStatusError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.listTagIndexStatus.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ListIndexStatusReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn createEdgeIndex(
            &self,
            arg_req: &crate::types::CreateEdgeIndexReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateEdgeIndexError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.createEdgeIndex.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::CreateEdgeIndexReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn dropEdgeIndex(
            &self,
            arg_req: &crate::types::DropEdgeIndexReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropEdgeIndexError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.dropEdgeIndex.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::DropEdgeIndexReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn getEdgeIndex(
            &self,
            arg_req: &crate::types::GetEdgeIndexReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetEdgeIndexResp, crate::errors::meta_service::GetEdgeIndexError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getEdgeIndex.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GetEdgeIndexReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listEdgeIndexes(
            &self,
            arg_req: &crate::types::ListEdgeIndexesReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListEdgeIndexesResp, crate::errors::meta_service::ListEdgeIndexesError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.listEdgeIndexes.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ListEdgeIndexesReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn rebuildEdgeIndex(
            &self,
            arg_req: &crate::types::RebuildIndexReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RebuildEdgeIndexError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.rebuildEdgeIndex.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::RebuildIndexReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listEdgeIndexStatus(
            &self,
            arg_req: &crate::types::ListIndexStatusReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListIndexStatusResp, crate::errors::meta_service::ListEdgeIndexStatusError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.listEdgeIndexStatus.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ListIndexStatusReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn createUser(
            &self,
            arg_req: &crate::types::CreateUserReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateUserError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.createUser.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::CreateUserReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn dropUser(
            &self,
            arg_req: &crate::types::DropUserReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropUserError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.dropUser.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::DropUserReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn alterUser(
            &self,
            arg_req: &crate::types::AlterUserReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterUserError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.alterUser.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::AlterUserReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn grantRole(
            &self,
            arg_req: &crate::types::GrantRoleReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::GrantRoleError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.grantRole.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GrantRoleReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn revokeRole(
            &self,
            arg_req: &crate::types::RevokeRoleReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RevokeRoleError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.revokeRole.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::RevokeRoleReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listUsers(
            &self,
            arg_req: &crate::types::ListUsersReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListUsersResp, crate::errors::meta_service::ListUsersError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.listUsers.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ListUsersReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listRoles(
            &self,
            arg_req: &crate::types::ListRolesReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListRolesResp, crate::errors::meta_service::ListRolesError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.listRoles.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ListRolesReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn getUserRoles(
            &self,
            arg_req: &crate::types::GetUserRolesReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListRolesResp, crate::errors::meta_service::GetUserRolesError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getUserRoles.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GetUserRolesReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn changePassword(
            &self,
            arg_req: &crate::types::ChangePasswordReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::ChangePasswordError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.changePassword.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ChangePasswordReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn heartBeat(
            &self,
            arg_req: &crate::types::HBReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::HBResp, crate::errors::meta_service::HeartBeatError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.heartBeat.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::HBReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn balance(
            &self,
            arg_req: &crate::types::BalanceReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::BalanceResp, crate::errors::meta_service::BalanceError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.balance.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::BalanceReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn leaderBalance(
            &self,
            arg_req: &crate::types::LeaderBalanceReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::LeaderBalanceError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.leaderBalance.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::LeaderBalanceReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn regConfig(
            &self,
            arg_req: &crate::types::RegConfigReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RegConfigError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.regConfig.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::RegConfigReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn getConfig(
            &self,
            arg_req: &crate::types::GetConfigReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetConfigResp, crate::errors::meta_service::GetConfigError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getConfig.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GetConfigReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn setConfig(
            &self,
            arg_req: &crate::types::SetConfigReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::SetConfigError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.setConfig.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::SetConfigReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listConfigs(
            &self,
            arg_req: &crate::types::ListConfigsReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListConfigsResp, crate::errors::meta_service::ListConfigsError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.listConfigs.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ListConfigsReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn createSnapshot(
            &self,
            arg_req: &crate::types::CreateSnapshotReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateSnapshotError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.createSnapshot.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::CreateSnapshotReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn dropSnapshot(
            &self,
            arg_req: &crate::types::DropSnapshotReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropSnapshotError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.dropSnapshot.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::DropSnapshotReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listSnapshots(
            &self,
            arg_req: &crate::types::ListSnapshotsReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListSnapshotsResp, crate::errors::meta_service::ListSnapshotsError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.listSnapshots.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ListSnapshotsReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn runAdminJob(
            &self,
            arg_req: &crate::types::AdminJobReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminJobResp, crate::errors::meta_service::RunAdminJobError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.runAdminJob.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::AdminJobReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn addZone(
            &self,
            arg_req: &crate::types::AddZoneReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddZoneError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.addZone.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::AddZoneReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn dropZone(
            &self,
            arg_req: &crate::types::DropZoneReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropZoneError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.dropZone.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::DropZoneReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn addHostIntoZone(
            &self,
            arg_req: &crate::types::AddHostIntoZoneReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddHostIntoZoneError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.addHostIntoZone.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::AddHostIntoZoneReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn dropHostFromZone(
            &self,
            arg_req: &crate::types::DropHostFromZoneReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropHostFromZoneError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.dropHostFromZone.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::DropHostFromZoneReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn getZone(
            &self,
            arg_req: &crate::types::GetZoneReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetZoneResp, crate::errors::meta_service::GetZoneError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getZone.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GetZoneReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listZones(
            &self,
            arg_req: &crate::types::ListZonesReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListZonesResp, crate::errors::meta_service::ListZonesError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.listZones.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ListZonesReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn addGroup(
            &self,
            arg_req: &crate::types::AddGroupReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddGroupError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.addGroup.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::AddGroupReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn dropGroup(
            &self,
            arg_req: &crate::types::DropGroupReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropGroupError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.dropGroup.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::DropGroupReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn addZoneIntoGroup(
            &self,
            arg_req: &crate::types::AddZoneIntoGroupReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddZoneIntoGroupError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.addZoneIntoGroup.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::AddZoneIntoGroupReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn dropZoneFromGroup(
            &self,
            arg_req: &crate::types::DropZoneFromGroupReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropZoneFromGroupError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.dropZoneFromGroup.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::DropZoneFromGroupReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn getGroup(
            &self,
            arg_req: &crate::types::GetGroupReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetGroupResp, crate::errors::meta_service::GetGroupError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getGroup.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GetGroupReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listGroups(
            &self,
            arg_req: &crate::types::ListGroupsReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListGroupsResp, crate::errors::meta_service::ListGroupsError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.listGroups.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ListGroupsReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn createBackup(
            &self,
            arg_req: &crate::types::CreateBackupReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::CreateBackupResp, crate::errors::meta_service::CreateBackupError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.createBackup.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::CreateBackupReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn restoreMeta(
            &self,
            arg_req: &crate::types::RestoreMetaReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RestoreMetaError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.restoreMeta.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::RestoreMetaReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn addListener(
            &self,
            arg_req: &crate::types::AddListenerReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddListenerError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.addListener.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::AddListenerReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn removeListener(
            &self,
            arg_req: &crate::types::RemoveListenerReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveListenerError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.removeListener.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::RemoveListenerReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listListener(
            &self,
            arg_req: &crate::types::ListListenerReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListListenerResp, crate::errors::meta_service::ListListenerError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.listListener.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ListListenerReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn getStatis(
            &self,
            arg_req: &crate::types::GetStatisReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetStatisResp, crate::errors::meta_service::GetStatisError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getStatis.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GetStatisReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn signInFTService(
            &self,
            arg_req: &crate::types::SignInFTServiceReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::SignInFTServiceError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.signInFTService.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::SignInFTServiceReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn signOutFTService(
            &self,
            arg_req: &crate::types::SignOutFTServiceReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::SignOutFTServiceError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.signOutFTService.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::SignOutFTServiceReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listFTClients(
            &self,
            arg_req: &crate::types::ListFTClientsReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListFTClientsResp, crate::errors::meta_service::ListFTClientsError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.listFTClients.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ListFTClientsReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn createSession(
            &self,
            arg_req: &crate::types::CreateSessionReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::CreateSessionResp, crate::errors::meta_service::CreateSessionError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.createSession.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::CreateSessionReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn updateSessions(
            &self,
            arg_req: &crate::types::UpdateSessionsReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::UpdateSessionsError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.updateSessions.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::UpdateSessionsReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listSessions(
            &self,
            arg_req: &crate::types::ListSessionsReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListSessionsResp, crate::errors::meta_service::ListSessionsError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.listSessions.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ListSessionsReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn getSession(
            &self,
            arg_req: &crate::types::GetSessionReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetSessionResp, crate::errors::meta_service::GetSessionError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getSession.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GetSessionReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn removeSession(
            &self,
            arg_req: &crate::types::RemoveSessionReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveSessionError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.removeSession.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::RemoveSessionReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn reportTaskFinish(
            &self,
            arg_req: &crate::types::ReportTaskReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::ReportTaskFinishError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.reportTaskFinish.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ReportTaskReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
    }

    mod r#impl {
        pub mod meta_service {

            pub struct createSpace<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::CreateSpaceReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::CreateSpaceError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> createSpace<'mock> {
                pub fn unimplemented() -> Self {
                    createSpace {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::CreateSpaceReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "createSpace",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::CreateSpaceReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateSpaceReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateSpaceReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateSpaceError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::CreateSpaceError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::CreateSpaceReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct dropSpace<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::DropSpaceReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::DropSpaceError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> dropSpace<'mock> {
                pub fn unimplemented() -> Self {
                    dropSpace {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::DropSpaceReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "dropSpace",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::DropSpaceReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropSpaceReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropSpaceReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropSpaceError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::DropSpaceError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::DropSpaceReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getSpace<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GetSpaceReq) -> ::std::result::Result<
                        crate::types::GetSpaceResp,
                        crate::errors::meta_service::GetSpaceError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getSpace<'mock> {
                pub fn unimplemented() -> Self {
                    getSpace {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GetSpaceReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "getSpace",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::GetSpaceResp) {
                    self.mock(move |_: crate::types::GetSpaceReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetSpaceReq) -> crate::types::GetSpaceResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetSpaceReq) -> ::std::result::Result<crate::types::GetSpaceResp, crate::errors::meta_service::GetSpaceError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::GetSpaceError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GetSpaceReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listSpaces<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ListSpacesReq) -> ::std::result::Result<
                        crate::types::ListSpacesResp,
                        crate::errors::meta_service::ListSpacesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> listSpaces<'mock> {
                pub fn unimplemented() -> Self {
                    listSpaces {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ListSpacesReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listSpaces",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ListSpacesResp) {
                    self.mock(move |_: crate::types::ListSpacesReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListSpacesReq) -> crate::types::ListSpacesResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListSpacesReq) -> ::std::result::Result<crate::types::ListSpacesResp, crate::errors::meta_service::ListSpacesError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ListSpacesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ListSpacesReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct createTag<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::CreateTagReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::CreateTagError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> createTag<'mock> {
                pub fn unimplemented() -> Self {
                    createTag {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::CreateTagReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "createTag",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::CreateTagReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateTagReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateTagReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateTagError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::CreateTagError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::CreateTagReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct alterTag<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::AlterTagReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::AlterTagError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> alterTag<'mock> {
                pub fn unimplemented() -> Self {
                    alterTag {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::AlterTagReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "alterTag",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::AlterTagReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::AlterTagReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::AlterTagReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterTagError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::AlterTagError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::AlterTagReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct dropTag<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::DropTagReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::DropTagError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> dropTag<'mock> {
                pub fn unimplemented() -> Self {
                    dropTag {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::DropTagReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "dropTag",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::DropTagReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropTagReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropTagReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropTagError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::DropTagError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::DropTagReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getTag<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GetTagReq) -> ::std::result::Result<
                        crate::types::GetTagResp,
                        crate::errors::meta_service::GetTagError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getTag<'mock> {
                pub fn unimplemented() -> Self {
                    getTag {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GetTagReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "getTag",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::GetTagResp) {
                    self.mock(move |_: crate::types::GetTagReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetTagReq) -> crate::types::GetTagResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetTagReq) -> ::std::result::Result<crate::types::GetTagResp, crate::errors::meta_service::GetTagError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::GetTagError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GetTagReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listTags<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ListTagsReq) -> ::std::result::Result<
                        crate::types::ListTagsResp,
                        crate::errors::meta_service::ListTagsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> listTags<'mock> {
                pub fn unimplemented() -> Self {
                    listTags {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ListTagsReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listTags",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ListTagsResp) {
                    self.mock(move |_: crate::types::ListTagsReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListTagsReq) -> crate::types::ListTagsResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListTagsReq) -> ::std::result::Result<crate::types::ListTagsResp, crate::errors::meta_service::ListTagsError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ListTagsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ListTagsReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct createEdge<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::CreateEdgeReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::CreateEdgeError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> createEdge<'mock> {
                pub fn unimplemented() -> Self {
                    createEdge {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::CreateEdgeReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "createEdge",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::CreateEdgeReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateEdgeReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateEdgeReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateEdgeError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::CreateEdgeError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::CreateEdgeReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct alterEdge<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::AlterEdgeReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::AlterEdgeError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> alterEdge<'mock> {
                pub fn unimplemented() -> Self {
                    alterEdge {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::AlterEdgeReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "alterEdge",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::AlterEdgeReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::AlterEdgeReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::AlterEdgeReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterEdgeError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::AlterEdgeError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::AlterEdgeReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct dropEdge<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::DropEdgeReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::DropEdgeError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> dropEdge<'mock> {
                pub fn unimplemented() -> Self {
                    dropEdge {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::DropEdgeReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "dropEdge",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::DropEdgeReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropEdgeReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropEdgeReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropEdgeError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::DropEdgeError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::DropEdgeReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getEdge<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GetEdgeReq) -> ::std::result::Result<
                        crate::types::GetEdgeResp,
                        crate::errors::meta_service::GetEdgeError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getEdge<'mock> {
                pub fn unimplemented() -> Self {
                    getEdge {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GetEdgeReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "getEdge",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::GetEdgeResp) {
                    self.mock(move |_: crate::types::GetEdgeReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetEdgeReq) -> crate::types::GetEdgeResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetEdgeReq) -> ::std::result::Result<crate::types::GetEdgeResp, crate::errors::meta_service::GetEdgeError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::GetEdgeError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GetEdgeReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listEdges<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ListEdgesReq) -> ::std::result::Result<
                        crate::types::ListEdgesResp,
                        crate::errors::meta_service::ListEdgesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> listEdges<'mock> {
                pub fn unimplemented() -> Self {
                    listEdges {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ListEdgesReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listEdges",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ListEdgesResp) {
                    self.mock(move |_: crate::types::ListEdgesReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListEdgesReq) -> crate::types::ListEdgesResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListEdgesReq) -> ::std::result::Result<crate::types::ListEdgesResp, crate::errors::meta_service::ListEdgesError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ListEdgesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ListEdgesReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listHosts<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ListHostsReq) -> ::std::result::Result<
                        crate::types::ListHostsResp,
                        crate::errors::meta_service::ListHostsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> listHosts<'mock> {
                pub fn unimplemented() -> Self {
                    listHosts {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ListHostsReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listHosts",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ListHostsResp) {
                    self.mock(move |_: crate::types::ListHostsReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListHostsReq) -> crate::types::ListHostsResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListHostsReq) -> ::std::result::Result<crate::types::ListHostsResp, crate::errors::meta_service::ListHostsError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ListHostsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ListHostsReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getPartsAlloc<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GetPartsAllocReq) -> ::std::result::Result<
                        crate::types::GetPartsAllocResp,
                        crate::errors::meta_service::GetPartsAllocError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getPartsAlloc<'mock> {
                pub fn unimplemented() -> Self {
                    getPartsAlloc {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GetPartsAllocReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "getPartsAlloc",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::GetPartsAllocResp) {
                    self.mock(move |_: crate::types::GetPartsAllocReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetPartsAllocReq) -> crate::types::GetPartsAllocResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetPartsAllocReq) -> ::std::result::Result<crate::types::GetPartsAllocResp, crate::errors::meta_service::GetPartsAllocError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::GetPartsAllocError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GetPartsAllocReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listParts<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ListPartsReq) -> ::std::result::Result<
                        crate::types::ListPartsResp,
                        crate::errors::meta_service::ListPartsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> listParts<'mock> {
                pub fn unimplemented() -> Self {
                    listParts {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ListPartsReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listParts",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ListPartsResp) {
                    self.mock(move |_: crate::types::ListPartsReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListPartsReq) -> crate::types::ListPartsResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListPartsReq) -> ::std::result::Result<crate::types::ListPartsResp, crate::errors::meta_service::ListPartsError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ListPartsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ListPartsReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct multiPut<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::MultiPutReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::MultiPutError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> multiPut<'mock> {
                pub fn unimplemented() -> Self {
                    multiPut {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::MultiPutReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "multiPut",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::MultiPutReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::MultiPutReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::MultiPutReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::MultiPutError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::MultiPutError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::MultiPutReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct get<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GetReq) -> ::std::result::Result<
                        crate::types::GetResp,
                        crate::errors::meta_service::GetError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> get<'mock> {
                pub fn unimplemented() -> Self {
                    get {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GetReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "get",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::GetResp) {
                    self.mock(move |_: crate::types::GetReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetReq) -> crate::types::GetResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetReq) -> ::std::result::Result<crate::types::GetResp, crate::errors::meta_service::GetError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::GetError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GetReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct multiGet<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::MultiGetReq) -> ::std::result::Result<
                        crate::types::MultiGetResp,
                        crate::errors::meta_service::MultiGetError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> multiGet<'mock> {
                pub fn unimplemented() -> Self {
                    multiGet {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::MultiGetReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "multiGet",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::MultiGetResp) {
                    self.mock(move |_: crate::types::MultiGetReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::MultiGetReq) -> crate::types::MultiGetResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::MultiGetReq) -> ::std::result::Result<crate::types::MultiGetResp, crate::errors::meta_service::MultiGetError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::MultiGetError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::MultiGetReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct remove<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::RemoveReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::RemoveError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> remove<'mock> {
                pub fn unimplemented() -> Self {
                    remove {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::RemoveReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "remove",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::RemoveReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::RemoveReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::RemoveReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::RemoveError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::RemoveReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct removeRange<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::RemoveRangeReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::RemoveRangeError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> removeRange<'mock> {
                pub fn unimplemented() -> Self {
                    removeRange {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::RemoveRangeReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "removeRange",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::RemoveRangeReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::RemoveRangeReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::RemoveRangeReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveRangeError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::RemoveRangeError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::RemoveRangeReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct scan<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ScanReq) -> ::std::result::Result<
                        crate::types::ScanResp,
                        crate::errors::meta_service::ScanError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> scan<'mock> {
                pub fn unimplemented() -> Self {
                    scan {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ScanReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "scan",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ScanResp) {
                    self.mock(move |_: crate::types::ScanReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ScanReq) -> crate::types::ScanResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ScanReq) -> ::std::result::Result<crate::types::ScanResp, crate::errors::meta_service::ScanError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ScanError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ScanReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct createTagIndex<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::CreateTagIndexReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::CreateTagIndexError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> createTagIndex<'mock> {
                pub fn unimplemented() -> Self {
                    createTagIndex {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::CreateTagIndexReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "createTagIndex",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::CreateTagIndexReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateTagIndexReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateTagIndexReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateTagIndexError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::CreateTagIndexError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::CreateTagIndexReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct dropTagIndex<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::DropTagIndexReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::DropTagIndexError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> dropTagIndex<'mock> {
                pub fn unimplemented() -> Self {
                    dropTagIndex {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::DropTagIndexReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "dropTagIndex",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::DropTagIndexReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropTagIndexReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropTagIndexReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropTagIndexError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::DropTagIndexError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::DropTagIndexReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getTagIndex<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GetTagIndexReq) -> ::std::result::Result<
                        crate::types::GetTagIndexResp,
                        crate::errors::meta_service::GetTagIndexError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getTagIndex<'mock> {
                pub fn unimplemented() -> Self {
                    getTagIndex {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GetTagIndexReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "getTagIndex",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::GetTagIndexResp) {
                    self.mock(move |_: crate::types::GetTagIndexReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetTagIndexReq) -> crate::types::GetTagIndexResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetTagIndexReq) -> ::std::result::Result<crate::types::GetTagIndexResp, crate::errors::meta_service::GetTagIndexError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::GetTagIndexError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GetTagIndexReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listTagIndexes<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ListTagIndexesReq) -> ::std::result::Result<
                        crate::types::ListTagIndexesResp,
                        crate::errors::meta_service::ListTagIndexesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> listTagIndexes<'mock> {
                pub fn unimplemented() -> Self {
                    listTagIndexes {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ListTagIndexesReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listTagIndexes",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ListTagIndexesResp) {
                    self.mock(move |_: crate::types::ListTagIndexesReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListTagIndexesReq) -> crate::types::ListTagIndexesResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListTagIndexesReq) -> ::std::result::Result<crate::types::ListTagIndexesResp, crate::errors::meta_service::ListTagIndexesError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ListTagIndexesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ListTagIndexesReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct rebuildTagIndex<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::RebuildIndexReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::RebuildTagIndexError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> rebuildTagIndex<'mock> {
                pub fn unimplemented() -> Self {
                    rebuildTagIndex {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::RebuildIndexReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "rebuildTagIndex",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::RebuildIndexReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::RebuildIndexReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::RebuildIndexReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RebuildTagIndexError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::RebuildTagIndexError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::RebuildIndexReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listTagIndexStatus<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ListIndexStatusReq) -> ::std::result::Result<
                        crate::types::ListIndexStatusResp,
                        crate::errors::meta_service::ListTagIndexStatusError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> listTagIndexStatus<'mock> {
                pub fn unimplemented() -> Self {
                    listTagIndexStatus {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ListIndexStatusReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listTagIndexStatus",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ListIndexStatusResp) {
                    self.mock(move |_: crate::types::ListIndexStatusReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListIndexStatusReq) -> crate::types::ListIndexStatusResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListIndexStatusReq) -> ::std::result::Result<crate::types::ListIndexStatusResp, crate::errors::meta_service::ListTagIndexStatusError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ListTagIndexStatusError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ListIndexStatusReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct createEdgeIndex<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::CreateEdgeIndexReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::CreateEdgeIndexError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> createEdgeIndex<'mock> {
                pub fn unimplemented() -> Self {
                    createEdgeIndex {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::CreateEdgeIndexReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "createEdgeIndex",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::CreateEdgeIndexReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateEdgeIndexReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateEdgeIndexReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateEdgeIndexError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::CreateEdgeIndexError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::CreateEdgeIndexReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct dropEdgeIndex<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::DropEdgeIndexReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::DropEdgeIndexError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> dropEdgeIndex<'mock> {
                pub fn unimplemented() -> Self {
                    dropEdgeIndex {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::DropEdgeIndexReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "dropEdgeIndex",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::DropEdgeIndexReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropEdgeIndexReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropEdgeIndexReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropEdgeIndexError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::DropEdgeIndexError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::DropEdgeIndexReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getEdgeIndex<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GetEdgeIndexReq) -> ::std::result::Result<
                        crate::types::GetEdgeIndexResp,
                        crate::errors::meta_service::GetEdgeIndexError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getEdgeIndex<'mock> {
                pub fn unimplemented() -> Self {
                    getEdgeIndex {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GetEdgeIndexReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "getEdgeIndex",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::GetEdgeIndexResp) {
                    self.mock(move |_: crate::types::GetEdgeIndexReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetEdgeIndexReq) -> crate::types::GetEdgeIndexResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetEdgeIndexReq) -> ::std::result::Result<crate::types::GetEdgeIndexResp, crate::errors::meta_service::GetEdgeIndexError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::GetEdgeIndexError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GetEdgeIndexReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listEdgeIndexes<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ListEdgeIndexesReq) -> ::std::result::Result<
                        crate::types::ListEdgeIndexesResp,
                        crate::errors::meta_service::ListEdgeIndexesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> listEdgeIndexes<'mock> {
                pub fn unimplemented() -> Self {
                    listEdgeIndexes {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ListEdgeIndexesReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listEdgeIndexes",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ListEdgeIndexesResp) {
                    self.mock(move |_: crate::types::ListEdgeIndexesReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListEdgeIndexesReq) -> crate::types::ListEdgeIndexesResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListEdgeIndexesReq) -> ::std::result::Result<crate::types::ListEdgeIndexesResp, crate::errors::meta_service::ListEdgeIndexesError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ListEdgeIndexesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ListEdgeIndexesReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct rebuildEdgeIndex<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::RebuildIndexReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::RebuildEdgeIndexError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> rebuildEdgeIndex<'mock> {
                pub fn unimplemented() -> Self {
                    rebuildEdgeIndex {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::RebuildIndexReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "rebuildEdgeIndex",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::RebuildIndexReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::RebuildIndexReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::RebuildIndexReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RebuildEdgeIndexError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::RebuildEdgeIndexError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::RebuildIndexReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listEdgeIndexStatus<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ListIndexStatusReq) -> ::std::result::Result<
                        crate::types::ListIndexStatusResp,
                        crate::errors::meta_service::ListEdgeIndexStatusError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> listEdgeIndexStatus<'mock> {
                pub fn unimplemented() -> Self {
                    listEdgeIndexStatus {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ListIndexStatusReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listEdgeIndexStatus",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ListIndexStatusResp) {
                    self.mock(move |_: crate::types::ListIndexStatusReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListIndexStatusReq) -> crate::types::ListIndexStatusResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListIndexStatusReq) -> ::std::result::Result<crate::types::ListIndexStatusResp, crate::errors::meta_service::ListEdgeIndexStatusError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ListEdgeIndexStatusError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ListIndexStatusReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct createUser<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::CreateUserReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::CreateUserError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> createUser<'mock> {
                pub fn unimplemented() -> Self {
                    createUser {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::CreateUserReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "createUser",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::CreateUserReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateUserReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateUserReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateUserError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::CreateUserError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::CreateUserReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct dropUser<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::DropUserReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::DropUserError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> dropUser<'mock> {
                pub fn unimplemented() -> Self {
                    dropUser {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::DropUserReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "dropUser",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::DropUserReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropUserReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropUserReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropUserError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::DropUserError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::DropUserReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct alterUser<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::AlterUserReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::AlterUserError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> alterUser<'mock> {
                pub fn unimplemented() -> Self {
                    alterUser {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::AlterUserReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "alterUser",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::AlterUserReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::AlterUserReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::AlterUserReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AlterUserError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::AlterUserError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::AlterUserReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct grantRole<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GrantRoleReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::GrantRoleError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> grantRole<'mock> {
                pub fn unimplemented() -> Self {
                    grantRole {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GrantRoleReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "grantRole",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::GrantRoleReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GrantRoleReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::GrantRoleReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::GrantRoleError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::GrantRoleError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GrantRoleReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct revokeRole<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::RevokeRoleReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::RevokeRoleError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> revokeRole<'mock> {
                pub fn unimplemented() -> Self {
                    revokeRole {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::RevokeRoleReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "revokeRole",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::RevokeRoleReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::RevokeRoleReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::RevokeRoleReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RevokeRoleError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::RevokeRoleError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::RevokeRoleReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listUsers<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ListUsersReq) -> ::std::result::Result<
                        crate::types::ListUsersResp,
                        crate::errors::meta_service::ListUsersError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> listUsers<'mock> {
                pub fn unimplemented() -> Self {
                    listUsers {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ListUsersReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listUsers",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ListUsersResp) {
                    self.mock(move |_: crate::types::ListUsersReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListUsersReq) -> crate::types::ListUsersResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListUsersReq) -> ::std::result::Result<crate::types::ListUsersResp, crate::errors::meta_service::ListUsersError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ListUsersError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ListUsersReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listRoles<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ListRolesReq) -> ::std::result::Result<
                        crate::types::ListRolesResp,
                        crate::errors::meta_service::ListRolesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> listRoles<'mock> {
                pub fn unimplemented() -> Self {
                    listRoles {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ListRolesReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listRoles",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ListRolesResp) {
                    self.mock(move |_: crate::types::ListRolesReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListRolesReq) -> crate::types::ListRolesResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListRolesReq) -> ::std::result::Result<crate::types::ListRolesResp, crate::errors::meta_service::ListRolesError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ListRolesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ListRolesReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getUserRoles<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GetUserRolesReq) -> ::std::result::Result<
                        crate::types::ListRolesResp,
                        crate::errors::meta_service::GetUserRolesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getUserRoles<'mock> {
                pub fn unimplemented() -> Self {
                    getUserRoles {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GetUserRolesReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "getUserRoles",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ListRolesResp) {
                    self.mock(move |_: crate::types::GetUserRolesReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetUserRolesReq) -> crate::types::ListRolesResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetUserRolesReq) -> ::std::result::Result<crate::types::ListRolesResp, crate::errors::meta_service::GetUserRolesError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::GetUserRolesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GetUserRolesReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct changePassword<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ChangePasswordReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::ChangePasswordError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> changePassword<'mock> {
                pub fn unimplemented() -> Self {
                    changePassword {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ChangePasswordReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "changePassword",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::ChangePasswordReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ChangePasswordReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ChangePasswordReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::ChangePasswordError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ChangePasswordError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ChangePasswordReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct heartBeat<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::HBReq) -> ::std::result::Result<
                        crate::types::HBResp,
                        crate::errors::meta_service::HeartBeatError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> heartBeat<'mock> {
                pub fn unimplemented() -> Self {
                    heartBeat {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::HBReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "heartBeat",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::HBResp) {
                    self.mock(move |_: crate::types::HBReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::HBReq) -> crate::types::HBResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::HBReq) -> ::std::result::Result<crate::types::HBResp, crate::errors::meta_service::HeartBeatError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::HeartBeatError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::HBReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct balance<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::BalanceReq) -> ::std::result::Result<
                        crate::types::BalanceResp,
                        crate::errors::meta_service::BalanceError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> balance<'mock> {
                pub fn unimplemented() -> Self {
                    balance {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::BalanceReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "balance",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::BalanceResp) {
                    self.mock(move |_: crate::types::BalanceReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::BalanceReq) -> crate::types::BalanceResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::BalanceReq) -> ::std::result::Result<crate::types::BalanceResp, crate::errors::meta_service::BalanceError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::BalanceError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::BalanceReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct leaderBalance<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::LeaderBalanceReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::LeaderBalanceError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> leaderBalance<'mock> {
                pub fn unimplemented() -> Self {
                    leaderBalance {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::LeaderBalanceReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "leaderBalance",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::LeaderBalanceReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::LeaderBalanceReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::LeaderBalanceReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::LeaderBalanceError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::LeaderBalanceError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::LeaderBalanceReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct regConfig<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::RegConfigReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::RegConfigError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> regConfig<'mock> {
                pub fn unimplemented() -> Self {
                    regConfig {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::RegConfigReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "regConfig",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::RegConfigReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::RegConfigReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::RegConfigReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RegConfigError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::RegConfigError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::RegConfigReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getConfig<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GetConfigReq) -> ::std::result::Result<
                        crate::types::GetConfigResp,
                        crate::errors::meta_service::GetConfigError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getConfig<'mock> {
                pub fn unimplemented() -> Self {
                    getConfig {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GetConfigReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "getConfig",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::GetConfigResp) {
                    self.mock(move |_: crate::types::GetConfigReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetConfigReq) -> crate::types::GetConfigResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetConfigReq) -> ::std::result::Result<crate::types::GetConfigResp, crate::errors::meta_service::GetConfigError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::GetConfigError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GetConfigReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct setConfig<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::SetConfigReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::SetConfigError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> setConfig<'mock> {
                pub fn unimplemented() -> Self {
                    setConfig {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::SetConfigReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "setConfig",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::SetConfigReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::SetConfigReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::SetConfigReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::SetConfigError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::SetConfigError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::SetConfigReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listConfigs<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ListConfigsReq) -> ::std::result::Result<
                        crate::types::ListConfigsResp,
                        crate::errors::meta_service::ListConfigsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> listConfigs<'mock> {
                pub fn unimplemented() -> Self {
                    listConfigs {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ListConfigsReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listConfigs",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ListConfigsResp) {
                    self.mock(move |_: crate::types::ListConfigsReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListConfigsReq) -> crate::types::ListConfigsResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListConfigsReq) -> ::std::result::Result<crate::types::ListConfigsResp, crate::errors::meta_service::ListConfigsError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ListConfigsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ListConfigsReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct createSnapshot<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::CreateSnapshotReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::CreateSnapshotError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> createSnapshot<'mock> {
                pub fn unimplemented() -> Self {
                    createSnapshot {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::CreateSnapshotReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "createSnapshot",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::CreateSnapshotReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateSnapshotReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateSnapshotReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::CreateSnapshotError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::CreateSnapshotError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::CreateSnapshotReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct dropSnapshot<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::DropSnapshotReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::DropSnapshotError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> dropSnapshot<'mock> {
                pub fn unimplemented() -> Self {
                    dropSnapshot {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::DropSnapshotReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "dropSnapshot",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::DropSnapshotReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropSnapshotReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropSnapshotReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropSnapshotError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::DropSnapshotError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::DropSnapshotReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listSnapshots<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ListSnapshotsReq) -> ::std::result::Result<
                        crate::types::ListSnapshotsResp,
                        crate::errors::meta_service::ListSnapshotsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> listSnapshots<'mock> {
                pub fn unimplemented() -> Self {
                    listSnapshots {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ListSnapshotsReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listSnapshots",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ListSnapshotsResp) {
                    self.mock(move |_: crate::types::ListSnapshotsReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListSnapshotsReq) -> crate::types::ListSnapshotsResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListSnapshotsReq) -> ::std::result::Result<crate::types::ListSnapshotsResp, crate::errors::meta_service::ListSnapshotsError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ListSnapshotsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ListSnapshotsReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct runAdminJob<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::AdminJobReq) -> ::std::result::Result<
                        crate::types::AdminJobResp,
                        crate::errors::meta_service::RunAdminJobError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> runAdminJob<'mock> {
                pub fn unimplemented() -> Self {
                    runAdminJob {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::AdminJobReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "runAdminJob",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::AdminJobResp) {
                    self.mock(move |_: crate::types::AdminJobReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::AdminJobReq) -> crate::types::AdminJobResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::AdminJobReq) -> ::std::result::Result<crate::types::AdminJobResp, crate::errors::meta_service::RunAdminJobError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::RunAdminJobError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::AdminJobReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct addZone<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::AddZoneReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::AddZoneError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> addZone<'mock> {
                pub fn unimplemented() -> Self {
                    addZone {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::AddZoneReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "addZone",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::AddZoneReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::AddZoneReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::AddZoneReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddZoneError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::AddZoneError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::AddZoneReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct dropZone<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::DropZoneReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::DropZoneError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> dropZone<'mock> {
                pub fn unimplemented() -> Self {
                    dropZone {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::DropZoneReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "dropZone",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::DropZoneReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropZoneReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropZoneReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropZoneError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::DropZoneError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::DropZoneReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct addHostIntoZone<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::AddHostIntoZoneReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::AddHostIntoZoneError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> addHostIntoZone<'mock> {
                pub fn unimplemented() -> Self {
                    addHostIntoZone {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::AddHostIntoZoneReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "addHostIntoZone",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::AddHostIntoZoneReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::AddHostIntoZoneReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::AddHostIntoZoneReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddHostIntoZoneError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::AddHostIntoZoneError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::AddHostIntoZoneReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct dropHostFromZone<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::DropHostFromZoneReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::DropHostFromZoneError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> dropHostFromZone<'mock> {
                pub fn unimplemented() -> Self {
                    dropHostFromZone {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::DropHostFromZoneReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "dropHostFromZone",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::DropHostFromZoneReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropHostFromZoneReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropHostFromZoneReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropHostFromZoneError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::DropHostFromZoneError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::DropHostFromZoneReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getZone<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GetZoneReq) -> ::std::result::Result<
                        crate::types::GetZoneResp,
                        crate::errors::meta_service::GetZoneError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getZone<'mock> {
                pub fn unimplemented() -> Self {
                    getZone {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GetZoneReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "getZone",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::GetZoneResp) {
                    self.mock(move |_: crate::types::GetZoneReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetZoneReq) -> crate::types::GetZoneResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetZoneReq) -> ::std::result::Result<crate::types::GetZoneResp, crate::errors::meta_service::GetZoneError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::GetZoneError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GetZoneReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listZones<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ListZonesReq) -> ::std::result::Result<
                        crate::types::ListZonesResp,
                        crate::errors::meta_service::ListZonesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> listZones<'mock> {
                pub fn unimplemented() -> Self {
                    listZones {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ListZonesReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listZones",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ListZonesResp) {
                    self.mock(move |_: crate::types::ListZonesReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListZonesReq) -> crate::types::ListZonesResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListZonesReq) -> ::std::result::Result<crate::types::ListZonesResp, crate::errors::meta_service::ListZonesError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ListZonesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ListZonesReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct addGroup<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::AddGroupReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::AddGroupError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> addGroup<'mock> {
                pub fn unimplemented() -> Self {
                    addGroup {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::AddGroupReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "addGroup",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::AddGroupReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::AddGroupReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::AddGroupReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddGroupError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::AddGroupError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::AddGroupReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct dropGroup<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::DropGroupReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::DropGroupError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> dropGroup<'mock> {
                pub fn unimplemented() -> Self {
                    dropGroup {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::DropGroupReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "dropGroup",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::DropGroupReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropGroupReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropGroupReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropGroupError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::DropGroupError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::DropGroupReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct addZoneIntoGroup<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::AddZoneIntoGroupReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::AddZoneIntoGroupError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> addZoneIntoGroup<'mock> {
                pub fn unimplemented() -> Self {
                    addZoneIntoGroup {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::AddZoneIntoGroupReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "addZoneIntoGroup",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::AddZoneIntoGroupReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::AddZoneIntoGroupReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::AddZoneIntoGroupReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddZoneIntoGroupError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::AddZoneIntoGroupError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::AddZoneIntoGroupReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct dropZoneFromGroup<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::DropZoneFromGroupReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::DropZoneFromGroupError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> dropZoneFromGroup<'mock> {
                pub fn unimplemented() -> Self {
                    dropZoneFromGroup {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::DropZoneFromGroupReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "dropZoneFromGroup",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::DropZoneFromGroupReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropZoneFromGroupReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropZoneFromGroupReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::DropZoneFromGroupError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::DropZoneFromGroupError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::DropZoneFromGroupReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getGroup<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GetGroupReq) -> ::std::result::Result<
                        crate::types::GetGroupResp,
                        crate::errors::meta_service::GetGroupError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getGroup<'mock> {
                pub fn unimplemented() -> Self {
                    getGroup {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GetGroupReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "getGroup",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::GetGroupResp) {
                    self.mock(move |_: crate::types::GetGroupReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetGroupReq) -> crate::types::GetGroupResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetGroupReq) -> ::std::result::Result<crate::types::GetGroupResp, crate::errors::meta_service::GetGroupError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::GetGroupError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GetGroupReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listGroups<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ListGroupsReq) -> ::std::result::Result<
                        crate::types::ListGroupsResp,
                        crate::errors::meta_service::ListGroupsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> listGroups<'mock> {
                pub fn unimplemented() -> Self {
                    listGroups {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ListGroupsReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listGroups",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ListGroupsResp) {
                    self.mock(move |_: crate::types::ListGroupsReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListGroupsReq) -> crate::types::ListGroupsResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListGroupsReq) -> ::std::result::Result<crate::types::ListGroupsResp, crate::errors::meta_service::ListGroupsError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ListGroupsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ListGroupsReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct createBackup<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::CreateBackupReq) -> ::std::result::Result<
                        crate::types::CreateBackupResp,
                        crate::errors::meta_service::CreateBackupError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> createBackup<'mock> {
                pub fn unimplemented() -> Self {
                    createBackup {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::CreateBackupReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "createBackup",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::CreateBackupResp) {
                    self.mock(move |_: crate::types::CreateBackupReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateBackupReq) -> crate::types::CreateBackupResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateBackupReq) -> ::std::result::Result<crate::types::CreateBackupResp, crate::errors::meta_service::CreateBackupError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::CreateBackupError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::CreateBackupReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct restoreMeta<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::RestoreMetaReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::RestoreMetaError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> restoreMeta<'mock> {
                pub fn unimplemented() -> Self {
                    restoreMeta {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::RestoreMetaReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "restoreMeta",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::RestoreMetaReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::RestoreMetaReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::RestoreMetaReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RestoreMetaError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::RestoreMetaError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::RestoreMetaReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct addListener<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::AddListenerReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::AddListenerError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> addListener<'mock> {
                pub fn unimplemented() -> Self {
                    addListener {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::AddListenerReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "addListener",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::AddListenerReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::AddListenerReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::AddListenerReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::AddListenerError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::AddListenerError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::AddListenerReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct removeListener<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::RemoveListenerReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::RemoveListenerError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> removeListener<'mock> {
                pub fn unimplemented() -> Self {
                    removeListener {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::RemoveListenerReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "removeListener",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::RemoveListenerReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::RemoveListenerReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::RemoveListenerReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveListenerError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::RemoveListenerError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::RemoveListenerReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listListener<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ListListenerReq) -> ::std::result::Result<
                        crate::types::ListListenerResp,
                        crate::errors::meta_service::ListListenerError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> listListener<'mock> {
                pub fn unimplemented() -> Self {
                    listListener {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ListListenerReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listListener",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ListListenerResp) {
                    self.mock(move |_: crate::types::ListListenerReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListListenerReq) -> crate::types::ListListenerResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListListenerReq) -> ::std::result::Result<crate::types::ListListenerResp, crate::errors::meta_service::ListListenerError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ListListenerError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ListListenerReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getStatis<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GetStatisReq) -> ::std::result::Result<
                        crate::types::GetStatisResp,
                        crate::errors::meta_service::GetStatisError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getStatis<'mock> {
                pub fn unimplemented() -> Self {
                    getStatis {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GetStatisReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "getStatis",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::GetStatisResp) {
                    self.mock(move |_: crate::types::GetStatisReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetStatisReq) -> crate::types::GetStatisResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetStatisReq) -> ::std::result::Result<crate::types::GetStatisResp, crate::errors::meta_service::GetStatisError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::GetStatisError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GetStatisReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct signInFTService<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::SignInFTServiceReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::SignInFTServiceError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> signInFTService<'mock> {
                pub fn unimplemented() -> Self {
                    signInFTService {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::SignInFTServiceReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "signInFTService",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::SignInFTServiceReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::SignInFTServiceReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::SignInFTServiceReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::SignInFTServiceError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::SignInFTServiceError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::SignInFTServiceReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct signOutFTService<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::SignOutFTServiceReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::SignOutFTServiceError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> signOutFTService<'mock> {
                pub fn unimplemented() -> Self {
                    signOutFTService {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::SignOutFTServiceReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "signOutFTService",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::SignOutFTServiceReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::SignOutFTServiceReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::SignOutFTServiceReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::SignOutFTServiceError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::SignOutFTServiceError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::SignOutFTServiceReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listFTClients<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ListFTClientsReq) -> ::std::result::Result<
                        crate::types::ListFTClientsResp,
                        crate::errors::meta_service::ListFTClientsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> listFTClients<'mock> {
                pub fn unimplemented() -> Self {
                    listFTClients {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ListFTClientsReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listFTClients",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ListFTClientsResp) {
                    self.mock(move |_: crate::types::ListFTClientsReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListFTClientsReq) -> crate::types::ListFTClientsResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListFTClientsReq) -> ::std::result::Result<crate::types::ListFTClientsResp, crate::errors::meta_service::ListFTClientsError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ListFTClientsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ListFTClientsReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct createSession<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::CreateSessionReq) -> ::std::result::Result<
                        crate::types::CreateSessionResp,
                        crate::errors::meta_service::CreateSessionError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> createSession<'mock> {
                pub fn unimplemented() -> Self {
                    createSession {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::CreateSessionReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "createSession",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::CreateSessionResp) {
                    self.mock(move |_: crate::types::CreateSessionReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateSessionReq) -> crate::types::CreateSessionResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateSessionReq) -> ::std::result::Result<crate::types::CreateSessionResp, crate::errors::meta_service::CreateSessionError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::CreateSessionError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::CreateSessionReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct updateSessions<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::UpdateSessionsReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::UpdateSessionsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> updateSessions<'mock> {
                pub fn unimplemented() -> Self {
                    updateSessions {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::UpdateSessionsReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "updateSessions",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::UpdateSessionsReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::UpdateSessionsReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::UpdateSessionsReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::UpdateSessionsError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::UpdateSessionsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::UpdateSessionsReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listSessions<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ListSessionsReq) -> ::std::result::Result<
                        crate::types::ListSessionsResp,
                        crate::errors::meta_service::ListSessionsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> listSessions<'mock> {
                pub fn unimplemented() -> Self {
                    listSessions {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ListSessionsReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listSessions",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ListSessionsResp) {
                    self.mock(move |_: crate::types::ListSessionsReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListSessionsReq) -> crate::types::ListSessionsResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListSessionsReq) -> ::std::result::Result<crate::types::ListSessionsResp, crate::errors::meta_service::ListSessionsError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ListSessionsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ListSessionsReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getSession<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GetSessionReq) -> ::std::result::Result<
                        crate::types::GetSessionResp,
                        crate::errors::meta_service::GetSessionError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getSession<'mock> {
                pub fn unimplemented() -> Self {
                    getSession {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GetSessionReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "getSession",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::GetSessionResp) {
                    self.mock(move |_: crate::types::GetSessionReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetSessionReq) -> crate::types::GetSessionResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetSessionReq) -> ::std::result::Result<crate::types::GetSessionResp, crate::errors::meta_service::GetSessionError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::GetSessionError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GetSessionReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct removeSession<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::RemoveSessionReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::RemoveSessionError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> removeSession<'mock> {
                pub fn unimplemented() -> Self {
                    removeSession {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::RemoveSessionReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "removeSession",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::RemoveSessionReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::RemoveSessionReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::RemoveSessionReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::RemoveSessionError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::RemoveSessionError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::RemoveSessionReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct reportTaskFinish<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ReportTaskReq) -> ::std::result::Result<
                        crate::types::ExecResp,
                        crate::errors::meta_service::ReportTaskFinishError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> reportTaskFinish<'mock> {
                pub fn unimplemented() -> Self {
                    reportTaskFinish {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ReportTaskReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "reportTaskFinish",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResp) {
                    self.mock(move |_: crate::types::ReportTaskReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ReportTaskReq) -> crate::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ReportTaskReq) -> ::std::result::Result<crate::types::ExecResp, crate::errors::meta_service::ReportTaskFinishError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::meta_service::ReportTaskFinishError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ReportTaskReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }
        }
    }
}

pub mod errors {
    pub mod meta_service {

        pub type CreateSpaceError = ::fbthrift::NonthrowingFunctionError;

        pub type DropSpaceError = ::fbthrift::NonthrowingFunctionError;

        pub type GetSpaceError = ::fbthrift::NonthrowingFunctionError;

        pub type ListSpacesError = ::fbthrift::NonthrowingFunctionError;

        pub type CreateTagError = ::fbthrift::NonthrowingFunctionError;

        pub type AlterTagError = ::fbthrift::NonthrowingFunctionError;

        pub type DropTagError = ::fbthrift::NonthrowingFunctionError;

        pub type GetTagError = ::fbthrift::NonthrowingFunctionError;

        pub type ListTagsError = ::fbthrift::NonthrowingFunctionError;

        pub type CreateEdgeError = ::fbthrift::NonthrowingFunctionError;

        pub type AlterEdgeError = ::fbthrift::NonthrowingFunctionError;

        pub type DropEdgeError = ::fbthrift::NonthrowingFunctionError;

        pub type GetEdgeError = ::fbthrift::NonthrowingFunctionError;

        pub type ListEdgesError = ::fbthrift::NonthrowingFunctionError;

        pub type ListHostsError = ::fbthrift::NonthrowingFunctionError;

        pub type GetPartsAllocError = ::fbthrift::NonthrowingFunctionError;

        pub type ListPartsError = ::fbthrift::NonthrowingFunctionError;

        pub type MultiPutError = ::fbthrift::NonthrowingFunctionError;

        pub type GetError = ::fbthrift::NonthrowingFunctionError;

        pub type MultiGetError = ::fbthrift::NonthrowingFunctionError;

        pub type RemoveError = ::fbthrift::NonthrowingFunctionError;

        pub type RemoveRangeError = ::fbthrift::NonthrowingFunctionError;

        pub type ScanError = ::fbthrift::NonthrowingFunctionError;

        pub type CreateTagIndexError = ::fbthrift::NonthrowingFunctionError;

        pub type DropTagIndexError = ::fbthrift::NonthrowingFunctionError;

        pub type GetTagIndexError = ::fbthrift::NonthrowingFunctionError;

        pub type ListTagIndexesError = ::fbthrift::NonthrowingFunctionError;

        pub type RebuildTagIndexError = ::fbthrift::NonthrowingFunctionError;

        pub type ListTagIndexStatusError = ::fbthrift::NonthrowingFunctionError;

        pub type CreateEdgeIndexError = ::fbthrift::NonthrowingFunctionError;

        pub type DropEdgeIndexError = ::fbthrift::NonthrowingFunctionError;

        pub type GetEdgeIndexError = ::fbthrift::NonthrowingFunctionError;

        pub type ListEdgeIndexesError = ::fbthrift::NonthrowingFunctionError;

        pub type RebuildEdgeIndexError = ::fbthrift::NonthrowingFunctionError;

        pub type ListEdgeIndexStatusError = ::fbthrift::NonthrowingFunctionError;

        pub type CreateUserError = ::fbthrift::NonthrowingFunctionError;

        pub type DropUserError = ::fbthrift::NonthrowingFunctionError;

        pub type AlterUserError = ::fbthrift::NonthrowingFunctionError;

        pub type GrantRoleError = ::fbthrift::NonthrowingFunctionError;

        pub type RevokeRoleError = ::fbthrift::NonthrowingFunctionError;

        pub type ListUsersError = ::fbthrift::NonthrowingFunctionError;

        pub type ListRolesError = ::fbthrift::NonthrowingFunctionError;

        pub type GetUserRolesError = ::fbthrift::NonthrowingFunctionError;

        pub type ChangePasswordError = ::fbthrift::NonthrowingFunctionError;

        pub type HeartBeatError = ::fbthrift::NonthrowingFunctionError;

        pub type BalanceError = ::fbthrift::NonthrowingFunctionError;

        pub type LeaderBalanceError = ::fbthrift::NonthrowingFunctionError;

        pub type RegConfigError = ::fbthrift::NonthrowingFunctionError;

        pub type GetConfigError = ::fbthrift::NonthrowingFunctionError;

        pub type SetConfigError = ::fbthrift::NonthrowingFunctionError;

        pub type ListConfigsError = ::fbthrift::NonthrowingFunctionError;

        pub type CreateSnapshotError = ::fbthrift::NonthrowingFunctionError;

        pub type DropSnapshotError = ::fbthrift::NonthrowingFunctionError;

        pub type ListSnapshotsError = ::fbthrift::NonthrowingFunctionError;

        pub type RunAdminJobError = ::fbthrift::NonthrowingFunctionError;

        pub type AddZoneError = ::fbthrift::NonthrowingFunctionError;

        pub type DropZoneError = ::fbthrift::NonthrowingFunctionError;

        pub type AddHostIntoZoneError = ::fbthrift::NonthrowingFunctionError;

        pub type DropHostFromZoneError = ::fbthrift::NonthrowingFunctionError;

        pub type GetZoneError = ::fbthrift::NonthrowingFunctionError;

        pub type ListZonesError = ::fbthrift::NonthrowingFunctionError;

        pub type AddGroupError = ::fbthrift::NonthrowingFunctionError;

        pub type DropGroupError = ::fbthrift::NonthrowingFunctionError;

        pub type AddZoneIntoGroupError = ::fbthrift::NonthrowingFunctionError;

        pub type DropZoneFromGroupError = ::fbthrift::NonthrowingFunctionError;

        pub type GetGroupError = ::fbthrift::NonthrowingFunctionError;

        pub type ListGroupsError = ::fbthrift::NonthrowingFunctionError;

        pub type CreateBackupError = ::fbthrift::NonthrowingFunctionError;

        pub type RestoreMetaError = ::fbthrift::NonthrowingFunctionError;

        pub type AddListenerError = ::fbthrift::NonthrowingFunctionError;

        pub type RemoveListenerError = ::fbthrift::NonthrowingFunctionError;

        pub type ListListenerError = ::fbthrift::NonthrowingFunctionError;

        pub type GetStatisError = ::fbthrift::NonthrowingFunctionError;

        pub type SignInFTServiceError = ::fbthrift::NonthrowingFunctionError;

        pub type SignOutFTServiceError = ::fbthrift::NonthrowingFunctionError;

        pub type ListFTClientsError = ::fbthrift::NonthrowingFunctionError;

        pub type CreateSessionError = ::fbthrift::NonthrowingFunctionError;

        pub type UpdateSessionsError = ::fbthrift::NonthrowingFunctionError;

        pub type ListSessionsError = ::fbthrift::NonthrowingFunctionError;

        pub type GetSessionError = ::fbthrift::NonthrowingFunctionError;

        pub type RemoveSessionError = ::fbthrift::NonthrowingFunctionError;

        pub type ReportTaskFinishError = ::fbthrift::NonthrowingFunctionError;

    }

}
