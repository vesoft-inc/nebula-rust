// @generated by Thrift. This file is probably not the place you want to edit!

#![recursion_limit = "100000000"]
#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals, unused_crate_dependencies)]

pub use self::errors::*;
pub use self::types::*;

pub mod types {
    #![allow(clippy::redundant_closure)]


    pub type GraphSpaceID = ::std::primitive::i32;

    pub type PartitionID = ::std::primitive::i32;

    pub type TagID = ::std::primitive::i32;

    pub type EdgeType = ::std::primitive::i32;

    pub type EdgeRanking = ::std::primitive::i64;

    pub type LogID = ::std::primitive::i64;

    pub type TermID = ::std::primitive::i64;

    pub type Timestamp = ::std::primitive::i64;

    pub type IndexID = ::std::primitive::i32;

    pub type Port = ::std::primitive::i32;

    pub type SessionID = ::std::primitive::i64;

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct Date {
        pub year: ::std::primitive::i16,
        pub month: ::std::primitive::i8,
        pub day: ::std::primitive::i8,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct Time {
        pub hour: ::std::primitive::i8,
        pub minute: ::std::primitive::i8,
        pub sec: ::std::primitive::i8,
        pub microsec: ::std::primitive::i32,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct DateTime {
        pub year: ::std::primitive::i16,
        pub month: ::std::primitive::i8,
        pub day: ::std::primitive::i8,
        pub hour: ::std::primitive::i8,
        pub minute: ::std::primitive::i8,
        pub sec: ::std::primitive::i8,
        pub microsec: ::std::primitive::i32,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub enum Value {
        nVal(crate::types::NullType),
        bVal(::std::primitive::bool),
        iVal(::std::primitive::i64),
        fVal(::std::primitive::f64),
        sVal(::std::vec::Vec<::std::primitive::u8>),
        dVal(crate::types::Date),
        tVal(crate::types::Time),
        dtVal(crate::types::DateTime),
        vVal(crate::types::Vertex),
        eVal(crate::types::Edge),
        pVal(crate::types::Path),
        lVal(crate::types::NList),
        mVal(crate::types::NMap),
        uVal(crate::types::NSet),
        gVal(crate::types::DataSet),
        UnknownField(::std::primitive::i32),
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct NList {
        pub values: ::std::vec::Vec<crate::types::Value>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct NMap {
        pub kvs: ::std::collections::BTreeMap<::std::vec::Vec<::std::primitive::u8>, crate::types::Value>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct NSet {
        pub values: ::std::collections::BTreeSet<crate::types::Value>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct Row {
        pub values: ::std::vec::Vec<crate::types::Value>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct DataSet {
        pub column_names: ::std::vec::Vec<::std::vec::Vec<::std::primitive::u8>>,
        pub rows: ::std::vec::Vec<crate::types::Row>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct Tag {
        pub name: ::std::vec::Vec<::std::primitive::u8>,
        pub props: ::std::collections::BTreeMap<::std::vec::Vec<::std::primitive::u8>, crate::types::Value>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct Vertex {
        pub vid: crate::types::Value,
        pub tags: ::std::vec::Vec<crate::types::Tag>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct Edge {
        pub src: crate::types::Value,
        pub dst: crate::types::Value,
        pub type_: crate::types::EdgeType,
        pub name: ::std::vec::Vec<::std::primitive::u8>,
        pub ranking: crate::types::EdgeRanking,
        pub props: ::std::collections::BTreeMap<::std::vec::Vec<::std::primitive::u8>, crate::types::Value>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct Step {
        pub dst: crate::types::Vertex,
        pub type_: crate::types::EdgeType,
        pub name: ::std::vec::Vec<::std::primitive::u8>,
        pub ranking: crate::types::EdgeRanking,
        pub props: ::std::collections::BTreeMap<::std::vec::Vec<::std::primitive::u8>, crate::types::Value>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct Path {
        pub src: crate::types::Vertex,
        pub steps: ::std::vec::Vec<crate::types::Step>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct HostAddr {
        pub host: ::std::string::String,
        pub port: crate::types::Port,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct KeyValue {
        pub key: ::std::vec::Vec<::std::primitive::u8>,
        pub value: ::std::vec::Vec<::std::primitive::u8>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct LogInfo {
        pub log_id: crate::types::LogID,
        pub term_id: crate::types::TermID,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct PartitionBackupInfo {
        pub info: ::std::collections::BTreeMap<crate::types::PartitionID, crate::types::LogInfo>,
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    pub struct NullType(pub ::std::primitive::i32);

    impl NullType {
        pub const __NULL__: Self = NullType(0i32);
        pub const NaN: Self = NullType(1i32);
        pub const BAD_DATA: Self = NullType(2i32);
        pub const BAD_TYPE: Self = NullType(3i32);
        pub const ERR_OVERFLOW: Self = NullType(4i32);
        pub const UNKNOWN_PROP: Self = NullType(5i32);
        pub const DIV_BY_ZERO: Self = NullType(6i32);
        pub const OUT_OF_RANGE: Self = NullType(7i32);
    }

    impl ::fbthrift::ThriftEnum for NullType {
        fn enumerate() -> &'static [(NullType, &'static str)] {
            &[
                (NullType::__NULL__, "__NULL__"),
                (NullType::NaN, "NaN"),
                (NullType::BAD_DATA, "BAD_DATA"),
                (NullType::BAD_TYPE, "BAD_TYPE"),
                (NullType::ERR_OVERFLOW, "ERR_OVERFLOW"),
                (NullType::UNKNOWN_PROP, "UNKNOWN_PROP"),
                (NullType::DIV_BY_ZERO, "DIV_BY_ZERO"),
                (NullType::OUT_OF_RANGE, "OUT_OF_RANGE"),
            ]
        }

        fn variants() -> &'static [&'static str] {
            &[
                "__NULL__",
                "NaN",
                "BAD_DATA",
                "BAD_TYPE",
                "ERR_OVERFLOW",
                "UNKNOWN_PROP",
                "DIV_BY_ZERO",
                "OUT_OF_RANGE",
            ]
        }

        fn variant_values() -> &'static [NullType] {
            &[
                NullType::__NULL__,
                NullType::NaN,
                NullType::BAD_DATA,
                NullType::BAD_TYPE,
                NullType::ERR_OVERFLOW,
                NullType::UNKNOWN_PROP,
                NullType::DIV_BY_ZERO,
                NullType::OUT_OF_RANGE,
            ]
        }
    }

    impl ::std::default::Default for NullType {
        fn default() -> Self {
            NullType(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a NullType> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a NullType) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<NullType> for ::std::primitive::i32 {
        #[inline]
        fn from(x: NullType) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for NullType {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for NullType {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("__NULL__", 0),
                ("NaN", 1),
                ("BAD_DATA", 2),
                ("BAD_TYPE", 3),
                ("ERR_OVERFLOW", 4),
                ("UNKNOWN_PROP", 5),
                ("DIV_BY_ZERO", 6),
                ("OUT_OF_RANGE", 7),
            ];
            ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
        }
    }

    impl ::std::fmt::Debug for NullType {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "NullType::{}", self)
        }
    }

    impl ::std::str::FromStr for NullType {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("BAD_DATA", 2),
                ("BAD_TYPE", 3),
                ("DIV_BY_ZERO", 6),
                ("ERR_OVERFLOW", 4),
                ("NaN", 1),
                ("OUT_OF_RANGE", 7),
                ("UNKNOWN_PROP", 5),
                ("__NULL__", 0),
            ];
            ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "NullType").map(NullType)
        }
    }

    impl ::fbthrift::GetTType for NullType {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for NullType
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for NullType
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(NullType::from(p.read_i32()?))
        }
    }












    impl ::std::default::Default for self::Date {
        fn default() -> Self {
            Self {
                year: ::std::default::Default::default(),
                month: ::std::default::Default::default(),
                day: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::Date {}
    unsafe impl ::std::marker::Sync for self::Date {}

    impl ::fbthrift::GetTType for self::Date {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::Date
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("Date");
            p.write_field_begin("year", ::fbthrift::TType::I16, 1);
            ::fbthrift::Serialize::write(&self.year, p);
            p.write_field_end();
            p.write_field_begin("month", ::fbthrift::TType::Byte, 2);
            ::fbthrift::Serialize::write(&self.month, p);
            p.write_field_end();
            p.write_field_begin("day", ::fbthrift::TType::Byte, 3);
            ::fbthrift::Serialize::write(&self.day, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::Date
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("day", ::fbthrift::TType::Byte, 3),
                ::fbthrift::Field::new("month", ::fbthrift::TType::Byte, 2),
                ::fbthrift::Field::new("year", ::fbthrift::TType::I16, 1),
            ];
            let mut field_year = ::std::option::Option::None;
            let mut field_month = ::std::option::Option::None;
            let mut field_day = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I16, 1) => field_year = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Byte, 2) => field_month = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Byte, 3) => field_day = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                year: field_year.unwrap_or_default(),
                month: field_month.unwrap_or_default(),
                day: field_day.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::Time {
        fn default() -> Self {
            Self {
                hour: ::std::default::Default::default(),
                minute: ::std::default::Default::default(),
                sec: ::std::default::Default::default(),
                microsec: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::Time {}
    unsafe impl ::std::marker::Sync for self::Time {}

    impl ::fbthrift::GetTType for self::Time {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::Time
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("Time");
            p.write_field_begin("hour", ::fbthrift::TType::Byte, 1);
            ::fbthrift::Serialize::write(&self.hour, p);
            p.write_field_end();
            p.write_field_begin("minute", ::fbthrift::TType::Byte, 2);
            ::fbthrift::Serialize::write(&self.minute, p);
            p.write_field_end();
            p.write_field_begin("sec", ::fbthrift::TType::Byte, 3);
            ::fbthrift::Serialize::write(&self.sec, p);
            p.write_field_end();
            p.write_field_begin("microsec", ::fbthrift::TType::I32, 4);
            ::fbthrift::Serialize::write(&self.microsec, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::Time
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("hour", ::fbthrift::TType::Byte, 1),
                ::fbthrift::Field::new("microsec", ::fbthrift::TType::I32, 4),
                ::fbthrift::Field::new("minute", ::fbthrift::TType::Byte, 2),
                ::fbthrift::Field::new("sec", ::fbthrift::TType::Byte, 3),
            ];
            let mut field_hour = ::std::option::Option::None;
            let mut field_minute = ::std::option::Option::None;
            let mut field_sec = ::std::option::Option::None;
            let mut field_microsec = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Byte, 1) => field_hour = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Byte, 2) => field_minute = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Byte, 3) => field_sec = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 4) => field_microsec = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                hour: field_hour.unwrap_or_default(),
                minute: field_minute.unwrap_or_default(),
                sec: field_sec.unwrap_or_default(),
                microsec: field_microsec.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::DateTime {
        fn default() -> Self {
            Self {
                year: ::std::default::Default::default(),
                month: ::std::default::Default::default(),
                day: ::std::default::Default::default(),
                hour: ::std::default::Default::default(),
                minute: ::std::default::Default::default(),
                sec: ::std::default::Default::default(),
                microsec: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::DateTime {}
    unsafe impl ::std::marker::Sync for self::DateTime {}

    impl ::fbthrift::GetTType for self::DateTime {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::DateTime
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("DateTime");
            p.write_field_begin("year", ::fbthrift::TType::I16, 1);
            ::fbthrift::Serialize::write(&self.year, p);
            p.write_field_end();
            p.write_field_begin("month", ::fbthrift::TType::Byte, 2);
            ::fbthrift::Serialize::write(&self.month, p);
            p.write_field_end();
            p.write_field_begin("day", ::fbthrift::TType::Byte, 3);
            ::fbthrift::Serialize::write(&self.day, p);
            p.write_field_end();
            p.write_field_begin("hour", ::fbthrift::TType::Byte, 4);
            ::fbthrift::Serialize::write(&self.hour, p);
            p.write_field_end();
            p.write_field_begin("minute", ::fbthrift::TType::Byte, 5);
            ::fbthrift::Serialize::write(&self.minute, p);
            p.write_field_end();
            p.write_field_begin("sec", ::fbthrift::TType::Byte, 6);
            ::fbthrift::Serialize::write(&self.sec, p);
            p.write_field_end();
            p.write_field_begin("microsec", ::fbthrift::TType::I32, 7);
            ::fbthrift::Serialize::write(&self.microsec, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::DateTime
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("day", ::fbthrift::TType::Byte, 3),
                ::fbthrift::Field::new("hour", ::fbthrift::TType::Byte, 4),
                ::fbthrift::Field::new("microsec", ::fbthrift::TType::I32, 7),
                ::fbthrift::Field::new("minute", ::fbthrift::TType::Byte, 5),
                ::fbthrift::Field::new("month", ::fbthrift::TType::Byte, 2),
                ::fbthrift::Field::new("sec", ::fbthrift::TType::Byte, 6),
                ::fbthrift::Field::new("year", ::fbthrift::TType::I16, 1),
            ];
            let mut field_year = ::std::option::Option::None;
            let mut field_month = ::std::option::Option::None;
            let mut field_day = ::std::option::Option::None;
            let mut field_hour = ::std::option::Option::None;
            let mut field_minute = ::std::option::Option::None;
            let mut field_sec = ::std::option::Option::None;
            let mut field_microsec = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I16, 1) => field_year = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Byte, 2) => field_month = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Byte, 3) => field_day = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Byte, 4) => field_hour = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Byte, 5) => field_minute = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Byte, 6) => field_sec = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 7) => field_microsec = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                year: field_year.unwrap_or_default(),
                month: field_month.unwrap_or_default(),
                day: field_day.unwrap_or_default(),
                hour: field_hour.unwrap_or_default(),
                minute: field_minute.unwrap_or_default(),
                sec: field_sec.unwrap_or_default(),
                microsec: field_microsec.unwrap_or_default(),
            })
        }
    }



    impl ::std::default::Default for Value {
        fn default() -> Self {
            Self::UnknownField(-1)
        }
    }

    impl ::fbthrift::GetTType for Value {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for Value
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("Value");
            match self {
                Value::nVal(inner) => {
                    p.write_field_begin("nVal", ::fbthrift::TType::I32, 1);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                Value::bVal(inner) => {
                    p.write_field_begin("bVal", ::fbthrift::TType::Bool, 2);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                Value::iVal(inner) => {
                    p.write_field_begin("iVal", ::fbthrift::TType::I64, 3);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                Value::fVal(inner) => {
                    p.write_field_begin("fVal", ::fbthrift::TType::Double, 4);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                Value::sVal(inner) => {
                    p.write_field_begin("sVal", ::fbthrift::TType::String, 5);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                Value::dVal(inner) => {
                    p.write_field_begin("dVal", ::fbthrift::TType::Struct, 6);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                Value::tVal(inner) => {
                    p.write_field_begin("tVal", ::fbthrift::TType::Struct, 7);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                Value::dtVal(inner) => {
                    p.write_field_begin("dtVal", ::fbthrift::TType::Struct, 8);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                Value::vVal(inner) => {
                    p.write_field_begin("vVal", ::fbthrift::TType::Struct, 9);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                Value::eVal(inner) => {
                    p.write_field_begin("eVal", ::fbthrift::TType::Struct, 10);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                Value::pVal(inner) => {
                    p.write_field_begin("pVal", ::fbthrift::TType::Struct, 11);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                Value::lVal(inner) => {
                    p.write_field_begin("lVal", ::fbthrift::TType::Struct, 12);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                Value::mVal(inner) => {
                    p.write_field_begin("mVal", ::fbthrift::TType::Struct, 13);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                Value::uVal(inner) => {
                    p.write_field_begin("uVal", ::fbthrift::TType::Struct, 14);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                Value::gVal(inner) => {
                    p.write_field_begin("gVal", ::fbthrift::TType::Struct, 15);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                Value::UnknownField(x) => {
                    p.write_field_begin("UnknownField", ::fbthrift::TType::I32, *x as ::std::primitive::i16);
                    x.write(p);
                    p.write_field_end();
                }
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for Value
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("bVal", ::fbthrift::TType::Bool, 2),
                ::fbthrift::Field::new("dVal", ::fbthrift::TType::Struct, 6),
                ::fbthrift::Field::new("dtVal", ::fbthrift::TType::Struct, 8),
                ::fbthrift::Field::new("eVal", ::fbthrift::TType::Struct, 10),
                ::fbthrift::Field::new("fVal", ::fbthrift::TType::Double, 4),
                ::fbthrift::Field::new("gVal", ::fbthrift::TType::Struct, 15),
                ::fbthrift::Field::new("iVal", ::fbthrift::TType::I64, 3),
                ::fbthrift::Field::new("lVal", ::fbthrift::TType::Struct, 12),
                ::fbthrift::Field::new("mVal", ::fbthrift::TType::Struct, 13),
                ::fbthrift::Field::new("nVal", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("pVal", ::fbthrift::TType::Struct, 11),
                ::fbthrift::Field::new("sVal", ::fbthrift::TType::String, 5),
                ::fbthrift::Field::new("tVal", ::fbthrift::TType::Struct, 7),
                ::fbthrift::Field::new("uVal", ::fbthrift::TType::Struct, 14),
                ::fbthrift::Field::new("vVal", ::fbthrift::TType::Struct, 9),
            ];
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::option::Option::None;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32, once) {
                    (::fbthrift::TType::Stop, _, _) => break,
                    (::fbthrift::TType::I32, 1, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(Value::nVal(::fbthrift::Deserialize::read(p)?));
                    }
                    (::fbthrift::TType::Bool, 2, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(Value::bVal(::fbthrift::Deserialize::read(p)?));
                    }
                    (::fbthrift::TType::I64, 3, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(Value::iVal(::fbthrift::Deserialize::read(p)?));
                    }
                    (::fbthrift::TType::Double, 4, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(Value::fVal(::fbthrift::Deserialize::read(p)?));
                    }
                    (::fbthrift::TType::String, 5, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(Value::sVal(::fbthrift::Deserialize::read(p)?));
                    }
                    (::fbthrift::TType::Struct, 6, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(Value::dVal(::fbthrift::Deserialize::read(p)?));
                    }
                    (::fbthrift::TType::Struct, 7, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(Value::tVal(::fbthrift::Deserialize::read(p)?));
                    }
                    (::fbthrift::TType::Struct, 8, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(Value::dtVal(::fbthrift::Deserialize::read(p)?));
                    }
                    (::fbthrift::TType::Struct, 9, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(Value::vVal(::fbthrift::Deserialize::read(p)?));
                    }
                    (::fbthrift::TType::Struct, 10, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(Value::eVal(::fbthrift::Deserialize::read(p)?));
                    }
                    (::fbthrift::TType::Struct, 11, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(Value::pVal(::fbthrift::Deserialize::read(p)?));
                    }
                    (::fbthrift::TType::Struct, 12, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(Value::lVal(::fbthrift::Deserialize::read(p)?));
                    }
                    (::fbthrift::TType::Struct, 13, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(Value::mVal(::fbthrift::Deserialize::read(p)?));
                    }
                    (::fbthrift::TType::Struct, 14, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(Value::uVal(::fbthrift::Deserialize::read(p)?));
                    }
                    (::fbthrift::TType::Struct, 15, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(Value::gVal(::fbthrift::Deserialize::read(p)?));
                    }
                    (fty, _, false) => p.skip(fty)?,
                    (badty, badid, true) => return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                        format!(
                            "unwanted extra union {} field ty {:?} id {}",
                            "Value",
                            badty,
                            badid,
                        ),
                    ))),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(alt.unwrap_or_default())
        }
    }

    impl ::std::default::Default for self::NList {
        fn default() -> Self {
            Self {
                values: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::NList {}
    unsafe impl ::std::marker::Sync for self::NList {}

    impl ::fbthrift::GetTType for self::NList {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::NList
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("NList");
            p.write_field_begin("values", ::fbthrift::TType::List, 1);
            ::fbthrift::Serialize::write(&self.values, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::NList
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("values", ::fbthrift::TType::List, 1),
            ];
            let mut field_values = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::List, 1) => field_values = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                values: field_values.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::NMap {
        fn default() -> Self {
            Self {
                kvs: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::NMap {}
    unsafe impl ::std::marker::Sync for self::NMap {}

    impl ::fbthrift::GetTType for self::NMap {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::NMap
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("NMap");
            p.write_field_begin("kvs", ::fbthrift::TType::Map, 1);
            ::fbthrift::Serialize::write(&self.kvs, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::NMap
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("kvs", ::fbthrift::TType::Map, 1),
            ];
            let mut field_kvs = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Map, 1) => field_kvs = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                kvs: field_kvs.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::NSet {
        fn default() -> Self {
            Self {
                values: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::NSet {}
    unsafe impl ::std::marker::Sync for self::NSet {}

    impl ::fbthrift::GetTType for self::NSet {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::NSet
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("NSet");
            p.write_field_begin("values", ::fbthrift::TType::Set, 1);
            ::fbthrift::Serialize::write(&self.values, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::NSet
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("values", ::fbthrift::TType::Set, 1),
            ];
            let mut field_values = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Set, 1) => field_values = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                values: field_values.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::Row {
        fn default() -> Self {
            Self {
                values: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::Row {}
    unsafe impl ::std::marker::Sync for self::Row {}

    impl ::fbthrift::GetTType for self::Row {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::Row
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("Row");
            p.write_field_begin("values", ::fbthrift::TType::List, 1);
            ::fbthrift::Serialize::write(&self.values, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::Row
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("values", ::fbthrift::TType::List, 1),
            ];
            let mut field_values = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::List, 1) => field_values = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                values: field_values.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::DataSet {
        fn default() -> Self {
            Self {
                column_names: ::std::default::Default::default(),
                rows: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::DataSet {}
    unsafe impl ::std::marker::Sync for self::DataSet {}

    impl ::fbthrift::GetTType for self::DataSet {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::DataSet
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("DataSet");
            p.write_field_begin("column_names", ::fbthrift::TType::List, 1);
            ::fbthrift::Serialize::write(&self.column_names, p);
            p.write_field_end();
            p.write_field_begin("rows", ::fbthrift::TType::List, 2);
            ::fbthrift::Serialize::write(&self.rows, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::DataSet
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("column_names", ::fbthrift::TType::List, 1),
                ::fbthrift::Field::new("rows", ::fbthrift::TType::List, 2),
            ];
            let mut field_column_names = ::std::option::Option::None;
            let mut field_rows = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::List, 1) => field_column_names = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 2) => field_rows = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                column_names: field_column_names.unwrap_or_default(),
                rows: field_rows.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::Tag {
        fn default() -> Self {
            Self {
                name: ::std::default::Default::default(),
                props: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::Tag {}
    unsafe impl ::std::marker::Sync for self::Tag {}

    impl ::fbthrift::GetTType for self::Tag {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::Tag
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("Tag");
            p.write_field_begin("name", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.name, p);
            p.write_field_end();
            p.write_field_begin("props", ::fbthrift::TType::Map, 2);
            ::fbthrift::Serialize::write(&self.props, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::Tag
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("name", ::fbthrift::TType::String, 1),
                ::fbthrift::Field::new("props", ::fbthrift::TType::Map, 2),
            ];
            let mut field_name = ::std::option::Option::None;
            let mut field_props = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 2) => field_props = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                name: field_name.unwrap_or_default(),
                props: field_props.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::Vertex {
        fn default() -> Self {
            Self {
                vid: ::std::default::Default::default(),
                tags: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::Vertex {}
    unsafe impl ::std::marker::Sync for self::Vertex {}

    impl ::fbthrift::GetTType for self::Vertex {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::Vertex
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("Vertex");
            p.write_field_begin("vid", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(&self.vid, p);
            p.write_field_end();
            p.write_field_begin("tags", ::fbthrift::TType::List, 2);
            ::fbthrift::Serialize::write(&self.tags, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::Vertex
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("tags", ::fbthrift::TType::List, 2),
                ::fbthrift::Field::new("vid", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_vid = ::std::option::Option::None;
            let mut field_tags = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_vid = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 2) => field_tags = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                vid: field_vid.unwrap_or_default(),
                tags: field_tags.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::Edge {
        fn default() -> Self {
            Self {
                src: ::std::default::Default::default(),
                dst: ::std::default::Default::default(),
                type_: ::std::default::Default::default(),
                name: ::std::default::Default::default(),
                ranking: ::std::default::Default::default(),
                props: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::Edge {}
    unsafe impl ::std::marker::Sync for self::Edge {}

    impl ::fbthrift::GetTType for self::Edge {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::Edge
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("Edge");
            p.write_field_begin("src", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(&self.src, p);
            p.write_field_end();
            p.write_field_begin("dst", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.dst, p);
            p.write_field_end();
            p.write_field_begin("type", ::fbthrift::TType::I32, 3);
            ::fbthrift::Serialize::write(&self.type_, p);
            p.write_field_end();
            p.write_field_begin("name", ::fbthrift::TType::String, 4);
            ::fbthrift::Serialize::write(&self.name, p);
            p.write_field_end();
            p.write_field_begin("ranking", ::fbthrift::TType::I64, 5);
            ::fbthrift::Serialize::write(&self.ranking, p);
            p.write_field_end();
            p.write_field_begin("props", ::fbthrift::TType::Map, 6);
            ::fbthrift::Serialize::write(&self.props, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::Edge
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("dst", ::fbthrift::TType::Struct, 2),
                ::fbthrift::Field::new("name", ::fbthrift::TType::String, 4),
                ::fbthrift::Field::new("props", ::fbthrift::TType::Map, 6),
                ::fbthrift::Field::new("ranking", ::fbthrift::TType::I64, 5),
                ::fbthrift::Field::new("src", ::fbthrift::TType::Struct, 1),
                ::fbthrift::Field::new("type", ::fbthrift::TType::I32, 3),
            ];
            let mut field_src = ::std::option::Option::None;
            let mut field_dst = ::std::option::Option::None;
            let mut field_type = ::std::option::Option::None;
            let mut field_name = ::std::option::Option::None;
            let mut field_ranking = ::std::option::Option::None;
            let mut field_props = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_src = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_dst = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 3) => field_type = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 4) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 5) => field_ranking = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 6) => field_props = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                src: field_src.unwrap_or_default(),
                dst: field_dst.unwrap_or_default(),
                type_: field_type.unwrap_or_default(),
                name: field_name.unwrap_or_default(),
                ranking: field_ranking.unwrap_or_default(),
                props: field_props.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::Step {
        fn default() -> Self {
            Self {
                dst: ::std::default::Default::default(),
                type_: ::std::default::Default::default(),
                name: ::std::default::Default::default(),
                ranking: ::std::default::Default::default(),
                props: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::Step {}
    unsafe impl ::std::marker::Sync for self::Step {}

    impl ::fbthrift::GetTType for self::Step {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::Step
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("Step");
            p.write_field_begin("dst", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(&self.dst, p);
            p.write_field_end();
            p.write_field_begin("type", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.type_, p);
            p.write_field_end();
            p.write_field_begin("name", ::fbthrift::TType::String, 3);
            ::fbthrift::Serialize::write(&self.name, p);
            p.write_field_end();
            p.write_field_begin("ranking", ::fbthrift::TType::I64, 4);
            ::fbthrift::Serialize::write(&self.ranking, p);
            p.write_field_end();
            p.write_field_begin("props", ::fbthrift::TType::Map, 5);
            ::fbthrift::Serialize::write(&self.props, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::Step
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("dst", ::fbthrift::TType::Struct, 1),
                ::fbthrift::Field::new("name", ::fbthrift::TType::String, 3),
                ::fbthrift::Field::new("props", ::fbthrift::TType::Map, 5),
                ::fbthrift::Field::new("ranking", ::fbthrift::TType::I64, 4),
                ::fbthrift::Field::new("type", ::fbthrift::TType::I32, 2),
            ];
            let mut field_dst = ::std::option::Option::None;
            let mut field_type = ::std::option::Option::None;
            let mut field_name = ::std::option::Option::None;
            let mut field_ranking = ::std::option::Option::None;
            let mut field_props = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_dst = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_type = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 3) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 4) => field_ranking = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 5) => field_props = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                dst: field_dst.unwrap_or_default(),
                type_: field_type.unwrap_or_default(),
                name: field_name.unwrap_or_default(),
                ranking: field_ranking.unwrap_or_default(),
                props: field_props.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::Path {
        fn default() -> Self {
            Self {
                src: ::std::default::Default::default(),
                steps: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::Path {}
    unsafe impl ::std::marker::Sync for self::Path {}

    impl ::fbthrift::GetTType for self::Path {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::Path
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("Path");
            p.write_field_begin("src", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(&self.src, p);
            p.write_field_end();
            p.write_field_begin("steps", ::fbthrift::TType::List, 2);
            ::fbthrift::Serialize::write(&self.steps, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::Path
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("src", ::fbthrift::TType::Struct, 1),
                ::fbthrift::Field::new("steps", ::fbthrift::TType::List, 2),
            ];
            let mut field_src = ::std::option::Option::None;
            let mut field_steps = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_src = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 2) => field_steps = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                src: field_src.unwrap_or_default(),
                steps: field_steps.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::HostAddr {
        fn default() -> Self {
            Self {
                host: ::std::default::Default::default(),
                port: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::HostAddr {}
    unsafe impl ::std::marker::Sync for self::HostAddr {}

    impl ::fbthrift::GetTType for self::HostAddr {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::HostAddr
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("HostAddr");
            p.write_field_begin("host", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.host, p);
            p.write_field_end();
            p.write_field_begin("port", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.port, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::HostAddr
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("host", ::fbthrift::TType::String, 1),
                ::fbthrift::Field::new("port", ::fbthrift::TType::I32, 2),
            ];
            let mut field_host = ::std::option::Option::None;
            let mut field_port = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_host = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_port = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                host: field_host.unwrap_or_default(),
                port: field_port.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::KeyValue {
        fn default() -> Self {
            Self {
                key: ::std::default::Default::default(),
                value: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::KeyValue {}
    unsafe impl ::std::marker::Sync for self::KeyValue {}

    impl ::fbthrift::GetTType for self::KeyValue {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::KeyValue
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("KeyValue");
            p.write_field_begin("key", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.key, p);
            p.write_field_end();
            p.write_field_begin("value", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.value, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::KeyValue
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("key", ::fbthrift::TType::String, 1),
                ::fbthrift::Field::new("value", ::fbthrift::TType::String, 2),
            ];
            let mut field_key = ::std::option::Option::None;
            let mut field_value = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_key = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_value = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                key: field_key.unwrap_or_default(),
                value: field_value.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::LogInfo {
        fn default() -> Self {
            Self {
                log_id: ::std::default::Default::default(),
                term_id: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::LogInfo {}
    unsafe impl ::std::marker::Sync for self::LogInfo {}

    impl ::fbthrift::GetTType for self::LogInfo {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::LogInfo
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("LogInfo");
            p.write_field_begin("log_id", ::fbthrift::TType::I64, 1);
            ::fbthrift::Serialize::write(&self.log_id, p);
            p.write_field_end();
            p.write_field_begin("term_id", ::fbthrift::TType::I64, 2);
            ::fbthrift::Serialize::write(&self.term_id, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::LogInfo
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("log_id", ::fbthrift::TType::I64, 1),
                ::fbthrift::Field::new("term_id", ::fbthrift::TType::I64, 2),
            ];
            let mut field_log_id = ::std::option::Option::None;
            let mut field_term_id = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I64, 1) => field_log_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 2) => field_term_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                log_id: field_log_id.unwrap_or_default(),
                term_id: field_term_id.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::PartitionBackupInfo {
        fn default() -> Self {
            Self {
                info: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::PartitionBackupInfo {}
    unsafe impl ::std::marker::Sync for self::PartitionBackupInfo {}

    impl ::fbthrift::GetTType for self::PartitionBackupInfo {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::PartitionBackupInfo
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("PartitionBackupInfo");
            p.write_field_begin("info", ::fbthrift::TType::Map, 1);
            ::fbthrift::Serialize::write(&self.info, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::PartitionBackupInfo
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("info", ::fbthrift::TType::Map, 1),
            ];
            let mut field_info = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Map, 1) => field_info = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                info: field_info.unwrap_or_default(),
            })
        }
    }

}

pub mod errors {
}
