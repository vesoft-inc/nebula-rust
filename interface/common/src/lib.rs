// @generated by Thrift. This file is probably not the place you want to edit!

#![recursion_limit = "100000000"]
#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals, unused_crate_dependencies)]

pub use self::errors::*;
pub use self::types::*;

pub mod types {
    #![allow(clippy::redundant_closure)]


    pub type GraphSpaceID = ::std::primitive::i32;

    pub type PartitionID = ::std::primitive::i32;

    pub type TagID = ::std::primitive::i32;

    pub type EdgeType = ::std::primitive::i32;

    pub type EdgeRanking = ::std::primitive::i64;

    pub type LogID = ::std::primitive::i64;

    pub type TermID = ::std::primitive::i64;

    pub type Timestamp = ::std::primitive::i64;

    pub type IndexID = ::std::primitive::i32;

    pub type Port = ::std::primitive::i32;

    pub type SessionID = ::std::primitive::i64;

    pub type ExecutionPlanID = ::std::primitive::i64;

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct Date {
        pub year: ::std::primitive::i16,
        pub month: ::std::primitive::i8,
        pub day: ::std::primitive::i8,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct Time {
        pub hour: ::std::primitive::i8,
        pub minute: ::std::primitive::i8,
        pub sec: ::std::primitive::i8,
        pub microsec: ::std::primitive::i32,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct DateTime {
        pub year: ::std::primitive::i16,
        pub month: ::std::primitive::i8,
        pub day: ::std::primitive::i8,
        pub hour: ::std::primitive::i8,
        pub minute: ::std::primitive::i8,
        pub sec: ::std::primitive::i8,
        pub microsec: ::std::primitive::i32,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
    pub enum Value {
        nVal(crate::types::NullType),
        bVal(::std::primitive::bool),
        iVal(::std::primitive::i64),
        fVal(crate::double::Double),
        sVal(::std::vec::Vec<::std::primitive::u8>),
        dVal(crate::types::Date),
        tVal(crate::types::Time),
        dtVal(crate::types::DateTime),
        vVal(std::boxed::Box<crate::types::Vertex>),
        eVal(std::boxed::Box<crate::types::Edge>),
        pVal(std::boxed::Box<crate::types::Path>),
        lVal(std::boxed::Box<crate::types::NList>),
        mVal(std::boxed::Box<crate::types::NMap>),
        uVal(std::boxed::Box<crate::types::NSet>),
        gVal(std::boxed::Box<crate::types::DataSet>),
        UnknownField(::std::primitive::i32),
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
    pub struct NList {
        pub values: ::std::vec::Vec<crate::types::Value>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
    pub struct NMap {
        pub kvs: ::std::collections::BTreeMap<::std::vec::Vec<::std::primitive::u8>, crate::types::Value>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
    pub struct NSet {
        pub values: ::std::collections::BTreeSet<crate::types::Value>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
    pub struct Row {
        pub values: ::std::vec::Vec<crate::types::Value>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
    pub struct DataSet {
        pub column_names: ::std::vec::Vec<::std::vec::Vec<::std::primitive::u8>>,
        pub rows: ::std::vec::Vec<crate::types::Row>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
    pub struct Tag {
        pub name: ::std::vec::Vec<::std::primitive::u8>,
        pub props: ::std::collections::BTreeMap<::std::vec::Vec<::std::primitive::u8>, crate::types::Value>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
    pub struct Vertex {
        pub vid: crate::types::Value,
        pub tags: ::std::vec::Vec<crate::types::Tag>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
    pub struct Edge {
        pub src: crate::types::Value,
        pub dst: crate::types::Value,
        pub type_: crate::types::EdgeType,
        pub name: ::std::vec::Vec<::std::primitive::u8>,
        pub ranking: crate::types::EdgeRanking,
        pub props: ::std::collections::BTreeMap<::std::vec::Vec<::std::primitive::u8>, crate::types::Value>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
    pub struct Step {
        pub dst: crate::types::Vertex,
        pub type_: crate::types::EdgeType,
        pub name: ::std::vec::Vec<::std::primitive::u8>,
        pub ranking: crate::types::EdgeRanking,
        pub props: ::std::collections::BTreeMap<::std::vec::Vec<::std::primitive::u8>, crate::types::Value>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
    pub struct Path {
        pub src: crate::types::Vertex,
        pub steps: ::std::vec::Vec<crate::types::Step>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct HostAddr {
        pub host: ::std::string::String,
        pub port: crate::types::Port,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct KeyValue {
        pub key: ::std::vec::Vec<::std::primitive::u8>,
        pub value: ::std::vec::Vec<::std::primitive::u8>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct LogInfo {
        pub log_id: crate::types::LogID,
        pub term_id: crate::types::TermID,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct DirInfo {
        pub root: ::std::vec::Vec<::std::primitive::u8>,
        pub data: ::std::vec::Vec<::std::vec::Vec<::std::primitive::u8>>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct NodeInfo {
        pub host: crate::types::HostAddr,
        pub dir: crate::types::DirInfo,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct PartitionBackupInfo {
        pub info: ::std::collections::BTreeMap<crate::types::PartitionID, crate::types::LogInfo>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct CheckpointInfo {
        pub partition_info: crate::types::PartitionBackupInfo,
        pub path: ::std::vec::Vec<::std::primitive::u8>,
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    pub struct NullType(pub ::std::primitive::i32);

    impl NullType {
        pub const __NULL__: Self = NullType(0i32);
        pub const NaN: Self = NullType(1i32);
        pub const BAD_DATA: Self = NullType(2i32);
        pub const BAD_TYPE: Self = NullType(3i32);
        pub const ERR_OVERFLOW: Self = NullType(4i32);
        pub const UNKNOWN_PROP: Self = NullType(5i32);
        pub const DIV_BY_ZERO: Self = NullType(6i32);
        pub const OUT_OF_RANGE: Self = NullType(7i32);
    }

    impl ::fbthrift::ThriftEnum for NullType {
        fn enumerate() -> &'static [(NullType, &'static str)] {
            &[
                (NullType::__NULL__, "__NULL__"),
                (NullType::NaN, "NaN"),
                (NullType::BAD_DATA, "BAD_DATA"),
                (NullType::BAD_TYPE, "BAD_TYPE"),
                (NullType::ERR_OVERFLOW, "ERR_OVERFLOW"),
                (NullType::UNKNOWN_PROP, "UNKNOWN_PROP"),
                (NullType::DIV_BY_ZERO, "DIV_BY_ZERO"),
                (NullType::OUT_OF_RANGE, "OUT_OF_RANGE"),
            ]
        }

        fn variants() -> &'static [&'static str] {
            &[
                "__NULL__",
                "NaN",
                "BAD_DATA",
                "BAD_TYPE",
                "ERR_OVERFLOW",
                "UNKNOWN_PROP",
                "DIV_BY_ZERO",
                "OUT_OF_RANGE",
            ]
        }

        fn variant_values() -> &'static [NullType] {
            &[
                NullType::__NULL__,
                NullType::NaN,
                NullType::BAD_DATA,
                NullType::BAD_TYPE,
                NullType::ERR_OVERFLOW,
                NullType::UNKNOWN_PROP,
                NullType::DIV_BY_ZERO,
                NullType::OUT_OF_RANGE,
            ]
        }
    }

    impl ::std::default::Default for NullType {
        fn default() -> Self {
            NullType(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a NullType> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a NullType) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<NullType> for ::std::primitive::i32 {
        #[inline]
        fn from(x: NullType) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for NullType {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for NullType {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("__NULL__", 0),
                ("NaN", 1),
                ("BAD_DATA", 2),
                ("BAD_TYPE", 3),
                ("ERR_OVERFLOW", 4),
                ("UNKNOWN_PROP", 5),
                ("DIV_BY_ZERO", 6),
                ("OUT_OF_RANGE", 7),
            ];
            ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
        }
    }

    impl ::std::fmt::Debug for NullType {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "NullType::{}", self)
        }
    }

    impl ::std::str::FromStr for NullType {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("BAD_DATA", 2),
                ("BAD_TYPE", 3),
                ("DIV_BY_ZERO", 6),
                ("ERR_OVERFLOW", 4),
                ("NaN", 1),
                ("OUT_OF_RANGE", 7),
                ("UNKNOWN_PROP", 5),
                ("__NULL__", 0),
            ];
            ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "NullType").map(NullType)
        }
    }

    impl ::fbthrift::GetTType for NullType {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for NullType
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for NullType
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(NullType::from(p.read_i32()?))
        }
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    pub struct ErrorCode(pub ::std::primitive::i32);

    impl ErrorCode {
        pub const SUCCEEDED: Self = ErrorCode(0i32);
        pub const E_DISCONNECTED: Self = ErrorCode(-1i32);
        pub const E_FAIL_TO_CONNECT: Self = ErrorCode(-2i32);
        pub const E_RPC_FAILURE: Self = ErrorCode(-3i32);
        pub const E_LEADER_CHANGED: Self = ErrorCode(-4i32);
        pub const E_SPACE_NOT_FOUND: Self = ErrorCode(-5i32);
        pub const E_TAG_NOT_FOUND: Self = ErrorCode(-6i32);
        pub const E_EDGE_NOT_FOUND: Self = ErrorCode(-7i32);
        pub const E_INDEX_NOT_FOUND: Self = ErrorCode(-8i32);
        pub const E_EDGE_PROP_NOT_FOUND: Self = ErrorCode(-9i32);
        pub const E_TAG_PROP_NOT_FOUND: Self = ErrorCode(-10i32);
        pub const E_ROLE_NOT_FOUND: Self = ErrorCode(-11i32);
        pub const E_CONFIG_NOT_FOUND: Self = ErrorCode(-12i32);
        pub const E_GROUP_NOT_FOUND: Self = ErrorCode(-13i32);
        pub const E_ZONE_NOT_FOUND: Self = ErrorCode(-14i32);
        pub const E_LISTENER_NOT_FOUND: Self = ErrorCode(-15i32);
        pub const E_PART_NOT_FOUND: Self = ErrorCode(-16i32);
        pub const E_KEY_NOT_FOUND: Self = ErrorCode(-17i32);
        pub const E_USER_NOT_FOUND: Self = ErrorCode(-18i32);
        pub const E_BACKUP_FAILED: Self = ErrorCode(-24i32);
        pub const E_BACKUP_EMPTY_TABLE: Self = ErrorCode(-25i32);
        pub const E_BACKUP_TABLE_FAILED: Self = ErrorCode(-26i32);
        pub const E_PARTIAL_RESULT: Self = ErrorCode(-27i32);
        pub const E_REBUILD_INDEX_FAILED: Self = ErrorCode(-28i32);
        pub const E_INVALID_PASSWORD: Self = ErrorCode(-29i32);
        pub const E_FAILED_GET_ABS_PATH: Self = ErrorCode(-30i32);
        pub const E_BAD_USERNAME_PASSWORD: Self = ErrorCode(-1001i32);
        pub const E_SESSION_INVALID: Self = ErrorCode(-1002i32);
        pub const E_SESSION_TIMEOUT: Self = ErrorCode(-1003i32);
        pub const E_SYNTAX_ERROR: Self = ErrorCode(-1004i32);
        pub const E_EXECUTION_ERROR: Self = ErrorCode(-1005i32);
        pub const E_STATEMENT_EMPTY: Self = ErrorCode(-1006i32);
        pub const E_BAD_PERMISSION: Self = ErrorCode(-1008i32);
        pub const E_SEMANTIC_ERROR: Self = ErrorCode(-1009i32);
        pub const E_TOO_MANY_CONNECTIONS: Self = ErrorCode(-1010i32);
        pub const E_PARTIAL_SUCCEEDED: Self = ErrorCode(-1011i32);
        pub const E_NO_HOSTS: Self = ErrorCode(-2001i32);
        pub const E_EXISTED: Self = ErrorCode(-2002i32);
        pub const E_INVALID_HOST: Self = ErrorCode(-2003i32);
        pub const E_UNSUPPORTED: Self = ErrorCode(-2004i32);
        pub const E_NOT_DROP: Self = ErrorCode(-2005i32);
        pub const E_BALANCER_RUNNING: Self = ErrorCode(-2006i32);
        pub const E_CONFIG_IMMUTABLE: Self = ErrorCode(-2007i32);
        pub const E_CONFLICT: Self = ErrorCode(-2008i32);
        pub const E_INVALID_PARM: Self = ErrorCode(-2009i32);
        pub const E_WRONGCLUSTER: Self = ErrorCode(-2010i32);
        pub const E_STORE_FAILURE: Self = ErrorCode(-2021i32);
        pub const E_STORE_SEGMENT_ILLEGAL: Self = ErrorCode(-2022i32);
        pub const E_BAD_BALANCE_PLAN: Self = ErrorCode(-2023i32);
        pub const E_BALANCED: Self = ErrorCode(-2024i32);
        pub const E_NO_RUNNING_BALANCE_PLAN: Self = ErrorCode(-2025i32);
        pub const E_NO_VALID_HOST: Self = ErrorCode(-2026i32);
        pub const E_CORRUPTTED_BALANCE_PLAN: Self = ErrorCode(-2027i32);
        pub const E_NO_INVALID_BALANCE_PLAN: Self = ErrorCode(-2028i32);
        pub const E_IMPROPER_ROLE: Self = ErrorCode(-2030i32);
        pub const E_INVALID_PARTITION_NUM: Self = ErrorCode(-2031i32);
        pub const E_INVALID_REPLICA_FACTOR: Self = ErrorCode(-2032i32);
        pub const E_INVALID_CHARSET: Self = ErrorCode(-2033i32);
        pub const E_INVALID_COLLATE: Self = ErrorCode(-2034i32);
        pub const E_CHARSET_COLLATE_NOT_MATCH: Self = ErrorCode(-2035i32);
        pub const E_SNAPSHOT_FAILURE: Self = ErrorCode(-2040i32);
        pub const E_BLOCK_WRITE_FAILURE: Self = ErrorCode(-2041i32);
        pub const E_REBUILD_INDEX_FAILURE: Self = ErrorCode(-2042i32);
        pub const E_INDEX_WITH_TTL: Self = ErrorCode(-2043i32);
        pub const E_ADD_JOB_FAILURE: Self = ErrorCode(-2044i32);
        pub const E_STOP_JOB_FAILURE: Self = ErrorCode(-2045i32);
        pub const E_SAVE_JOB_FAILURE: Self = ErrorCode(-2046i32);
        pub const E_BALANCER_FAILURE: Self = ErrorCode(-2047i32);
        pub const E_JOB_NOT_FINISHED: Self = ErrorCode(-2048i32);
        pub const E_TASK_REPORT_OUT_DATE: Self = ErrorCode(-2049i32);
        pub const E_INVALID_JOB: Self = ErrorCode(-2065i32);
        pub const E_BACKUP_BUILDING_INDEX: Self = ErrorCode(-2066i32);
        pub const E_BACKUP_SPACE_NOT_FOUND: Self = ErrorCode(-2067i32);
        pub const E_RESTORE_FAILURE: Self = ErrorCode(-2068i32);
        pub const E_SESSION_NOT_FOUND: Self = ErrorCode(-2069i32);
        pub const E_LIST_CLUSTER_FAILURE: Self = ErrorCode(-2070i32);
        pub const E_LIST_CLUSTER_GET_ABS_PATH_FAILURE: Self = ErrorCode(-2071i32);
        pub const E_GET_META_DIR_FAILURE: Self = ErrorCode(-2072i32);
        pub const E_QUERY_NOT_FOUND: Self = ErrorCode(-2073i32);
        pub const E_CONSENSUS_ERROR: Self = ErrorCode(-3001i32);
        pub const E_KEY_HAS_EXISTS: Self = ErrorCode(-3002i32);
        pub const E_DATA_TYPE_MISMATCH: Self = ErrorCode(-3003i32);
        pub const E_INVALID_FIELD_VALUE: Self = ErrorCode(-3004i32);
        pub const E_INVALID_OPERATION: Self = ErrorCode(-3005i32);
        pub const E_NOT_NULLABLE: Self = ErrorCode(-3006i32);
        pub const E_FIELD_UNSET: Self = ErrorCode(-3007i32);
        pub const E_OUT_OF_RANGE: Self = ErrorCode(-3008i32);
        pub const E_ATOMIC_OP_FAILED: Self = ErrorCode(-3009i32);
        pub const E_DATA_CONFLICT_ERROR: Self = ErrorCode(-3010i32);
        pub const E_WRITE_STALLED: Self = ErrorCode(-3011i32);
        pub const E_IMPROPER_DATA_TYPE: Self = ErrorCode(-3021i32);
        pub const E_INVALID_SPACEVIDLEN: Self = ErrorCode(-3022i32);
        pub const E_INVALID_FILTER: Self = ErrorCode(-3031i32);
        pub const E_INVALID_UPDATER: Self = ErrorCode(-3032i32);
        pub const E_INVALID_STORE: Self = ErrorCode(-3033i32);
        pub const E_INVALID_PEER: Self = ErrorCode(-3034i32);
        pub const E_RETRY_EXHAUSTED: Self = ErrorCode(-3035i32);
        pub const E_TRANSFER_LEADER_FAILED: Self = ErrorCode(-3036i32);
        pub const E_INVALID_STAT_TYPE: Self = ErrorCode(-3037i32);
        pub const E_INVALID_VID: Self = ErrorCode(-3038i32);
        pub const E_NO_TRANSFORMED: Self = ErrorCode(-3039i32);
        pub const E_LOAD_META_FAILED: Self = ErrorCode(-3040i32);
        pub const E_FAILED_TO_CHECKPOINT: Self = ErrorCode(-3041i32);
        pub const E_CHECKPOINT_BLOCKED: Self = ErrorCode(-3042i32);
        pub const E_FILTER_OUT: Self = ErrorCode(-3043i32);
        pub const E_INVALID_DATA: Self = ErrorCode(-3044i32);
        pub const E_MUTATE_EDGE_CONFLICT: Self = ErrorCode(-3045i32);
        pub const E_MUTATE_TAG_CONFLICT: Self = ErrorCode(-3046i32);
        pub const E_OUTDATED_LOCK: Self = ErrorCode(-3047i32);
        pub const E_INVALID_TASK_PARA: Self = ErrorCode(-3051i32);
        pub const E_USER_CANCEL: Self = ErrorCode(-3052i32);
        pub const E_TASK_EXECUTION_FAILED: Self = ErrorCode(-3053i32);
        pub const E_UNKNOWN: Self = ErrorCode(-8000i32);
    }

    impl ::fbthrift::ThriftEnum for ErrorCode {
        fn enumerate() -> &'static [(ErrorCode, &'static str)] {
            &[
                (ErrorCode::SUCCEEDED, "SUCCEEDED"),
                (ErrorCode::E_DISCONNECTED, "E_DISCONNECTED"),
                (ErrorCode::E_FAIL_TO_CONNECT, "E_FAIL_TO_CONNECT"),
                (ErrorCode::E_RPC_FAILURE, "E_RPC_FAILURE"),
                (ErrorCode::E_LEADER_CHANGED, "E_LEADER_CHANGED"),
                (ErrorCode::E_SPACE_NOT_FOUND, "E_SPACE_NOT_FOUND"),
                (ErrorCode::E_TAG_NOT_FOUND, "E_TAG_NOT_FOUND"),
                (ErrorCode::E_EDGE_NOT_FOUND, "E_EDGE_NOT_FOUND"),
                (ErrorCode::E_INDEX_NOT_FOUND, "E_INDEX_NOT_FOUND"),
                (ErrorCode::E_EDGE_PROP_NOT_FOUND, "E_EDGE_PROP_NOT_FOUND"),
                (ErrorCode::E_TAG_PROP_NOT_FOUND, "E_TAG_PROP_NOT_FOUND"),
                (ErrorCode::E_ROLE_NOT_FOUND, "E_ROLE_NOT_FOUND"),
                (ErrorCode::E_CONFIG_NOT_FOUND, "E_CONFIG_NOT_FOUND"),
                (ErrorCode::E_GROUP_NOT_FOUND, "E_GROUP_NOT_FOUND"),
                (ErrorCode::E_ZONE_NOT_FOUND, "E_ZONE_NOT_FOUND"),
                (ErrorCode::E_LISTENER_NOT_FOUND, "E_LISTENER_NOT_FOUND"),
                (ErrorCode::E_PART_NOT_FOUND, "E_PART_NOT_FOUND"),
                (ErrorCode::E_KEY_NOT_FOUND, "E_KEY_NOT_FOUND"),
                (ErrorCode::E_USER_NOT_FOUND, "E_USER_NOT_FOUND"),
                (ErrorCode::E_BACKUP_FAILED, "E_BACKUP_FAILED"),
                (ErrorCode::E_BACKUP_EMPTY_TABLE, "E_BACKUP_EMPTY_TABLE"),
                (ErrorCode::E_BACKUP_TABLE_FAILED, "E_BACKUP_TABLE_FAILED"),
                (ErrorCode::E_PARTIAL_RESULT, "E_PARTIAL_RESULT"),
                (ErrorCode::E_REBUILD_INDEX_FAILED, "E_REBUILD_INDEX_FAILED"),
                (ErrorCode::E_INVALID_PASSWORD, "E_INVALID_PASSWORD"),
                (ErrorCode::E_FAILED_GET_ABS_PATH, "E_FAILED_GET_ABS_PATH"),
                (ErrorCode::E_BAD_USERNAME_PASSWORD, "E_BAD_USERNAME_PASSWORD"),
                (ErrorCode::E_SESSION_INVALID, "E_SESSION_INVALID"),
                (ErrorCode::E_SESSION_TIMEOUT, "E_SESSION_TIMEOUT"),
                (ErrorCode::E_SYNTAX_ERROR, "E_SYNTAX_ERROR"),
                (ErrorCode::E_EXECUTION_ERROR, "E_EXECUTION_ERROR"),
                (ErrorCode::E_STATEMENT_EMPTY, "E_STATEMENT_EMPTY"),
                (ErrorCode::E_BAD_PERMISSION, "E_BAD_PERMISSION"),
                (ErrorCode::E_SEMANTIC_ERROR, "E_SEMANTIC_ERROR"),
                (ErrorCode::E_TOO_MANY_CONNECTIONS, "E_TOO_MANY_CONNECTIONS"),
                (ErrorCode::E_PARTIAL_SUCCEEDED, "E_PARTIAL_SUCCEEDED"),
                (ErrorCode::E_NO_HOSTS, "E_NO_HOSTS"),
                (ErrorCode::E_EXISTED, "E_EXISTED"),
                (ErrorCode::E_INVALID_HOST, "E_INVALID_HOST"),
                (ErrorCode::E_UNSUPPORTED, "E_UNSUPPORTED"),
                (ErrorCode::E_NOT_DROP, "E_NOT_DROP"),
                (ErrorCode::E_BALANCER_RUNNING, "E_BALANCER_RUNNING"),
                (ErrorCode::E_CONFIG_IMMUTABLE, "E_CONFIG_IMMUTABLE"),
                (ErrorCode::E_CONFLICT, "E_CONFLICT"),
                (ErrorCode::E_INVALID_PARM, "E_INVALID_PARM"),
                (ErrorCode::E_WRONGCLUSTER, "E_WRONGCLUSTER"),
                (ErrorCode::E_STORE_FAILURE, "E_STORE_FAILURE"),
                (ErrorCode::E_STORE_SEGMENT_ILLEGAL, "E_STORE_SEGMENT_ILLEGAL"),
                (ErrorCode::E_BAD_BALANCE_PLAN, "E_BAD_BALANCE_PLAN"),
                (ErrorCode::E_BALANCED, "E_BALANCED"),
                (ErrorCode::E_NO_RUNNING_BALANCE_PLAN, "E_NO_RUNNING_BALANCE_PLAN"),
                (ErrorCode::E_NO_VALID_HOST, "E_NO_VALID_HOST"),
                (ErrorCode::E_CORRUPTTED_BALANCE_PLAN, "E_CORRUPTTED_BALANCE_PLAN"),
                (ErrorCode::E_NO_INVALID_BALANCE_PLAN, "E_NO_INVALID_BALANCE_PLAN"),
                (ErrorCode::E_IMPROPER_ROLE, "E_IMPROPER_ROLE"),
                (ErrorCode::E_INVALID_PARTITION_NUM, "E_INVALID_PARTITION_NUM"),
                (ErrorCode::E_INVALID_REPLICA_FACTOR, "E_INVALID_REPLICA_FACTOR"),
                (ErrorCode::E_INVALID_CHARSET, "E_INVALID_CHARSET"),
                (ErrorCode::E_INVALID_COLLATE, "E_INVALID_COLLATE"),
                (ErrorCode::E_CHARSET_COLLATE_NOT_MATCH, "E_CHARSET_COLLATE_NOT_MATCH"),
                (ErrorCode::E_SNAPSHOT_FAILURE, "E_SNAPSHOT_FAILURE"),
                (ErrorCode::E_BLOCK_WRITE_FAILURE, "E_BLOCK_WRITE_FAILURE"),
                (ErrorCode::E_REBUILD_INDEX_FAILURE, "E_REBUILD_INDEX_FAILURE"),
                (ErrorCode::E_INDEX_WITH_TTL, "E_INDEX_WITH_TTL"),
                (ErrorCode::E_ADD_JOB_FAILURE, "E_ADD_JOB_FAILURE"),
                (ErrorCode::E_STOP_JOB_FAILURE, "E_STOP_JOB_FAILURE"),
                (ErrorCode::E_SAVE_JOB_FAILURE, "E_SAVE_JOB_FAILURE"),
                (ErrorCode::E_BALANCER_FAILURE, "E_BALANCER_FAILURE"),
                (ErrorCode::E_JOB_NOT_FINISHED, "E_JOB_NOT_FINISHED"),
                (ErrorCode::E_TASK_REPORT_OUT_DATE, "E_TASK_REPORT_OUT_DATE"),
                (ErrorCode::E_INVALID_JOB, "E_INVALID_JOB"),
                (ErrorCode::E_BACKUP_BUILDING_INDEX, "E_BACKUP_BUILDING_INDEX"),
                (ErrorCode::E_BACKUP_SPACE_NOT_FOUND, "E_BACKUP_SPACE_NOT_FOUND"),
                (ErrorCode::E_RESTORE_FAILURE, "E_RESTORE_FAILURE"),
                (ErrorCode::E_SESSION_NOT_FOUND, "E_SESSION_NOT_FOUND"),
                (ErrorCode::E_LIST_CLUSTER_FAILURE, "E_LIST_CLUSTER_FAILURE"),
                (ErrorCode::E_LIST_CLUSTER_GET_ABS_PATH_FAILURE, "E_LIST_CLUSTER_GET_ABS_PATH_FAILURE"),
                (ErrorCode::E_GET_META_DIR_FAILURE, "E_GET_META_DIR_FAILURE"),
                (ErrorCode::E_QUERY_NOT_FOUND, "E_QUERY_NOT_FOUND"),
                (ErrorCode::E_CONSENSUS_ERROR, "E_CONSENSUS_ERROR"),
                (ErrorCode::E_KEY_HAS_EXISTS, "E_KEY_HAS_EXISTS"),
                (ErrorCode::E_DATA_TYPE_MISMATCH, "E_DATA_TYPE_MISMATCH"),
                (ErrorCode::E_INVALID_FIELD_VALUE, "E_INVALID_FIELD_VALUE"),
                (ErrorCode::E_INVALID_OPERATION, "E_INVALID_OPERATION"),
                (ErrorCode::E_NOT_NULLABLE, "E_NOT_NULLABLE"),
                (ErrorCode::E_FIELD_UNSET, "E_FIELD_UNSET"),
                (ErrorCode::E_OUT_OF_RANGE, "E_OUT_OF_RANGE"),
                (ErrorCode::E_ATOMIC_OP_FAILED, "E_ATOMIC_OP_FAILED"),
                (ErrorCode::E_DATA_CONFLICT_ERROR, "E_DATA_CONFLICT_ERROR"),
                (ErrorCode::E_WRITE_STALLED, "E_WRITE_STALLED"),
                (ErrorCode::E_IMPROPER_DATA_TYPE, "E_IMPROPER_DATA_TYPE"),
                (ErrorCode::E_INVALID_SPACEVIDLEN, "E_INVALID_SPACEVIDLEN"),
                (ErrorCode::E_INVALID_FILTER, "E_INVALID_FILTER"),
                (ErrorCode::E_INVALID_UPDATER, "E_INVALID_UPDATER"),
                (ErrorCode::E_INVALID_STORE, "E_INVALID_STORE"),
                (ErrorCode::E_INVALID_PEER, "E_INVALID_PEER"),
                (ErrorCode::E_RETRY_EXHAUSTED, "E_RETRY_EXHAUSTED"),
                (ErrorCode::E_TRANSFER_LEADER_FAILED, "E_TRANSFER_LEADER_FAILED"),
                (ErrorCode::E_INVALID_STAT_TYPE, "E_INVALID_STAT_TYPE"),
                (ErrorCode::E_INVALID_VID, "E_INVALID_VID"),
                (ErrorCode::E_NO_TRANSFORMED, "E_NO_TRANSFORMED"),
                (ErrorCode::E_LOAD_META_FAILED, "E_LOAD_META_FAILED"),
                (ErrorCode::E_FAILED_TO_CHECKPOINT, "E_FAILED_TO_CHECKPOINT"),
                (ErrorCode::E_CHECKPOINT_BLOCKED, "E_CHECKPOINT_BLOCKED"),
                (ErrorCode::E_FILTER_OUT, "E_FILTER_OUT"),
                (ErrorCode::E_INVALID_DATA, "E_INVALID_DATA"),
                (ErrorCode::E_MUTATE_EDGE_CONFLICT, "E_MUTATE_EDGE_CONFLICT"),
                (ErrorCode::E_MUTATE_TAG_CONFLICT, "E_MUTATE_TAG_CONFLICT"),
                (ErrorCode::E_OUTDATED_LOCK, "E_OUTDATED_LOCK"),
                (ErrorCode::E_INVALID_TASK_PARA, "E_INVALID_TASK_PARA"),
                (ErrorCode::E_USER_CANCEL, "E_USER_CANCEL"),
                (ErrorCode::E_TASK_EXECUTION_FAILED, "E_TASK_EXECUTION_FAILED"),
                (ErrorCode::E_UNKNOWN, "E_UNKNOWN"),
            ]
        }

        fn variants() -> &'static [&'static str] {
            &[
                "SUCCEEDED",
                "E_DISCONNECTED",
                "E_FAIL_TO_CONNECT",
                "E_RPC_FAILURE",
                "E_LEADER_CHANGED",
                "E_SPACE_NOT_FOUND",
                "E_TAG_NOT_FOUND",
                "E_EDGE_NOT_FOUND",
                "E_INDEX_NOT_FOUND",
                "E_EDGE_PROP_NOT_FOUND",
                "E_TAG_PROP_NOT_FOUND",
                "E_ROLE_NOT_FOUND",
                "E_CONFIG_NOT_FOUND",
                "E_GROUP_NOT_FOUND",
                "E_ZONE_NOT_FOUND",
                "E_LISTENER_NOT_FOUND",
                "E_PART_NOT_FOUND",
                "E_KEY_NOT_FOUND",
                "E_USER_NOT_FOUND",
                "E_BACKUP_FAILED",
                "E_BACKUP_EMPTY_TABLE",
                "E_BACKUP_TABLE_FAILED",
                "E_PARTIAL_RESULT",
                "E_REBUILD_INDEX_FAILED",
                "E_INVALID_PASSWORD",
                "E_FAILED_GET_ABS_PATH",
                "E_BAD_USERNAME_PASSWORD",
                "E_SESSION_INVALID",
                "E_SESSION_TIMEOUT",
                "E_SYNTAX_ERROR",
                "E_EXECUTION_ERROR",
                "E_STATEMENT_EMPTY",
                "E_BAD_PERMISSION",
                "E_SEMANTIC_ERROR",
                "E_TOO_MANY_CONNECTIONS",
                "E_PARTIAL_SUCCEEDED",
                "E_NO_HOSTS",
                "E_EXISTED",
                "E_INVALID_HOST",
                "E_UNSUPPORTED",
                "E_NOT_DROP",
                "E_BALANCER_RUNNING",
                "E_CONFIG_IMMUTABLE",
                "E_CONFLICT",
                "E_INVALID_PARM",
                "E_WRONGCLUSTER",
                "E_STORE_FAILURE",
                "E_STORE_SEGMENT_ILLEGAL",
                "E_BAD_BALANCE_PLAN",
                "E_BALANCED",
                "E_NO_RUNNING_BALANCE_PLAN",
                "E_NO_VALID_HOST",
                "E_CORRUPTTED_BALANCE_PLAN",
                "E_NO_INVALID_BALANCE_PLAN",
                "E_IMPROPER_ROLE",
                "E_INVALID_PARTITION_NUM",
                "E_INVALID_REPLICA_FACTOR",
                "E_INVALID_CHARSET",
                "E_INVALID_COLLATE",
                "E_CHARSET_COLLATE_NOT_MATCH",
                "E_SNAPSHOT_FAILURE",
                "E_BLOCK_WRITE_FAILURE",
                "E_REBUILD_INDEX_FAILURE",
                "E_INDEX_WITH_TTL",
                "E_ADD_JOB_FAILURE",
                "E_STOP_JOB_FAILURE",
                "E_SAVE_JOB_FAILURE",
                "E_BALANCER_FAILURE",
                "E_JOB_NOT_FINISHED",
                "E_TASK_REPORT_OUT_DATE",
                "E_INVALID_JOB",
                "E_BACKUP_BUILDING_INDEX",
                "E_BACKUP_SPACE_NOT_FOUND",
                "E_RESTORE_FAILURE",
                "E_SESSION_NOT_FOUND",
                "E_LIST_CLUSTER_FAILURE",
                "E_LIST_CLUSTER_GET_ABS_PATH_FAILURE",
                "E_GET_META_DIR_FAILURE",
                "E_QUERY_NOT_FOUND",
                "E_CONSENSUS_ERROR",
                "E_KEY_HAS_EXISTS",
                "E_DATA_TYPE_MISMATCH",
                "E_INVALID_FIELD_VALUE",
                "E_INVALID_OPERATION",
                "E_NOT_NULLABLE",
                "E_FIELD_UNSET",
                "E_OUT_OF_RANGE",
                "E_ATOMIC_OP_FAILED",
                "E_DATA_CONFLICT_ERROR",
                "E_WRITE_STALLED",
                "E_IMPROPER_DATA_TYPE",
                "E_INVALID_SPACEVIDLEN",
                "E_INVALID_FILTER",
                "E_INVALID_UPDATER",
                "E_INVALID_STORE",
                "E_INVALID_PEER",
                "E_RETRY_EXHAUSTED",
                "E_TRANSFER_LEADER_FAILED",
                "E_INVALID_STAT_TYPE",
                "E_INVALID_VID",
                "E_NO_TRANSFORMED",
                "E_LOAD_META_FAILED",
                "E_FAILED_TO_CHECKPOINT",
                "E_CHECKPOINT_BLOCKED",
                "E_FILTER_OUT",
                "E_INVALID_DATA",
                "E_MUTATE_EDGE_CONFLICT",
                "E_MUTATE_TAG_CONFLICT",
                "E_OUTDATED_LOCK",
                "E_INVALID_TASK_PARA",
                "E_USER_CANCEL",
                "E_TASK_EXECUTION_FAILED",
                "E_UNKNOWN",
            ]
        }

        fn variant_values() -> &'static [ErrorCode] {
            &[
                ErrorCode::SUCCEEDED,
                ErrorCode::E_DISCONNECTED,
                ErrorCode::E_FAIL_TO_CONNECT,
                ErrorCode::E_RPC_FAILURE,
                ErrorCode::E_LEADER_CHANGED,
                ErrorCode::E_SPACE_NOT_FOUND,
                ErrorCode::E_TAG_NOT_FOUND,
                ErrorCode::E_EDGE_NOT_FOUND,
                ErrorCode::E_INDEX_NOT_FOUND,
                ErrorCode::E_EDGE_PROP_NOT_FOUND,
                ErrorCode::E_TAG_PROP_NOT_FOUND,
                ErrorCode::E_ROLE_NOT_FOUND,
                ErrorCode::E_CONFIG_NOT_FOUND,
                ErrorCode::E_GROUP_NOT_FOUND,
                ErrorCode::E_ZONE_NOT_FOUND,
                ErrorCode::E_LISTENER_NOT_FOUND,
                ErrorCode::E_PART_NOT_FOUND,
                ErrorCode::E_KEY_NOT_FOUND,
                ErrorCode::E_USER_NOT_FOUND,
                ErrorCode::E_BACKUP_FAILED,
                ErrorCode::E_BACKUP_EMPTY_TABLE,
                ErrorCode::E_BACKUP_TABLE_FAILED,
                ErrorCode::E_PARTIAL_RESULT,
                ErrorCode::E_REBUILD_INDEX_FAILED,
                ErrorCode::E_INVALID_PASSWORD,
                ErrorCode::E_FAILED_GET_ABS_PATH,
                ErrorCode::E_BAD_USERNAME_PASSWORD,
                ErrorCode::E_SESSION_INVALID,
                ErrorCode::E_SESSION_TIMEOUT,
                ErrorCode::E_SYNTAX_ERROR,
                ErrorCode::E_EXECUTION_ERROR,
                ErrorCode::E_STATEMENT_EMPTY,
                ErrorCode::E_BAD_PERMISSION,
                ErrorCode::E_SEMANTIC_ERROR,
                ErrorCode::E_TOO_MANY_CONNECTIONS,
                ErrorCode::E_PARTIAL_SUCCEEDED,
                ErrorCode::E_NO_HOSTS,
                ErrorCode::E_EXISTED,
                ErrorCode::E_INVALID_HOST,
                ErrorCode::E_UNSUPPORTED,
                ErrorCode::E_NOT_DROP,
                ErrorCode::E_BALANCER_RUNNING,
                ErrorCode::E_CONFIG_IMMUTABLE,
                ErrorCode::E_CONFLICT,
                ErrorCode::E_INVALID_PARM,
                ErrorCode::E_WRONGCLUSTER,
                ErrorCode::E_STORE_FAILURE,
                ErrorCode::E_STORE_SEGMENT_ILLEGAL,
                ErrorCode::E_BAD_BALANCE_PLAN,
                ErrorCode::E_BALANCED,
                ErrorCode::E_NO_RUNNING_BALANCE_PLAN,
                ErrorCode::E_NO_VALID_HOST,
                ErrorCode::E_CORRUPTTED_BALANCE_PLAN,
                ErrorCode::E_NO_INVALID_BALANCE_PLAN,
                ErrorCode::E_IMPROPER_ROLE,
                ErrorCode::E_INVALID_PARTITION_NUM,
                ErrorCode::E_INVALID_REPLICA_FACTOR,
                ErrorCode::E_INVALID_CHARSET,
                ErrorCode::E_INVALID_COLLATE,
                ErrorCode::E_CHARSET_COLLATE_NOT_MATCH,
                ErrorCode::E_SNAPSHOT_FAILURE,
                ErrorCode::E_BLOCK_WRITE_FAILURE,
                ErrorCode::E_REBUILD_INDEX_FAILURE,
                ErrorCode::E_INDEX_WITH_TTL,
                ErrorCode::E_ADD_JOB_FAILURE,
                ErrorCode::E_STOP_JOB_FAILURE,
                ErrorCode::E_SAVE_JOB_FAILURE,
                ErrorCode::E_BALANCER_FAILURE,
                ErrorCode::E_JOB_NOT_FINISHED,
                ErrorCode::E_TASK_REPORT_OUT_DATE,
                ErrorCode::E_INVALID_JOB,
                ErrorCode::E_BACKUP_BUILDING_INDEX,
                ErrorCode::E_BACKUP_SPACE_NOT_FOUND,
                ErrorCode::E_RESTORE_FAILURE,
                ErrorCode::E_SESSION_NOT_FOUND,
                ErrorCode::E_LIST_CLUSTER_FAILURE,
                ErrorCode::E_LIST_CLUSTER_GET_ABS_PATH_FAILURE,
                ErrorCode::E_GET_META_DIR_FAILURE,
                ErrorCode::E_QUERY_NOT_FOUND,
                ErrorCode::E_CONSENSUS_ERROR,
                ErrorCode::E_KEY_HAS_EXISTS,
                ErrorCode::E_DATA_TYPE_MISMATCH,
                ErrorCode::E_INVALID_FIELD_VALUE,
                ErrorCode::E_INVALID_OPERATION,
                ErrorCode::E_NOT_NULLABLE,
                ErrorCode::E_FIELD_UNSET,
                ErrorCode::E_OUT_OF_RANGE,
                ErrorCode::E_ATOMIC_OP_FAILED,
                ErrorCode::E_DATA_CONFLICT_ERROR,
                ErrorCode::E_WRITE_STALLED,
                ErrorCode::E_IMPROPER_DATA_TYPE,
                ErrorCode::E_INVALID_SPACEVIDLEN,
                ErrorCode::E_INVALID_FILTER,
                ErrorCode::E_INVALID_UPDATER,
                ErrorCode::E_INVALID_STORE,
                ErrorCode::E_INVALID_PEER,
                ErrorCode::E_RETRY_EXHAUSTED,
                ErrorCode::E_TRANSFER_LEADER_FAILED,
                ErrorCode::E_INVALID_STAT_TYPE,
                ErrorCode::E_INVALID_VID,
                ErrorCode::E_NO_TRANSFORMED,
                ErrorCode::E_LOAD_META_FAILED,
                ErrorCode::E_FAILED_TO_CHECKPOINT,
                ErrorCode::E_CHECKPOINT_BLOCKED,
                ErrorCode::E_FILTER_OUT,
                ErrorCode::E_INVALID_DATA,
                ErrorCode::E_MUTATE_EDGE_CONFLICT,
                ErrorCode::E_MUTATE_TAG_CONFLICT,
                ErrorCode::E_OUTDATED_LOCK,
                ErrorCode::E_INVALID_TASK_PARA,
                ErrorCode::E_USER_CANCEL,
                ErrorCode::E_TASK_EXECUTION_FAILED,
                ErrorCode::E_UNKNOWN,
            ]
        }
    }

    impl ::std::default::Default for ErrorCode {
        fn default() -> Self {
            ErrorCode(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a ErrorCode> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a ErrorCode) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<ErrorCode> for ::std::primitive::i32 {
        #[inline]
        fn from(x: ErrorCode) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for ErrorCode {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for ErrorCode {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("E_UNKNOWN", -8000),
                ("E_TASK_EXECUTION_FAILED", -3053),
                ("E_USER_CANCEL", -3052),
                ("E_INVALID_TASK_PARA", -3051),
                ("E_OUTDATED_LOCK", -3047),
                ("E_MUTATE_TAG_CONFLICT", -3046),
                ("E_MUTATE_EDGE_CONFLICT", -3045),
                ("E_INVALID_DATA", -3044),
                ("E_FILTER_OUT", -3043),
                ("E_CHECKPOINT_BLOCKED", -3042),
                ("E_FAILED_TO_CHECKPOINT", -3041),
                ("E_LOAD_META_FAILED", -3040),
                ("E_NO_TRANSFORMED", -3039),
                ("E_INVALID_VID", -3038),
                ("E_INVALID_STAT_TYPE", -3037),
                ("E_TRANSFER_LEADER_FAILED", -3036),
                ("E_RETRY_EXHAUSTED", -3035),
                ("E_INVALID_PEER", -3034),
                ("E_INVALID_STORE", -3033),
                ("E_INVALID_UPDATER", -3032),
                ("E_INVALID_FILTER", -3031),
                ("E_INVALID_SPACEVIDLEN", -3022),
                ("E_IMPROPER_DATA_TYPE", -3021),
                ("E_WRITE_STALLED", -3011),
                ("E_DATA_CONFLICT_ERROR", -3010),
                ("E_ATOMIC_OP_FAILED", -3009),
                ("E_OUT_OF_RANGE", -3008),
                ("E_FIELD_UNSET", -3007),
                ("E_NOT_NULLABLE", -3006),
                ("E_INVALID_OPERATION", -3005),
                ("E_INVALID_FIELD_VALUE", -3004),
                ("E_DATA_TYPE_MISMATCH", -3003),
                ("E_KEY_HAS_EXISTS", -3002),
                ("E_CONSENSUS_ERROR", -3001),
                ("E_QUERY_NOT_FOUND", -2073),
                ("E_GET_META_DIR_FAILURE", -2072),
                ("E_LIST_CLUSTER_GET_ABS_PATH_FAILURE", -2071),
                ("E_LIST_CLUSTER_FAILURE", -2070),
                ("E_SESSION_NOT_FOUND", -2069),
                ("E_RESTORE_FAILURE", -2068),
                ("E_BACKUP_SPACE_NOT_FOUND", -2067),
                ("E_BACKUP_BUILDING_INDEX", -2066),
                ("E_INVALID_JOB", -2065),
                ("E_TASK_REPORT_OUT_DATE", -2049),
                ("E_JOB_NOT_FINISHED", -2048),
                ("E_BALANCER_FAILURE", -2047),
                ("E_SAVE_JOB_FAILURE", -2046),
                ("E_STOP_JOB_FAILURE", -2045),
                ("E_ADD_JOB_FAILURE", -2044),
                ("E_INDEX_WITH_TTL", -2043),
                ("E_REBUILD_INDEX_FAILURE", -2042),
                ("E_BLOCK_WRITE_FAILURE", -2041),
                ("E_SNAPSHOT_FAILURE", -2040),
                ("E_CHARSET_COLLATE_NOT_MATCH", -2035),
                ("E_INVALID_COLLATE", -2034),
                ("E_INVALID_CHARSET", -2033),
                ("E_INVALID_REPLICA_FACTOR", -2032),
                ("E_INVALID_PARTITION_NUM", -2031),
                ("E_IMPROPER_ROLE", -2030),
                ("E_NO_INVALID_BALANCE_PLAN", -2028),
                ("E_CORRUPTTED_BALANCE_PLAN", -2027),
                ("E_NO_VALID_HOST", -2026),
                ("E_NO_RUNNING_BALANCE_PLAN", -2025),
                ("E_BALANCED", -2024),
                ("E_BAD_BALANCE_PLAN", -2023),
                ("E_STORE_SEGMENT_ILLEGAL", -2022),
                ("E_STORE_FAILURE", -2021),
                ("E_WRONGCLUSTER", -2010),
                ("E_INVALID_PARM", -2009),
                ("E_CONFLICT", -2008),
                ("E_CONFIG_IMMUTABLE", -2007),
                ("E_BALANCER_RUNNING", -2006),
                ("E_NOT_DROP", -2005),
                ("E_UNSUPPORTED", -2004),
                ("E_INVALID_HOST", -2003),
                ("E_EXISTED", -2002),
                ("E_NO_HOSTS", -2001),
                ("E_PARTIAL_SUCCEEDED", -1011),
                ("E_TOO_MANY_CONNECTIONS", -1010),
                ("E_SEMANTIC_ERROR", -1009),
                ("E_BAD_PERMISSION", -1008),
                ("E_STATEMENT_EMPTY", -1006),
                ("E_EXECUTION_ERROR", -1005),
                ("E_SYNTAX_ERROR", -1004),
                ("E_SESSION_TIMEOUT", -1003),
                ("E_SESSION_INVALID", -1002),
                ("E_BAD_USERNAME_PASSWORD", -1001),
                ("E_FAILED_GET_ABS_PATH", -30),
                ("E_INVALID_PASSWORD", -29),
                ("E_REBUILD_INDEX_FAILED", -28),
                ("E_PARTIAL_RESULT", -27),
                ("E_BACKUP_TABLE_FAILED", -26),
                ("E_BACKUP_EMPTY_TABLE", -25),
                ("E_BACKUP_FAILED", -24),
                ("E_USER_NOT_FOUND", -18),
                ("E_KEY_NOT_FOUND", -17),
                ("E_PART_NOT_FOUND", -16),
                ("E_LISTENER_NOT_FOUND", -15),
                ("E_ZONE_NOT_FOUND", -14),
                ("E_GROUP_NOT_FOUND", -13),
                ("E_CONFIG_NOT_FOUND", -12),
                ("E_ROLE_NOT_FOUND", -11),
                ("E_TAG_PROP_NOT_FOUND", -10),
                ("E_EDGE_PROP_NOT_FOUND", -9),
                ("E_INDEX_NOT_FOUND", -8),
                ("E_EDGE_NOT_FOUND", -7),
                ("E_TAG_NOT_FOUND", -6),
                ("E_SPACE_NOT_FOUND", -5),
                ("E_LEADER_CHANGED", -4),
                ("E_RPC_FAILURE", -3),
                ("E_FAIL_TO_CONNECT", -2),
                ("E_DISCONNECTED", -1),
                ("SUCCEEDED", 0),
            ];
            ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
        }
    }

    impl ::std::fmt::Debug for ErrorCode {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "ErrorCode::{}", self)
        }
    }

    impl ::std::str::FromStr for ErrorCode {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("E_ADD_JOB_FAILURE", -2044),
                ("E_ATOMIC_OP_FAILED", -3009),
                ("E_BACKUP_BUILDING_INDEX", -2066),
                ("E_BACKUP_EMPTY_TABLE", -25),
                ("E_BACKUP_FAILED", -24),
                ("E_BACKUP_SPACE_NOT_FOUND", -2067),
                ("E_BACKUP_TABLE_FAILED", -26),
                ("E_BAD_BALANCE_PLAN", -2023),
                ("E_BAD_PERMISSION", -1008),
                ("E_BAD_USERNAME_PASSWORD", -1001),
                ("E_BALANCED", -2024),
                ("E_BALANCER_FAILURE", -2047),
                ("E_BALANCER_RUNNING", -2006),
                ("E_BLOCK_WRITE_FAILURE", -2041),
                ("E_CHARSET_COLLATE_NOT_MATCH", -2035),
                ("E_CHECKPOINT_BLOCKED", -3042),
                ("E_CONFIG_IMMUTABLE", -2007),
                ("E_CONFIG_NOT_FOUND", -12),
                ("E_CONFLICT", -2008),
                ("E_CONSENSUS_ERROR", -3001),
                ("E_CORRUPTTED_BALANCE_PLAN", -2027),
                ("E_DATA_CONFLICT_ERROR", -3010),
                ("E_DATA_TYPE_MISMATCH", -3003),
                ("E_DISCONNECTED", -1),
                ("E_EDGE_NOT_FOUND", -7),
                ("E_EDGE_PROP_NOT_FOUND", -9),
                ("E_EXECUTION_ERROR", -1005),
                ("E_EXISTED", -2002),
                ("E_FAILED_GET_ABS_PATH", -30),
                ("E_FAILED_TO_CHECKPOINT", -3041),
                ("E_FAIL_TO_CONNECT", -2),
                ("E_FIELD_UNSET", -3007),
                ("E_FILTER_OUT", -3043),
                ("E_GET_META_DIR_FAILURE", -2072),
                ("E_GROUP_NOT_FOUND", -13),
                ("E_IMPROPER_DATA_TYPE", -3021),
                ("E_IMPROPER_ROLE", -2030),
                ("E_INDEX_NOT_FOUND", -8),
                ("E_INDEX_WITH_TTL", -2043),
                ("E_INVALID_CHARSET", -2033),
                ("E_INVALID_COLLATE", -2034),
                ("E_INVALID_DATA", -3044),
                ("E_INVALID_FIELD_VALUE", -3004),
                ("E_INVALID_FILTER", -3031),
                ("E_INVALID_HOST", -2003),
                ("E_INVALID_JOB", -2065),
                ("E_INVALID_OPERATION", -3005),
                ("E_INVALID_PARM", -2009),
                ("E_INVALID_PARTITION_NUM", -2031),
                ("E_INVALID_PASSWORD", -29),
                ("E_INVALID_PEER", -3034),
                ("E_INVALID_REPLICA_FACTOR", -2032),
                ("E_INVALID_SPACEVIDLEN", -3022),
                ("E_INVALID_STAT_TYPE", -3037),
                ("E_INVALID_STORE", -3033),
                ("E_INVALID_TASK_PARA", -3051),
                ("E_INVALID_UPDATER", -3032),
                ("E_INVALID_VID", -3038),
                ("E_JOB_NOT_FINISHED", -2048),
                ("E_KEY_HAS_EXISTS", -3002),
                ("E_KEY_NOT_FOUND", -17),
                ("E_LEADER_CHANGED", -4),
                ("E_LISTENER_NOT_FOUND", -15),
                ("E_LIST_CLUSTER_FAILURE", -2070),
                ("E_LIST_CLUSTER_GET_ABS_PATH_FAILURE", -2071),
                ("E_LOAD_META_FAILED", -3040),
                ("E_MUTATE_EDGE_CONFLICT", -3045),
                ("E_MUTATE_TAG_CONFLICT", -3046),
                ("E_NOT_DROP", -2005),
                ("E_NOT_NULLABLE", -3006),
                ("E_NO_HOSTS", -2001),
                ("E_NO_INVALID_BALANCE_PLAN", -2028),
                ("E_NO_RUNNING_BALANCE_PLAN", -2025),
                ("E_NO_TRANSFORMED", -3039),
                ("E_NO_VALID_HOST", -2026),
                ("E_OUTDATED_LOCK", -3047),
                ("E_OUT_OF_RANGE", -3008),
                ("E_PARTIAL_RESULT", -27),
                ("E_PARTIAL_SUCCEEDED", -1011),
                ("E_PART_NOT_FOUND", -16),
                ("E_QUERY_NOT_FOUND", -2073),
                ("E_REBUILD_INDEX_FAILED", -28),
                ("E_REBUILD_INDEX_FAILURE", -2042),
                ("E_RESTORE_FAILURE", -2068),
                ("E_RETRY_EXHAUSTED", -3035),
                ("E_ROLE_NOT_FOUND", -11),
                ("E_RPC_FAILURE", -3),
                ("E_SAVE_JOB_FAILURE", -2046),
                ("E_SEMANTIC_ERROR", -1009),
                ("E_SESSION_INVALID", -1002),
                ("E_SESSION_NOT_FOUND", -2069),
                ("E_SESSION_TIMEOUT", -1003),
                ("E_SNAPSHOT_FAILURE", -2040),
                ("E_SPACE_NOT_FOUND", -5),
                ("E_STATEMENT_EMPTY", -1006),
                ("E_STOP_JOB_FAILURE", -2045),
                ("E_STORE_FAILURE", -2021),
                ("E_STORE_SEGMENT_ILLEGAL", -2022),
                ("E_SYNTAX_ERROR", -1004),
                ("E_TAG_NOT_FOUND", -6),
                ("E_TAG_PROP_NOT_FOUND", -10),
                ("E_TASK_EXECUTION_FAILED", -3053),
                ("E_TASK_REPORT_OUT_DATE", -2049),
                ("E_TOO_MANY_CONNECTIONS", -1010),
                ("E_TRANSFER_LEADER_FAILED", -3036),
                ("E_UNKNOWN", -8000),
                ("E_UNSUPPORTED", -2004),
                ("E_USER_CANCEL", -3052),
                ("E_USER_NOT_FOUND", -18),
                ("E_WRITE_STALLED", -3011),
                ("E_WRONGCLUSTER", -2010),
                ("E_ZONE_NOT_FOUND", -14),
                ("SUCCEEDED", 0),
            ];
            ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "ErrorCode").map(ErrorCode)
        }
    }

    impl ::fbthrift::GetTType for ErrorCode {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for ErrorCode
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for ErrorCode
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(ErrorCode::from(p.read_i32()?))
        }
    }













    impl ::std::default::Default for self::Date {
        fn default() -> Self {
            Self {
                year: ::std::default::Default::default(),
                month: ::std::default::Default::default(),
                day: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::Date {}
    unsafe impl ::std::marker::Sync for self::Date {}

    impl ::fbthrift::GetTType for self::Date {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::Date
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("Date");
            p.write_field_begin("year", ::fbthrift::TType::I16, 1);
            ::fbthrift::Serialize::write(&self.year, p);
            p.write_field_end();
            p.write_field_begin("month", ::fbthrift::TType::Byte, 2);
            ::fbthrift::Serialize::write(&self.month, p);
            p.write_field_end();
            p.write_field_begin("day", ::fbthrift::TType::Byte, 3);
            ::fbthrift::Serialize::write(&self.day, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::Date
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("day", ::fbthrift::TType::Byte, 3),
                ::fbthrift::Field::new("month", ::fbthrift::TType::Byte, 2),
                ::fbthrift::Field::new("year", ::fbthrift::TType::I16, 1),
            ];
            let mut field_year = ::std::option::Option::None;
            let mut field_month = ::std::option::Option::None;
            let mut field_day = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I16, 1) => field_year = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Byte, 2) => field_month = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Byte, 3) => field_day = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                year: field_year.unwrap_or_default(),
                month: field_month.unwrap_or_default(),
                day: field_day.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::Time {
        fn default() -> Self {
            Self {
                hour: ::std::default::Default::default(),
                minute: ::std::default::Default::default(),
                sec: ::std::default::Default::default(),
                microsec: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::Time {}
    unsafe impl ::std::marker::Sync for self::Time {}

    impl ::fbthrift::GetTType for self::Time {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::Time
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("Time");
            p.write_field_begin("hour", ::fbthrift::TType::Byte, 1);
            ::fbthrift::Serialize::write(&self.hour, p);
            p.write_field_end();
            p.write_field_begin("minute", ::fbthrift::TType::Byte, 2);
            ::fbthrift::Serialize::write(&self.minute, p);
            p.write_field_end();
            p.write_field_begin("sec", ::fbthrift::TType::Byte, 3);
            ::fbthrift::Serialize::write(&self.sec, p);
            p.write_field_end();
            p.write_field_begin("microsec", ::fbthrift::TType::I32, 4);
            ::fbthrift::Serialize::write(&self.microsec, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::Time
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("hour", ::fbthrift::TType::Byte, 1),
                ::fbthrift::Field::new("microsec", ::fbthrift::TType::I32, 4),
                ::fbthrift::Field::new("minute", ::fbthrift::TType::Byte, 2),
                ::fbthrift::Field::new("sec", ::fbthrift::TType::Byte, 3),
            ];
            let mut field_hour = ::std::option::Option::None;
            let mut field_minute = ::std::option::Option::None;
            let mut field_sec = ::std::option::Option::None;
            let mut field_microsec = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Byte, 1) => field_hour = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Byte, 2) => field_minute = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Byte, 3) => field_sec = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 4) => field_microsec = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                hour: field_hour.unwrap_or_default(),
                minute: field_minute.unwrap_or_default(),
                sec: field_sec.unwrap_or_default(),
                microsec: field_microsec.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::DateTime {
        fn default() -> Self {
            Self {
                year: ::std::default::Default::default(),
                month: ::std::default::Default::default(),
                day: ::std::default::Default::default(),
                hour: ::std::default::Default::default(),
                minute: ::std::default::Default::default(),
                sec: ::std::default::Default::default(),
                microsec: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::DateTime {}
    unsafe impl ::std::marker::Sync for self::DateTime {}

    impl ::fbthrift::GetTType for self::DateTime {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::DateTime
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("DateTime");
            p.write_field_begin("year", ::fbthrift::TType::I16, 1);
            ::fbthrift::Serialize::write(&self.year, p);
            p.write_field_end();
            p.write_field_begin("month", ::fbthrift::TType::Byte, 2);
            ::fbthrift::Serialize::write(&self.month, p);
            p.write_field_end();
            p.write_field_begin("day", ::fbthrift::TType::Byte, 3);
            ::fbthrift::Serialize::write(&self.day, p);
            p.write_field_end();
            p.write_field_begin("hour", ::fbthrift::TType::Byte, 4);
            ::fbthrift::Serialize::write(&self.hour, p);
            p.write_field_end();
            p.write_field_begin("minute", ::fbthrift::TType::Byte, 5);
            ::fbthrift::Serialize::write(&self.minute, p);
            p.write_field_end();
            p.write_field_begin("sec", ::fbthrift::TType::Byte, 6);
            ::fbthrift::Serialize::write(&self.sec, p);
            p.write_field_end();
            p.write_field_begin("microsec", ::fbthrift::TType::I32, 7);
            ::fbthrift::Serialize::write(&self.microsec, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::DateTime
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("day", ::fbthrift::TType::Byte, 3),
                ::fbthrift::Field::new("hour", ::fbthrift::TType::Byte, 4),
                ::fbthrift::Field::new("microsec", ::fbthrift::TType::I32, 7),
                ::fbthrift::Field::new("minute", ::fbthrift::TType::Byte, 5),
                ::fbthrift::Field::new("month", ::fbthrift::TType::Byte, 2),
                ::fbthrift::Field::new("sec", ::fbthrift::TType::Byte, 6),
                ::fbthrift::Field::new("year", ::fbthrift::TType::I16, 1),
            ];
            let mut field_year = ::std::option::Option::None;
            let mut field_month = ::std::option::Option::None;
            let mut field_day = ::std::option::Option::None;
            let mut field_hour = ::std::option::Option::None;
            let mut field_minute = ::std::option::Option::None;
            let mut field_sec = ::std::option::Option::None;
            let mut field_microsec = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I16, 1) => field_year = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Byte, 2) => field_month = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Byte, 3) => field_day = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Byte, 4) => field_hour = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Byte, 5) => field_minute = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Byte, 6) => field_sec = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 7) => field_microsec = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                year: field_year.unwrap_or_default(),
                month: field_month.unwrap_or_default(),
                day: field_day.unwrap_or_default(),
                hour: field_hour.unwrap_or_default(),
                minute: field_minute.unwrap_or_default(),
                sec: field_sec.unwrap_or_default(),
                microsec: field_microsec.unwrap_or_default(),
            })
        }
    }



    impl ::std::default::Default for Value {
        fn default() -> Self {
            Self::UnknownField(-1)
        }
    }

    impl ::fbthrift::GetTType for Value {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for Value
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("Value");
            match self {
                Value::nVal(inner) => {
                    p.write_field_begin("nVal", ::fbthrift::TType::I32, 1);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                Value::bVal(inner) => {
                    p.write_field_begin("bVal", ::fbthrift::TType::Bool, 2);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                Value::iVal(inner) => {
                    p.write_field_begin("iVal", ::fbthrift::TType::I64, 3);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                Value::fVal(inner) => {
                    p.write_field_begin("fVal", ::fbthrift::TType::Double, 4);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                Value::sVal(inner) => {
                    p.write_field_begin("sVal", ::fbthrift::TType::String, 5);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                Value::dVal(inner) => {
                    p.write_field_begin("dVal", ::fbthrift::TType::Struct, 6);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                Value::tVal(inner) => {
                    p.write_field_begin("tVal", ::fbthrift::TType::Struct, 7);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                Value::dtVal(inner) => {
                    p.write_field_begin("dtVal", ::fbthrift::TType::Struct, 8);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                Value::vVal(inner) => {
                    p.write_field_begin("vVal", ::fbthrift::TType::Struct, 9);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                Value::eVal(inner) => {
                    p.write_field_begin("eVal", ::fbthrift::TType::Struct, 10);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                Value::pVal(inner) => {
                    p.write_field_begin("pVal", ::fbthrift::TType::Struct, 11);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                Value::lVal(inner) => {
                    p.write_field_begin("lVal", ::fbthrift::TType::Struct, 12);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                Value::mVal(inner) => {
                    p.write_field_begin("mVal", ::fbthrift::TType::Struct, 13);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                Value::uVal(inner) => {
                    p.write_field_begin("uVal", ::fbthrift::TType::Struct, 14);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                Value::gVal(inner) => {
                    p.write_field_begin("gVal", ::fbthrift::TType::Struct, 15);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                Value::UnknownField(x) => {
                    p.write_field_begin("UnknownField", ::fbthrift::TType::I32, *x as ::std::primitive::i16);
                    x.write(p);
                    p.write_field_end();
                }
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for Value
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("bVal", ::fbthrift::TType::Bool, 2),
                ::fbthrift::Field::new("dVal", ::fbthrift::TType::Struct, 6),
                ::fbthrift::Field::new("dtVal", ::fbthrift::TType::Struct, 8),
                ::fbthrift::Field::new("eVal", ::fbthrift::TType::Struct, 10),
                ::fbthrift::Field::new("fVal", ::fbthrift::TType::Double, 4),
                ::fbthrift::Field::new("gVal", ::fbthrift::TType::Struct, 15),
                ::fbthrift::Field::new("iVal", ::fbthrift::TType::I64, 3),
                ::fbthrift::Field::new("lVal", ::fbthrift::TType::Struct, 12),
                ::fbthrift::Field::new("mVal", ::fbthrift::TType::Struct, 13),
                ::fbthrift::Field::new("nVal", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("pVal", ::fbthrift::TType::Struct, 11),
                ::fbthrift::Field::new("sVal", ::fbthrift::TType::String, 5),
                ::fbthrift::Field::new("tVal", ::fbthrift::TType::Struct, 7),
                ::fbthrift::Field::new("uVal", ::fbthrift::TType::Struct, 14),
                ::fbthrift::Field::new("vVal", ::fbthrift::TType::Struct, 9),
            ];
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::option::Option::None;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32, once) {
                    (::fbthrift::TType::Stop, _, _) => break,
                    (::fbthrift::TType::I32, 1, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(Value::nVal(::fbthrift::Deserialize::read(p)?));
                    }
                    (::fbthrift::TType::Bool, 2, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(Value::bVal(::fbthrift::Deserialize::read(p)?));
                    }
                    (::fbthrift::TType::I64, 3, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(Value::iVal(::fbthrift::Deserialize::read(p)?));
                    }
                    (::fbthrift::TType::Double, 4, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(Value::fVal(::fbthrift::Deserialize::read(p)?));
                    }
                    (::fbthrift::TType::String, 5, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(Value::sVal(::fbthrift::Deserialize::read(p)?));
                    }
                    (::fbthrift::TType::Struct, 6, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(Value::dVal(::fbthrift::Deserialize::read(p)?));
                    }
                    (::fbthrift::TType::Struct, 7, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(Value::tVal(::fbthrift::Deserialize::read(p)?));
                    }
                    (::fbthrift::TType::Struct, 8, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(Value::dtVal(::fbthrift::Deserialize::read(p)?));
                    }
                    (::fbthrift::TType::Struct, 9, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(Value::vVal(::fbthrift::Deserialize::read(p)?));
                    }
                    (::fbthrift::TType::Struct, 10, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(Value::eVal(::fbthrift::Deserialize::read(p)?));
                    }
                    (::fbthrift::TType::Struct, 11, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(Value::pVal(::fbthrift::Deserialize::read(p)?));
                    }
                    (::fbthrift::TType::Struct, 12, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(Value::lVal(::fbthrift::Deserialize::read(p)?));
                    }
                    (::fbthrift::TType::Struct, 13, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(Value::mVal(::fbthrift::Deserialize::read(p)?));
                    }
                    (::fbthrift::TType::Struct, 14, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(Value::uVal(::fbthrift::Deserialize::read(p)?));
                    }
                    (::fbthrift::TType::Struct, 15, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(Value::gVal(::fbthrift::Deserialize::read(p)?));
                    }
                    (fty, _, false) => p.skip(fty)?,
                    (badty, badid, true) => return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                        format!(
                            "unwanted extra union {} field ty {:?} id {}",
                            "Value",
                            badty,
                            badid,
                        ),
                    ))),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(alt.unwrap_or_default())
        }
    }

    impl ::std::default::Default for self::NList {
        fn default() -> Self {
            Self {
                values: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::NList {}
    unsafe impl ::std::marker::Sync for self::NList {}

    impl ::fbthrift::GetTType for self::NList {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::NList
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("NList");
            p.write_field_begin("values", ::fbthrift::TType::List, 1);
            ::fbthrift::Serialize::write(&self.values, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::NList
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("values", ::fbthrift::TType::List, 1),
            ];
            let mut field_values = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::List, 1) => field_values = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                values: field_values.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::NMap {
        fn default() -> Self {
            Self {
                kvs: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::NMap {}
    unsafe impl ::std::marker::Sync for self::NMap {}

    impl ::fbthrift::GetTType for self::NMap {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::NMap
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("NMap");
            p.write_field_begin("kvs", ::fbthrift::TType::Map, 1);
            ::fbthrift::Serialize::write(&self.kvs, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::NMap
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("kvs", ::fbthrift::TType::Map, 1),
            ];
            let mut field_kvs = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Map, 1) => field_kvs = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                kvs: field_kvs.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::NSet {
        fn default() -> Self {
            Self {
                values: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::NSet {}
    unsafe impl ::std::marker::Sync for self::NSet {}

    impl ::fbthrift::GetTType for self::NSet {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::NSet
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("NSet");
            p.write_field_begin("values", ::fbthrift::TType::Set, 1);
            ::fbthrift::Serialize::write(&self.values, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::NSet
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("values", ::fbthrift::TType::Set, 1),
            ];
            let mut field_values = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Set, 1) => field_values = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                values: field_values.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::Row {
        fn default() -> Self {
            Self {
                values: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::Row {}
    unsafe impl ::std::marker::Sync for self::Row {}

    impl ::fbthrift::GetTType for self::Row {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::Row
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("Row");
            p.write_field_begin("values", ::fbthrift::TType::List, 1);
            ::fbthrift::Serialize::write(&self.values, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::Row
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("values", ::fbthrift::TType::List, 1),
            ];
            let mut field_values = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::List, 1) => field_values = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                values: field_values.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::DataSet {
        fn default() -> Self {
            Self {
                column_names: ::std::default::Default::default(),
                rows: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::DataSet {}
    unsafe impl ::std::marker::Sync for self::DataSet {}

    impl ::fbthrift::GetTType for self::DataSet {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::DataSet
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("DataSet");
            p.write_field_begin("column_names", ::fbthrift::TType::List, 1);
            ::fbthrift::Serialize::write(&self.column_names, p);
            p.write_field_end();
            p.write_field_begin("rows", ::fbthrift::TType::List, 2);
            ::fbthrift::Serialize::write(&self.rows, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::DataSet
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("column_names", ::fbthrift::TType::List, 1),
                ::fbthrift::Field::new("rows", ::fbthrift::TType::List, 2),
            ];
            let mut field_column_names = ::std::option::Option::None;
            let mut field_rows = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::List, 1) => field_column_names = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 2) => field_rows = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                column_names: field_column_names.unwrap_or_default(),
                rows: field_rows.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::Tag {
        fn default() -> Self {
            Self {
                name: ::std::default::Default::default(),
                props: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::Tag {}
    unsafe impl ::std::marker::Sync for self::Tag {}

    impl ::fbthrift::GetTType for self::Tag {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::Tag
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("Tag");
            p.write_field_begin("name", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.name, p);
            p.write_field_end();
            p.write_field_begin("props", ::fbthrift::TType::Map, 2);
            ::fbthrift::Serialize::write(&self.props, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::Tag
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("name", ::fbthrift::TType::String, 1),
                ::fbthrift::Field::new("props", ::fbthrift::TType::Map, 2),
            ];
            let mut field_name = ::std::option::Option::None;
            let mut field_props = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 2) => field_props = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                name: field_name.unwrap_or_default(),
                props: field_props.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::Vertex {
        fn default() -> Self {
            Self {
                vid: ::std::default::Default::default(),
                tags: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::Vertex {}
    unsafe impl ::std::marker::Sync for self::Vertex {}

    impl ::fbthrift::GetTType for self::Vertex {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::Vertex
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("Vertex");
            p.write_field_begin("vid", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(&self.vid, p);
            p.write_field_end();
            p.write_field_begin("tags", ::fbthrift::TType::List, 2);
            ::fbthrift::Serialize::write(&self.tags, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::Vertex
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("tags", ::fbthrift::TType::List, 2),
                ::fbthrift::Field::new("vid", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_vid = ::std::option::Option::None;
            let mut field_tags = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_vid = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 2) => field_tags = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                vid: field_vid.unwrap_or_default(),
                tags: field_tags.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::Edge {
        fn default() -> Self {
            Self {
                src: ::std::default::Default::default(),
                dst: ::std::default::Default::default(),
                type_: ::std::default::Default::default(),
                name: ::std::default::Default::default(),
                ranking: ::std::default::Default::default(),
                props: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::Edge {}
    unsafe impl ::std::marker::Sync for self::Edge {}

    impl ::fbthrift::GetTType for self::Edge {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::Edge
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("Edge");
            p.write_field_begin("src", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(&self.src, p);
            p.write_field_end();
            p.write_field_begin("dst", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.dst, p);
            p.write_field_end();
            p.write_field_begin("type", ::fbthrift::TType::I32, 3);
            ::fbthrift::Serialize::write(&self.type_, p);
            p.write_field_end();
            p.write_field_begin("name", ::fbthrift::TType::String, 4);
            ::fbthrift::Serialize::write(&self.name, p);
            p.write_field_end();
            p.write_field_begin("ranking", ::fbthrift::TType::I64, 5);
            ::fbthrift::Serialize::write(&self.ranking, p);
            p.write_field_end();
            p.write_field_begin("props", ::fbthrift::TType::Map, 6);
            ::fbthrift::Serialize::write(&self.props, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::Edge
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("dst", ::fbthrift::TType::Struct, 2),
                ::fbthrift::Field::new("name", ::fbthrift::TType::String, 4),
                ::fbthrift::Field::new("props", ::fbthrift::TType::Map, 6),
                ::fbthrift::Field::new("ranking", ::fbthrift::TType::I64, 5),
                ::fbthrift::Field::new("src", ::fbthrift::TType::Struct, 1),
                ::fbthrift::Field::new("type", ::fbthrift::TType::I32, 3),
            ];
            let mut field_src = ::std::option::Option::None;
            let mut field_dst = ::std::option::Option::None;
            let mut field_type = ::std::option::Option::None;
            let mut field_name = ::std::option::Option::None;
            let mut field_ranking = ::std::option::Option::None;
            let mut field_props = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_src = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_dst = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 3) => field_type = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 4) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 5) => field_ranking = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 6) => field_props = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                src: field_src.unwrap_or_default(),
                dst: field_dst.unwrap_or_default(),
                type_: field_type.unwrap_or_default(),
                name: field_name.unwrap_or_default(),
                ranking: field_ranking.unwrap_or_default(),
                props: field_props.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::Step {
        fn default() -> Self {
            Self {
                dst: ::std::default::Default::default(),
                type_: ::std::default::Default::default(),
                name: ::std::default::Default::default(),
                ranking: ::std::default::Default::default(),
                props: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::Step {}
    unsafe impl ::std::marker::Sync for self::Step {}

    impl ::fbthrift::GetTType for self::Step {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::Step
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("Step");
            p.write_field_begin("dst", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(&self.dst, p);
            p.write_field_end();
            p.write_field_begin("type", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.type_, p);
            p.write_field_end();
            p.write_field_begin("name", ::fbthrift::TType::String, 3);
            ::fbthrift::Serialize::write(&self.name, p);
            p.write_field_end();
            p.write_field_begin("ranking", ::fbthrift::TType::I64, 4);
            ::fbthrift::Serialize::write(&self.ranking, p);
            p.write_field_end();
            p.write_field_begin("props", ::fbthrift::TType::Map, 5);
            ::fbthrift::Serialize::write(&self.props, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::Step
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("dst", ::fbthrift::TType::Struct, 1),
                ::fbthrift::Field::new("name", ::fbthrift::TType::String, 3),
                ::fbthrift::Field::new("props", ::fbthrift::TType::Map, 5),
                ::fbthrift::Field::new("ranking", ::fbthrift::TType::I64, 4),
                ::fbthrift::Field::new("type", ::fbthrift::TType::I32, 2),
            ];
            let mut field_dst = ::std::option::Option::None;
            let mut field_type = ::std::option::Option::None;
            let mut field_name = ::std::option::Option::None;
            let mut field_ranking = ::std::option::Option::None;
            let mut field_props = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_dst = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_type = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 3) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 4) => field_ranking = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 5) => field_props = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                dst: field_dst.unwrap_or_default(),
                type_: field_type.unwrap_or_default(),
                name: field_name.unwrap_or_default(),
                ranking: field_ranking.unwrap_or_default(),
                props: field_props.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::Path {
        fn default() -> Self {
            Self {
                src: ::std::default::Default::default(),
                steps: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::Path {}
    unsafe impl ::std::marker::Sync for self::Path {}

    impl ::fbthrift::GetTType for self::Path {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::Path
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("Path");
            p.write_field_begin("src", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(&self.src, p);
            p.write_field_end();
            p.write_field_begin("steps", ::fbthrift::TType::List, 2);
            ::fbthrift::Serialize::write(&self.steps, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::Path
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("src", ::fbthrift::TType::Struct, 1),
                ::fbthrift::Field::new("steps", ::fbthrift::TType::List, 2),
            ];
            let mut field_src = ::std::option::Option::None;
            let mut field_steps = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_src = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 2) => field_steps = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                src: field_src.unwrap_or_default(),
                steps: field_steps.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::HostAddr {
        fn default() -> Self {
            Self {
                host: ::std::default::Default::default(),
                port: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::HostAddr {}
    unsafe impl ::std::marker::Sync for self::HostAddr {}

    impl ::fbthrift::GetTType for self::HostAddr {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::HostAddr
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("HostAddr");
            p.write_field_begin("host", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.host, p);
            p.write_field_end();
            p.write_field_begin("port", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.port, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::HostAddr
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("host", ::fbthrift::TType::String, 1),
                ::fbthrift::Field::new("port", ::fbthrift::TType::I32, 2),
            ];
            let mut field_host = ::std::option::Option::None;
            let mut field_port = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_host = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_port = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                host: field_host.unwrap_or_default(),
                port: field_port.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::KeyValue {
        fn default() -> Self {
            Self {
                key: ::std::default::Default::default(),
                value: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::KeyValue {}
    unsafe impl ::std::marker::Sync for self::KeyValue {}

    impl ::fbthrift::GetTType for self::KeyValue {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::KeyValue
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("KeyValue");
            p.write_field_begin("key", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.key, p);
            p.write_field_end();
            p.write_field_begin("value", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.value, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::KeyValue
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("key", ::fbthrift::TType::String, 1),
                ::fbthrift::Field::new("value", ::fbthrift::TType::String, 2),
            ];
            let mut field_key = ::std::option::Option::None;
            let mut field_value = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_key = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_value = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                key: field_key.unwrap_or_default(),
                value: field_value.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::LogInfo {
        fn default() -> Self {
            Self {
                log_id: ::std::default::Default::default(),
                term_id: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::LogInfo {}
    unsafe impl ::std::marker::Sync for self::LogInfo {}

    impl ::fbthrift::GetTType for self::LogInfo {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::LogInfo
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("LogInfo");
            p.write_field_begin("log_id", ::fbthrift::TType::I64, 1);
            ::fbthrift::Serialize::write(&self.log_id, p);
            p.write_field_end();
            p.write_field_begin("term_id", ::fbthrift::TType::I64, 2);
            ::fbthrift::Serialize::write(&self.term_id, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::LogInfo
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("log_id", ::fbthrift::TType::I64, 1),
                ::fbthrift::Field::new("term_id", ::fbthrift::TType::I64, 2),
            ];
            let mut field_log_id = ::std::option::Option::None;
            let mut field_term_id = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I64, 1) => field_log_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 2) => field_term_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                log_id: field_log_id.unwrap_or_default(),
                term_id: field_term_id.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::DirInfo {
        fn default() -> Self {
            Self {
                root: ::std::default::Default::default(),
                data: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::DirInfo {}
    unsafe impl ::std::marker::Sync for self::DirInfo {}

    impl ::fbthrift::GetTType for self::DirInfo {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::DirInfo
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("DirInfo");
            p.write_field_begin("root", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.root, p);
            p.write_field_end();
            p.write_field_begin("data", ::fbthrift::TType::List, 2);
            ::fbthrift::Serialize::write(&self.data, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::DirInfo
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("data", ::fbthrift::TType::List, 2),
                ::fbthrift::Field::new("root", ::fbthrift::TType::String, 1),
            ];
            let mut field_root = ::std::option::Option::None;
            let mut field_data = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_root = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 2) => field_data = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                root: field_root.unwrap_or_default(),
                data: field_data.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::NodeInfo {
        fn default() -> Self {
            Self {
                host: ::std::default::Default::default(),
                dir: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::NodeInfo {}
    unsafe impl ::std::marker::Sync for self::NodeInfo {}

    impl ::fbthrift::GetTType for self::NodeInfo {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::NodeInfo
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("NodeInfo");
            p.write_field_begin("host", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(&self.host, p);
            p.write_field_end();
            p.write_field_begin("dir", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.dir, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::NodeInfo
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("dir", ::fbthrift::TType::Struct, 2),
                ::fbthrift::Field::new("host", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_host = ::std::option::Option::None;
            let mut field_dir = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_host = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_dir = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                host: field_host.unwrap_or_default(),
                dir: field_dir.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::PartitionBackupInfo {
        fn default() -> Self {
            Self {
                info: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::PartitionBackupInfo {}
    unsafe impl ::std::marker::Sync for self::PartitionBackupInfo {}

    impl ::fbthrift::GetTType for self::PartitionBackupInfo {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::PartitionBackupInfo
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("PartitionBackupInfo");
            p.write_field_begin("info", ::fbthrift::TType::Map, 1);
            ::fbthrift::Serialize::write(&self.info, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::PartitionBackupInfo
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("info", ::fbthrift::TType::Map, 1),
            ];
            let mut field_info = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Map, 1) => field_info = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                info: field_info.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::CheckpointInfo {
        fn default() -> Self {
            Self {
                partition_info: ::std::default::Default::default(),
                path: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::CheckpointInfo {}
    unsafe impl ::std::marker::Sync for self::CheckpointInfo {}

    impl ::fbthrift::GetTType for self::CheckpointInfo {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::CheckpointInfo
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("CheckpointInfo");
            p.write_field_begin("partition_info", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(&self.partition_info, p);
            p.write_field_end();
            p.write_field_begin("path", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.path, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::CheckpointInfo
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("partition_info", ::fbthrift::TType::Struct, 1),
                ::fbthrift::Field::new("path", ::fbthrift::TType::String, 2),
            ];
            let mut field_partition_info = ::std::option::Option::None;
            let mut field_path = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_partition_info = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_path = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                partition_info: field_partition_info.unwrap_or_default(),
                path: field_path.unwrap_or_default(),
            })
        }
    }

}

pub mod errors {
}

pub mod double;
