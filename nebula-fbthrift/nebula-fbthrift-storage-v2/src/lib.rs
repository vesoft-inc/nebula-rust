// @generated by Thrift for src/interface/storage.thrift
// This file is probably not the place you want to edit!

#![recursion_limit = "100000000"]
#![allow(bare_trait_objects)]
#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals, unused_crate_dependencies, clippy::all)]

pub use self::errors::*;
pub use self::types::*;

pub mod types;

#[doc(hidden)]
pub mod dependencies {
    pub use common as common;
    pub use meta as meta;
}

pub mod services {
    pub mod graph_storage_service {
        #[derive(Clone, Debug)]
        pub enum GetNeighborsExn {
            #[doc(hidden)]
            Success(crate::types::GetNeighborsResponse),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::graph_storage_service::GetNeighborsError> for GetNeighborsExn {
            fn from(err: crate::errors::graph_storage_service::GetNeighborsError) -> Self {
                match err {
                    crate::errors::graph_storage_service::GetNeighborsError::ApplicationException(aexn) => GetNeighborsExn::ApplicationException(aexn),
                    crate::errors::graph_storage_service::GetNeighborsError::ThriftError(err) => GetNeighborsExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetNeighborsExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for GetNeighborsExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for GetNeighborsExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for GetNeighborsExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetNeighborsExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetNeighbors");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetNeighborsExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetNeighborsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetNeighborsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetPropsExn {
            #[doc(hidden)]
            Success(crate::types::GetPropResponse),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::graph_storage_service::GetPropsError> for GetPropsExn {
            fn from(err: crate::errors::graph_storage_service::GetPropsError) -> Self {
                match err {
                    crate::errors::graph_storage_service::GetPropsError::ApplicationException(aexn) => GetPropsExn::ApplicationException(aexn),
                    crate::errors::graph_storage_service::GetPropsError::ThriftError(err) => GetPropsExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetPropsExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for GetPropsExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for GetPropsExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for GetPropsExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetPropsExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetProps");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetPropsExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetPropsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetPropsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum AddVerticesExn {
            #[doc(hidden)]
            Success(crate::types::ExecResponse),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::graph_storage_service::AddVerticesError> for AddVerticesExn {
            fn from(err: crate::errors::graph_storage_service::AddVerticesError) -> Self {
                match err {
                    crate::errors::graph_storage_service::AddVerticesError::ApplicationException(aexn) => AddVerticesExn::ApplicationException(aexn),
                    crate::errors::graph_storage_service::AddVerticesError::ThriftError(err) => AddVerticesExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for AddVerticesExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for AddVerticesExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for AddVerticesExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for AddVerticesExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for AddVerticesExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("AddVertices");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for AddVerticesExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "AddVerticesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "AddVerticesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum AddEdgesExn {
            #[doc(hidden)]
            Success(crate::types::ExecResponse),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::graph_storage_service::AddEdgesError> for AddEdgesExn {
            fn from(err: crate::errors::graph_storage_service::AddEdgesError) -> Self {
                match err {
                    crate::errors::graph_storage_service::AddEdgesError::ApplicationException(aexn) => AddEdgesExn::ApplicationException(aexn),
                    crate::errors::graph_storage_service::AddEdgesError::ThriftError(err) => AddEdgesExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for AddEdgesExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for AddEdgesExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for AddEdgesExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for AddEdgesExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for AddEdgesExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("AddEdges");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for AddEdgesExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "AddEdgesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "AddEdgesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DeleteEdgesExn {
            #[doc(hidden)]
            Success(crate::types::ExecResponse),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::graph_storage_service::DeleteEdgesError> for DeleteEdgesExn {
            fn from(err: crate::errors::graph_storage_service::DeleteEdgesError) -> Self {
                match err {
                    crate::errors::graph_storage_service::DeleteEdgesError::ApplicationException(aexn) => DeleteEdgesExn::ApplicationException(aexn),
                    crate::errors::graph_storage_service::DeleteEdgesError::ThriftError(err) => DeleteEdgesExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DeleteEdgesExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for DeleteEdgesExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for DeleteEdgesExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for DeleteEdgesExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DeleteEdgesExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("DeleteEdges");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DeleteEdgesExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DeleteEdgesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DeleteEdgesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DeleteVerticesExn {
            #[doc(hidden)]
            Success(crate::types::ExecResponse),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::graph_storage_service::DeleteVerticesError> for DeleteVerticesExn {
            fn from(err: crate::errors::graph_storage_service::DeleteVerticesError) -> Self {
                match err {
                    crate::errors::graph_storage_service::DeleteVerticesError::ApplicationException(aexn) => DeleteVerticesExn::ApplicationException(aexn),
                    crate::errors::graph_storage_service::DeleteVerticesError::ThriftError(err) => DeleteVerticesExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DeleteVerticesExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for DeleteVerticesExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for DeleteVerticesExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for DeleteVerticesExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DeleteVerticesExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("DeleteVertices");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DeleteVerticesExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DeleteVerticesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DeleteVerticesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DeleteTagsExn {
            #[doc(hidden)]
            Success(crate::types::ExecResponse),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::graph_storage_service::DeleteTagsError> for DeleteTagsExn {
            fn from(err: crate::errors::graph_storage_service::DeleteTagsError) -> Self {
                match err {
                    crate::errors::graph_storage_service::DeleteTagsError::ApplicationException(aexn) => DeleteTagsExn::ApplicationException(aexn),
                    crate::errors::graph_storage_service::DeleteTagsError::ThriftError(err) => DeleteTagsExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DeleteTagsExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for DeleteTagsExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for DeleteTagsExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for DeleteTagsExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DeleteTagsExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("DeleteTags");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DeleteTagsExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DeleteTagsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DeleteTagsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum UpdateVertexExn {
            #[doc(hidden)]
            Success(crate::types::UpdateResponse),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::graph_storage_service::UpdateVertexError> for UpdateVertexExn {
            fn from(err: crate::errors::graph_storage_service::UpdateVertexError) -> Self {
                match err {
                    crate::errors::graph_storage_service::UpdateVertexError::ApplicationException(aexn) => UpdateVertexExn::ApplicationException(aexn),
                    crate::errors::graph_storage_service::UpdateVertexError::ThriftError(err) => UpdateVertexExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for UpdateVertexExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for UpdateVertexExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for UpdateVertexExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for UpdateVertexExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for UpdateVertexExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("UpdateVertex");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for UpdateVertexExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "UpdateVertexExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "UpdateVertexExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum UpdateEdgeExn {
            #[doc(hidden)]
            Success(crate::types::UpdateResponse),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::graph_storage_service::UpdateEdgeError> for UpdateEdgeExn {
            fn from(err: crate::errors::graph_storage_service::UpdateEdgeError) -> Self {
                match err {
                    crate::errors::graph_storage_service::UpdateEdgeError::ApplicationException(aexn) => UpdateEdgeExn::ApplicationException(aexn),
                    crate::errors::graph_storage_service::UpdateEdgeError::ThriftError(err) => UpdateEdgeExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for UpdateEdgeExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for UpdateEdgeExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for UpdateEdgeExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for UpdateEdgeExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for UpdateEdgeExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("UpdateEdge");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for UpdateEdgeExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "UpdateEdgeExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "UpdateEdgeExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ScanVertexExn {
            #[doc(hidden)]
            Success(crate::types::ScanVertexResponse),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::graph_storage_service::ScanVertexError> for ScanVertexExn {
            fn from(err: crate::errors::graph_storage_service::ScanVertexError) -> Self {
                match err {
                    crate::errors::graph_storage_service::ScanVertexError::ApplicationException(aexn) => ScanVertexExn::ApplicationException(aexn),
                    crate::errors::graph_storage_service::ScanVertexError::ThriftError(err) => ScanVertexExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ScanVertexExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for ScanVertexExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for ScanVertexExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for ScanVertexExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ScanVertexExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ScanVertex");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ScanVertexExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ScanVertexExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ScanVertexExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ScanEdgeExn {
            #[doc(hidden)]
            Success(crate::types::ScanEdgeResponse),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::graph_storage_service::ScanEdgeError> for ScanEdgeExn {
            fn from(err: crate::errors::graph_storage_service::ScanEdgeError) -> Self {
                match err {
                    crate::errors::graph_storage_service::ScanEdgeError::ApplicationException(aexn) => ScanEdgeExn::ApplicationException(aexn),
                    crate::errors::graph_storage_service::ScanEdgeError::ThriftError(err) => ScanEdgeExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ScanEdgeExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for ScanEdgeExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for ScanEdgeExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for ScanEdgeExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ScanEdgeExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ScanEdge");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ScanEdgeExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ScanEdgeExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ScanEdgeExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetUUIDExn {
            #[doc(hidden)]
            Success(crate::types::GetUUIDResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::graph_storage_service::GetUUIDError> for GetUUIDExn {
            fn from(err: crate::errors::graph_storage_service::GetUUIDError) -> Self {
                match err {
                    crate::errors::graph_storage_service::GetUUIDError::ApplicationException(aexn) => GetUUIDExn::ApplicationException(aexn),
                    crate::errors::graph_storage_service::GetUUIDError::ThriftError(err) => GetUUIDExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetUUIDExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for GetUUIDExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for GetUUIDExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for GetUUIDExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetUUIDExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetUUID");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetUUIDExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetUUIDExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetUUIDExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum LookupIndexExn {
            #[doc(hidden)]
            Success(crate::types::LookupIndexResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::graph_storage_service::LookupIndexError> for LookupIndexExn {
            fn from(err: crate::errors::graph_storage_service::LookupIndexError) -> Self {
                match err {
                    crate::errors::graph_storage_service::LookupIndexError::ApplicationException(aexn) => LookupIndexExn::ApplicationException(aexn),
                    crate::errors::graph_storage_service::LookupIndexError::ThriftError(err) => LookupIndexExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for LookupIndexExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for LookupIndexExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for LookupIndexExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for LookupIndexExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for LookupIndexExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("LookupIndex");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for LookupIndexExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "LookupIndexExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "LookupIndexExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum LookupAndTraverseExn {
            #[doc(hidden)]
            Success(crate::types::GetNeighborsResponse),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::graph_storage_service::LookupAndTraverseError> for LookupAndTraverseExn {
            fn from(err: crate::errors::graph_storage_service::LookupAndTraverseError) -> Self {
                match err {
                    crate::errors::graph_storage_service::LookupAndTraverseError::ApplicationException(aexn) => LookupAndTraverseExn::ApplicationException(aexn),
                    crate::errors::graph_storage_service::LookupAndTraverseError::ThriftError(err) => LookupAndTraverseExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for LookupAndTraverseExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for LookupAndTraverseExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for LookupAndTraverseExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for LookupAndTraverseExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for LookupAndTraverseExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("LookupAndTraverse");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for LookupAndTraverseExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "LookupAndTraverseExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "LookupAndTraverseExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ChainUpdateEdgeExn {
            #[doc(hidden)]
            Success(crate::types::UpdateResponse),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::graph_storage_service::ChainUpdateEdgeError> for ChainUpdateEdgeExn {
            fn from(err: crate::errors::graph_storage_service::ChainUpdateEdgeError) -> Self {
                match err {
                    crate::errors::graph_storage_service::ChainUpdateEdgeError::ApplicationException(aexn) => ChainUpdateEdgeExn::ApplicationException(aexn),
                    crate::errors::graph_storage_service::ChainUpdateEdgeError::ThriftError(err) => ChainUpdateEdgeExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ChainUpdateEdgeExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for ChainUpdateEdgeExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for ChainUpdateEdgeExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for ChainUpdateEdgeExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ChainUpdateEdgeExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ChainUpdateEdge");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ChainUpdateEdgeExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ChainUpdateEdgeExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ChainUpdateEdgeExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ChainAddEdgesExn {
            #[doc(hidden)]
            Success(crate::types::ExecResponse),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::graph_storage_service::ChainAddEdgesError> for ChainAddEdgesExn {
            fn from(err: crate::errors::graph_storage_service::ChainAddEdgesError) -> Self {
                match err {
                    crate::errors::graph_storage_service::ChainAddEdgesError::ApplicationException(aexn) => ChainAddEdgesExn::ApplicationException(aexn),
                    crate::errors::graph_storage_service::ChainAddEdgesError::ThriftError(err) => ChainAddEdgesExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ChainAddEdgesExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for ChainAddEdgesExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for ChainAddEdgesExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for ChainAddEdgesExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ChainAddEdgesExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ChainAddEdges");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ChainAddEdgesExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ChainAddEdgesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ChainAddEdgesExn"),
                    )
                    .into(),
                )
            }
        }
    }

    pub mod storage_admin_service {
        #[derive(Clone, Debug)]
        pub enum TransLeaderExn {
            #[doc(hidden)]
            Success(crate::types::AdminExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::storage_admin_service::TransLeaderError> for TransLeaderExn {
            fn from(err: crate::errors::storage_admin_service::TransLeaderError) -> Self {
                match err {
                    crate::errors::storage_admin_service::TransLeaderError::ApplicationException(aexn) => TransLeaderExn::ApplicationException(aexn),
                    crate::errors::storage_admin_service::TransLeaderError::ThriftError(err) => TransLeaderExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for TransLeaderExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for TransLeaderExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for TransLeaderExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for TransLeaderExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for TransLeaderExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("TransLeader");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for TransLeaderExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "TransLeaderExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "TransLeaderExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum AddPartExn {
            #[doc(hidden)]
            Success(crate::types::AdminExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::storage_admin_service::AddPartError> for AddPartExn {
            fn from(err: crate::errors::storage_admin_service::AddPartError) -> Self {
                match err {
                    crate::errors::storage_admin_service::AddPartError::ApplicationException(aexn) => AddPartExn::ApplicationException(aexn),
                    crate::errors::storage_admin_service::AddPartError::ThriftError(err) => AddPartExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for AddPartExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for AddPartExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for AddPartExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for AddPartExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for AddPartExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("AddPart");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for AddPartExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "AddPartExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "AddPartExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum AddLearnerExn {
            #[doc(hidden)]
            Success(crate::types::AdminExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::storage_admin_service::AddLearnerError> for AddLearnerExn {
            fn from(err: crate::errors::storage_admin_service::AddLearnerError) -> Self {
                match err {
                    crate::errors::storage_admin_service::AddLearnerError::ApplicationException(aexn) => AddLearnerExn::ApplicationException(aexn),
                    crate::errors::storage_admin_service::AddLearnerError::ThriftError(err) => AddLearnerExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for AddLearnerExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for AddLearnerExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for AddLearnerExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for AddLearnerExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for AddLearnerExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("AddLearner");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for AddLearnerExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "AddLearnerExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "AddLearnerExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum RemovePartExn {
            #[doc(hidden)]
            Success(crate::types::AdminExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::storage_admin_service::RemovePartError> for RemovePartExn {
            fn from(err: crate::errors::storage_admin_service::RemovePartError) -> Self {
                match err {
                    crate::errors::storage_admin_service::RemovePartError::ApplicationException(aexn) => RemovePartExn::ApplicationException(aexn),
                    crate::errors::storage_admin_service::RemovePartError::ThriftError(err) => RemovePartExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for RemovePartExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for RemovePartExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for RemovePartExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for RemovePartExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for RemovePartExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("RemovePart");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for RemovePartExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "RemovePartExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "RemovePartExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum MemberChangeExn {
            #[doc(hidden)]
            Success(crate::types::AdminExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::storage_admin_service::MemberChangeError> for MemberChangeExn {
            fn from(err: crate::errors::storage_admin_service::MemberChangeError) -> Self {
                match err {
                    crate::errors::storage_admin_service::MemberChangeError::ApplicationException(aexn) => MemberChangeExn::ApplicationException(aexn),
                    crate::errors::storage_admin_service::MemberChangeError::ThriftError(err) => MemberChangeExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for MemberChangeExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for MemberChangeExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for MemberChangeExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for MemberChangeExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for MemberChangeExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("MemberChange");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for MemberChangeExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "MemberChangeExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "MemberChangeExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum WaitingForCatchUpDataExn {
            #[doc(hidden)]
            Success(crate::types::AdminExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::storage_admin_service::WaitingForCatchUpDataError> for WaitingForCatchUpDataExn {
            fn from(err: crate::errors::storage_admin_service::WaitingForCatchUpDataError) -> Self {
                match err {
                    crate::errors::storage_admin_service::WaitingForCatchUpDataError::ApplicationException(aexn) => WaitingForCatchUpDataExn::ApplicationException(aexn),
                    crate::errors::storage_admin_service::WaitingForCatchUpDataError::ThriftError(err) => WaitingForCatchUpDataExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for WaitingForCatchUpDataExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for WaitingForCatchUpDataExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for WaitingForCatchUpDataExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for WaitingForCatchUpDataExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for WaitingForCatchUpDataExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("WaitingForCatchUpData");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for WaitingForCatchUpDataExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "WaitingForCatchUpDataExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "WaitingForCatchUpDataExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum CreateCheckpointExn {
            #[doc(hidden)]
            Success(crate::types::CreateCPResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::storage_admin_service::CreateCheckpointError> for CreateCheckpointExn {
            fn from(err: crate::errors::storage_admin_service::CreateCheckpointError) -> Self {
                match err {
                    crate::errors::storage_admin_service::CreateCheckpointError::ApplicationException(aexn) => CreateCheckpointExn::ApplicationException(aexn),
                    crate::errors::storage_admin_service::CreateCheckpointError::ThriftError(err) => CreateCheckpointExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for CreateCheckpointExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for CreateCheckpointExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for CreateCheckpointExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for CreateCheckpointExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for CreateCheckpointExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("CreateCheckpoint");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for CreateCheckpointExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "CreateCheckpointExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "CreateCheckpointExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DropCheckpointExn {
            #[doc(hidden)]
            Success(crate::types::AdminExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::storage_admin_service::DropCheckpointError> for DropCheckpointExn {
            fn from(err: crate::errors::storage_admin_service::DropCheckpointError) -> Self {
                match err {
                    crate::errors::storage_admin_service::DropCheckpointError::ApplicationException(aexn) => DropCheckpointExn::ApplicationException(aexn),
                    crate::errors::storage_admin_service::DropCheckpointError::ThriftError(err) => DropCheckpointExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DropCheckpointExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for DropCheckpointExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for DropCheckpointExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for DropCheckpointExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DropCheckpointExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("DropCheckpoint");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DropCheckpointExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DropCheckpointExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DropCheckpointExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum BlockingWritesExn {
            #[doc(hidden)]
            Success(crate::types::AdminExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::storage_admin_service::BlockingWritesError> for BlockingWritesExn {
            fn from(err: crate::errors::storage_admin_service::BlockingWritesError) -> Self {
                match err {
                    crate::errors::storage_admin_service::BlockingWritesError::ApplicationException(aexn) => BlockingWritesExn::ApplicationException(aexn),
                    crate::errors::storage_admin_service::BlockingWritesError::ThriftError(err) => BlockingWritesExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for BlockingWritesExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for BlockingWritesExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for BlockingWritesExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for BlockingWritesExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for BlockingWritesExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("BlockingWrites");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for BlockingWritesExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "BlockingWritesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "BlockingWritesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum RebuildTagIndexExn {
            #[doc(hidden)]
            Success(crate::types::AdminExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::storage_admin_service::RebuildTagIndexError> for RebuildTagIndexExn {
            fn from(err: crate::errors::storage_admin_service::RebuildTagIndexError) -> Self {
                match err {
                    crate::errors::storage_admin_service::RebuildTagIndexError::ApplicationException(aexn) => RebuildTagIndexExn::ApplicationException(aexn),
                    crate::errors::storage_admin_service::RebuildTagIndexError::ThriftError(err) => RebuildTagIndexExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for RebuildTagIndexExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for RebuildTagIndexExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for RebuildTagIndexExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for RebuildTagIndexExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for RebuildTagIndexExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("RebuildTagIndex");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for RebuildTagIndexExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "RebuildTagIndexExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "RebuildTagIndexExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum RebuildEdgeIndexExn {
            #[doc(hidden)]
            Success(crate::types::AdminExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::storage_admin_service::RebuildEdgeIndexError> for RebuildEdgeIndexExn {
            fn from(err: crate::errors::storage_admin_service::RebuildEdgeIndexError) -> Self {
                match err {
                    crate::errors::storage_admin_service::RebuildEdgeIndexError::ApplicationException(aexn) => RebuildEdgeIndexExn::ApplicationException(aexn),
                    crate::errors::storage_admin_service::RebuildEdgeIndexError::ThriftError(err) => RebuildEdgeIndexExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for RebuildEdgeIndexExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for RebuildEdgeIndexExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for RebuildEdgeIndexExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for RebuildEdgeIndexExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for RebuildEdgeIndexExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("RebuildEdgeIndex");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for RebuildEdgeIndexExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "RebuildEdgeIndexExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "RebuildEdgeIndexExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetLeaderPartsExn {
            #[doc(hidden)]
            Success(crate::types::GetLeaderPartsResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::storage_admin_service::GetLeaderPartsError> for GetLeaderPartsExn {
            fn from(err: crate::errors::storage_admin_service::GetLeaderPartsError) -> Self {
                match err {
                    crate::errors::storage_admin_service::GetLeaderPartsError::ApplicationException(aexn) => GetLeaderPartsExn::ApplicationException(aexn),
                    crate::errors::storage_admin_service::GetLeaderPartsError::ThriftError(err) => GetLeaderPartsExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetLeaderPartsExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for GetLeaderPartsExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for GetLeaderPartsExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for GetLeaderPartsExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetLeaderPartsExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetLeaderParts");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetLeaderPartsExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetLeaderPartsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetLeaderPartsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum CheckPeersExn {
            #[doc(hidden)]
            Success(crate::types::AdminExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::storage_admin_service::CheckPeersError> for CheckPeersExn {
            fn from(err: crate::errors::storage_admin_service::CheckPeersError) -> Self {
                match err {
                    crate::errors::storage_admin_service::CheckPeersError::ApplicationException(aexn) => CheckPeersExn::ApplicationException(aexn),
                    crate::errors::storage_admin_service::CheckPeersError::ThriftError(err) => CheckPeersExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for CheckPeersExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for CheckPeersExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for CheckPeersExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for CheckPeersExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for CheckPeersExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("CheckPeers");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for CheckPeersExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "CheckPeersExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "CheckPeersExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum AddAdminTaskExn {
            #[doc(hidden)]
            Success(crate::types::AdminExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::storage_admin_service::AddAdminTaskError> for AddAdminTaskExn {
            fn from(err: crate::errors::storage_admin_service::AddAdminTaskError) -> Self {
                match err {
                    crate::errors::storage_admin_service::AddAdminTaskError::ApplicationException(aexn) => AddAdminTaskExn::ApplicationException(aexn),
                    crate::errors::storage_admin_service::AddAdminTaskError::ThriftError(err) => AddAdminTaskExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for AddAdminTaskExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for AddAdminTaskExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for AddAdminTaskExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for AddAdminTaskExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for AddAdminTaskExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("AddAdminTask");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for AddAdminTaskExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "AddAdminTaskExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "AddAdminTaskExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum StopAdminTaskExn {
            #[doc(hidden)]
            Success(crate::types::AdminExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::storage_admin_service::StopAdminTaskError> for StopAdminTaskExn {
            fn from(err: crate::errors::storage_admin_service::StopAdminTaskError) -> Self {
                match err {
                    crate::errors::storage_admin_service::StopAdminTaskError::ApplicationException(aexn) => StopAdminTaskExn::ApplicationException(aexn),
                    crate::errors::storage_admin_service::StopAdminTaskError::ThriftError(err) => StopAdminTaskExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for StopAdminTaskExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for StopAdminTaskExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for StopAdminTaskExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for StopAdminTaskExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for StopAdminTaskExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("StopAdminTask");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for StopAdminTaskExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "StopAdminTaskExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "StopAdminTaskExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListClusterInfoExn {
            #[doc(hidden)]
            Success(crate::types::ListClusterInfoResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::storage_admin_service::ListClusterInfoError> for ListClusterInfoExn {
            fn from(err: crate::errors::storage_admin_service::ListClusterInfoError) -> Self {
                match err {
                    crate::errors::storage_admin_service::ListClusterInfoError::ApplicationException(aexn) => ListClusterInfoExn::ApplicationException(aexn),
                    crate::errors::storage_admin_service::ListClusterInfoError::ThriftError(err) => ListClusterInfoExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ListClusterInfoExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for ListClusterInfoExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for ListClusterInfoExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for ListClusterInfoExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ListClusterInfoExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ListClusterInfo");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ListClusterInfoExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListClusterInfoExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListClusterInfoExn"),
                    )
                    .into(),
                )
            }
        }
    }

    pub mod general_storage_service {
        #[derive(Clone, Debug)]
        pub enum GetExn {
            #[doc(hidden)]
            Success(crate::types::KVGetResponse),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::general_storage_service::GetError> for GetExn {
            fn from(err: crate::errors::general_storage_service::GetError) -> Self {
                match err {
                    crate::errors::general_storage_service::GetError::ApplicationException(aexn) => GetExn::ApplicationException(aexn),
                    crate::errors::general_storage_service::GetError::ThriftError(err) => GetExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for GetExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for GetExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for GetExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("Get");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum PutExn {
            #[doc(hidden)]
            Success(crate::types::ExecResponse),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::general_storage_service::PutError> for PutExn {
            fn from(err: crate::errors::general_storage_service::PutError) -> Self {
                match err {
                    crate::errors::general_storage_service::PutError::ApplicationException(aexn) => PutExn::ApplicationException(aexn),
                    crate::errors::general_storage_service::PutError::ThriftError(err) => PutExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for PutExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for PutExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for PutExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for PutExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for PutExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("Put");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for PutExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "PutExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "PutExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum RemoveExn {
            #[doc(hidden)]
            Success(crate::types::ExecResponse),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::general_storage_service::RemoveError> for RemoveExn {
            fn from(err: crate::errors::general_storage_service::RemoveError) -> Self {
                match err {
                    crate::errors::general_storage_service::RemoveError::ApplicationException(aexn) => RemoveExn::ApplicationException(aexn),
                    crate::errors::general_storage_service::RemoveError::ThriftError(err) => RemoveExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for RemoveExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for RemoveExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for RemoveExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for RemoveExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for RemoveExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("Remove");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for RemoveExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "RemoveExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "RemoveExn"),
                    )
                    .into(),
                )
            }
        }
    }

    pub mod internal_storage_service {
        #[derive(Clone, Debug)]
        pub enum ChainAddEdgesExn {
            #[doc(hidden)]
            Success(crate::types::ExecResponse),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::internal_storage_service::ChainAddEdgesError> for ChainAddEdgesExn {
            fn from(err: crate::errors::internal_storage_service::ChainAddEdgesError) -> Self {
                match err {
                    crate::errors::internal_storage_service::ChainAddEdgesError::ApplicationException(aexn) => ChainAddEdgesExn::ApplicationException(aexn),
                    crate::errors::internal_storage_service::ChainAddEdgesError::ThriftError(err) => ChainAddEdgesExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ChainAddEdgesExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for ChainAddEdgesExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for ChainAddEdgesExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for ChainAddEdgesExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ChainAddEdgesExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ChainAddEdges");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ChainAddEdgesExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ChainAddEdgesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ChainAddEdgesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ChainUpdateEdgeExn {
            #[doc(hidden)]
            Success(crate::types::UpdateResponse),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::errors::internal_storage_service::ChainUpdateEdgeError> for ChainUpdateEdgeExn {
            fn from(err: crate::errors::internal_storage_service::ChainUpdateEdgeError) -> Self {
                match err {
                    crate::errors::internal_storage_service::ChainUpdateEdgeError::ApplicationException(aexn) => ChainUpdateEdgeExn::ApplicationException(aexn),
                    crate::errors::internal_storage_service::ChainUpdateEdgeError::ThriftError(err) => ChainUpdateEdgeExn::ApplicationException(::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ChainUpdateEdgeExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for ChainUpdateEdgeExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for ChainUpdateEdgeExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    Self::Success(_) => ::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for ChainUpdateEdgeExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ChainUpdateEdgeExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ChainUpdateEdge");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ChainUpdateEdgeExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ChainUpdateEdgeExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ChainUpdateEdgeExn"),
                    )
                    .into(),
                )
            }
        }
    }
}

/// Client implementation for each service in `storage`.
pub mod client {

    pub struct GraphStorageServiceImpl<P, T, S = ::fbthrift::NoopSpawner> {
        transport: T,
        _phantom: ::std::marker::PhantomData<fn() -> (P, S)>,
    }

    impl<P, T, S> GraphStorageServiceImpl<P, T, S>
    where
        P: ::fbthrift::Protocol,
        T: ::fbthrift::Transport,
        P::Frame: ::fbthrift::Framing<DecBuf = ::fbthrift::FramingDecoded<T>>,
        ::fbthrift::ProtocolEncoded<P>: ::fbthrift::BufMutExt<Final = ::fbthrift::FramingEncodedFinal<T>>,
        P::Deserializer: ::std::marker::Send,
        S: ::fbthrift::help::Spawner,
    {
        pub fn new(
            transport: T,
        ) -> Self {
            Self {
                transport,
                _phantom: ::std::marker::PhantomData,
            }
        }

        pub fn transport(&self) -> &T {
            &self.transport
        }


        fn _getNeighbors_impl(
            &self,
            arg_req: &crate::types::GetNeighborsRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetNeighborsResponse, crate::errors::graph_storage_service::GetNeighborsError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "GraphStorageService";
                METHOD_NAME = "GraphStorageService.getNeighbors";
            }
            let args = self::Args_GraphStorageService_getNeighbors {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("getNeighbors", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "GraphStorageService.getNeighbors"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::graph_storage_service::GetNeighborsExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::graph_storage_service::GetNeighborsError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("GraphStorageService.getNeighbors"))
            .boxed()
        }

        fn _getProps_impl(
            &self,
            arg_req: &crate::types::GetPropRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetPropResponse, crate::errors::graph_storage_service::GetPropsError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "GraphStorageService";
                METHOD_NAME = "GraphStorageService.getProps";
            }
            let args = self::Args_GraphStorageService_getProps {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("getProps", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "GraphStorageService.getProps"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::graph_storage_service::GetPropsExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::graph_storage_service::GetPropsError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("GraphStorageService.getProps"))
            .boxed()
        }

        fn _addVertices_impl(
            &self,
            arg_req: &crate::types::AddVerticesRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::AddVerticesError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "GraphStorageService";
                METHOD_NAME = "GraphStorageService.addVertices";
            }
            let args = self::Args_GraphStorageService_addVertices {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("addVertices", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "GraphStorageService.addVertices"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::graph_storage_service::AddVerticesExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::graph_storage_service::AddVerticesError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("GraphStorageService.addVertices"))
            .boxed()
        }

        fn _addEdges_impl(
            &self,
            arg_req: &crate::types::AddEdgesRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::AddEdgesError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "GraphStorageService";
                METHOD_NAME = "GraphStorageService.addEdges";
            }
            let args = self::Args_GraphStorageService_addEdges {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("addEdges", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "GraphStorageService.addEdges"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::graph_storage_service::AddEdgesExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::graph_storage_service::AddEdgesError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("GraphStorageService.addEdges"))
            .boxed()
        }

        fn _deleteEdges_impl(
            &self,
            arg_req: &crate::types::DeleteEdgesRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::DeleteEdgesError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "GraphStorageService";
                METHOD_NAME = "GraphStorageService.deleteEdges";
            }
            let args = self::Args_GraphStorageService_deleteEdges {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("deleteEdges", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "GraphStorageService.deleteEdges"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::graph_storage_service::DeleteEdgesExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::graph_storage_service::DeleteEdgesError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("GraphStorageService.deleteEdges"))
            .boxed()
        }

        fn _deleteVertices_impl(
            &self,
            arg_req: &crate::types::DeleteVerticesRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::DeleteVerticesError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "GraphStorageService";
                METHOD_NAME = "GraphStorageService.deleteVertices";
            }
            let args = self::Args_GraphStorageService_deleteVertices {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("deleteVertices", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "GraphStorageService.deleteVertices"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::graph_storage_service::DeleteVerticesExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::graph_storage_service::DeleteVerticesError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("GraphStorageService.deleteVertices"))
            .boxed()
        }

        fn _deleteTags_impl(
            &self,
            arg_req: &crate::types::DeleteTagsRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::DeleteTagsError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "GraphStorageService";
                METHOD_NAME = "GraphStorageService.deleteTags";
            }
            let args = self::Args_GraphStorageService_deleteTags {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("deleteTags", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "GraphStorageService.deleteTags"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::graph_storage_service::DeleteTagsExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::graph_storage_service::DeleteTagsError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("GraphStorageService.deleteTags"))
            .boxed()
        }

        fn _updateVertex_impl(
            &self,
            arg_req: &crate::types::UpdateVertexRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::UpdateResponse, crate::errors::graph_storage_service::UpdateVertexError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "GraphStorageService";
                METHOD_NAME = "GraphStorageService.updateVertex";
            }
            let args = self::Args_GraphStorageService_updateVertex {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("updateVertex", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "GraphStorageService.updateVertex"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::graph_storage_service::UpdateVertexExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::graph_storage_service::UpdateVertexError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("GraphStorageService.updateVertex"))
            .boxed()
        }

        fn _updateEdge_impl(
            &self,
            arg_req: &crate::types::UpdateEdgeRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::UpdateResponse, crate::errors::graph_storage_service::UpdateEdgeError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "GraphStorageService";
                METHOD_NAME = "GraphStorageService.updateEdge";
            }
            let args = self::Args_GraphStorageService_updateEdge {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("updateEdge", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "GraphStorageService.updateEdge"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::graph_storage_service::UpdateEdgeExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::graph_storage_service::UpdateEdgeError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("GraphStorageService.updateEdge"))
            .boxed()
        }

        fn _scanVertex_impl(
            &self,
            arg_req: &crate::types::ScanVertexRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ScanVertexResponse, crate::errors::graph_storage_service::ScanVertexError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "GraphStorageService";
                METHOD_NAME = "GraphStorageService.scanVertex";
            }
            let args = self::Args_GraphStorageService_scanVertex {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("scanVertex", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "GraphStorageService.scanVertex"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::graph_storage_service::ScanVertexExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::graph_storage_service::ScanVertexError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("GraphStorageService.scanVertex"))
            .boxed()
        }

        fn _scanEdge_impl(
            &self,
            arg_req: &crate::types::ScanEdgeRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ScanEdgeResponse, crate::errors::graph_storage_service::ScanEdgeError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "GraphStorageService";
                METHOD_NAME = "GraphStorageService.scanEdge";
            }
            let args = self::Args_GraphStorageService_scanEdge {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("scanEdge", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "GraphStorageService.scanEdge"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::graph_storage_service::ScanEdgeExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::graph_storage_service::ScanEdgeError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("GraphStorageService.scanEdge"))
            .boxed()
        }

        fn _getUUID_impl(
            &self,
            arg_req: &crate::types::GetUUIDReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetUUIDResp, crate::errors::graph_storage_service::GetUUIDError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "GraphStorageService";
                METHOD_NAME = "GraphStorageService.getUUID";
            }
            let args = self::Args_GraphStorageService_getUUID {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("getUUID", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "GraphStorageService.getUUID"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::graph_storage_service::GetUUIDExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::graph_storage_service::GetUUIDError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("GraphStorageService.getUUID"))
            .boxed()
        }

        fn _lookupIndex_impl(
            &self,
            arg_req: &crate::types::LookupIndexRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::LookupIndexResp, crate::errors::graph_storage_service::LookupIndexError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "GraphStorageService";
                METHOD_NAME = "GraphStorageService.lookupIndex";
            }
            let args = self::Args_GraphStorageService_lookupIndex {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("lookupIndex", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "GraphStorageService.lookupIndex"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::graph_storage_service::LookupIndexExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::graph_storage_service::LookupIndexError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("GraphStorageService.lookupIndex"))
            .boxed()
        }

        fn _lookupAndTraverse_impl(
            &self,
            arg_req: &crate::types::LookupAndTraverseRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetNeighborsResponse, crate::errors::graph_storage_service::LookupAndTraverseError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "GraphStorageService";
                METHOD_NAME = "GraphStorageService.lookupAndTraverse";
            }
            let args = self::Args_GraphStorageService_lookupAndTraverse {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("lookupAndTraverse", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "GraphStorageService.lookupAndTraverse"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::graph_storage_service::LookupAndTraverseExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::graph_storage_service::LookupAndTraverseError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("GraphStorageService.lookupAndTraverse"))
            .boxed()
        }

        fn _chainUpdateEdge_impl(
            &self,
            arg_req: &crate::types::UpdateEdgeRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::UpdateResponse, crate::errors::graph_storage_service::ChainUpdateEdgeError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "GraphStorageService";
                METHOD_NAME = "GraphStorageService.chainUpdateEdge";
            }
            let args = self::Args_GraphStorageService_chainUpdateEdge {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("chainUpdateEdge", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "GraphStorageService.chainUpdateEdge"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::graph_storage_service::ChainUpdateEdgeExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::graph_storage_service::ChainUpdateEdgeError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("GraphStorageService.chainUpdateEdge"))
            .boxed()
        }

        fn _chainAddEdges_impl(
            &self,
            arg_req: &crate::types::AddEdgesRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::ChainAddEdgesError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "GraphStorageService";
                METHOD_NAME = "GraphStorageService.chainAddEdges";
            }
            let args = self::Args_GraphStorageService_chainAddEdges {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("chainAddEdges", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "GraphStorageService.chainAddEdges"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::graph_storage_service::ChainAddEdgesExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::graph_storage_service::ChainAddEdgesError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("GraphStorageService.chainAddEdges"))
            .boxed()
        }
    }

    pub trait GraphStorageService: ::std::marker::Send {
        fn getNeighbors(
            &self,
            arg_req: &crate::types::GetNeighborsRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetNeighborsResponse, crate::errors::graph_storage_service::GetNeighborsError>>;

        fn getProps(
            &self,
            arg_req: &crate::types::GetPropRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetPropResponse, crate::errors::graph_storage_service::GetPropsError>>;

        fn addVertices(
            &self,
            arg_req: &crate::types::AddVerticesRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::AddVerticesError>>;

        fn addEdges(
            &self,
            arg_req: &crate::types::AddEdgesRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::AddEdgesError>>;

        fn deleteEdges(
            &self,
            arg_req: &crate::types::DeleteEdgesRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::DeleteEdgesError>>;

        fn deleteVertices(
            &self,
            arg_req: &crate::types::DeleteVerticesRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::DeleteVerticesError>>;

        fn deleteTags(
            &self,
            arg_req: &crate::types::DeleteTagsRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::DeleteTagsError>>;

        fn updateVertex(
            &self,
            arg_req: &crate::types::UpdateVertexRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::UpdateResponse, crate::errors::graph_storage_service::UpdateVertexError>>;

        fn updateEdge(
            &self,
            arg_req: &crate::types::UpdateEdgeRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::UpdateResponse, crate::errors::graph_storage_service::UpdateEdgeError>>;

        fn scanVertex(
            &self,
            arg_req: &crate::types::ScanVertexRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ScanVertexResponse, crate::errors::graph_storage_service::ScanVertexError>>;

        fn scanEdge(
            &self,
            arg_req: &crate::types::ScanEdgeRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ScanEdgeResponse, crate::errors::graph_storage_service::ScanEdgeError>>;

        fn getUUID(
            &self,
            arg_req: &crate::types::GetUUIDReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetUUIDResp, crate::errors::graph_storage_service::GetUUIDError>>;

        fn lookupIndex(
            &self,
            arg_req: &crate::types::LookupIndexRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::LookupIndexResp, crate::errors::graph_storage_service::LookupIndexError>>;

        fn lookupAndTraverse(
            &self,
            arg_req: &crate::types::LookupAndTraverseRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetNeighborsResponse, crate::errors::graph_storage_service::LookupAndTraverseError>>;

        fn chainUpdateEdge(
            &self,
            arg_req: &crate::types::UpdateEdgeRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::UpdateResponse, crate::errors::graph_storage_service::ChainUpdateEdgeError>>;

        fn chainAddEdges(
            &self,
            arg_req: &crate::types::AddEdgesRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::ChainAddEdgesError>>;
    }

    pub trait GraphStorageServiceExt<T>: GraphStorageService
    where
        T: ::fbthrift::Transport,
    {
        fn getNeighbors_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetNeighborsRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetNeighborsResponse, crate::errors::graph_storage_service::GetNeighborsError>>;
        fn getProps_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetPropRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetPropResponse, crate::errors::graph_storage_service::GetPropsError>>;
        fn addVertices_with_rpc_opts(
            &self,
            arg_req: &crate::types::AddVerticesRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::AddVerticesError>>;
        fn addEdges_with_rpc_opts(
            &self,
            arg_req: &crate::types::AddEdgesRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::AddEdgesError>>;
        fn deleteEdges_with_rpc_opts(
            &self,
            arg_req: &crate::types::DeleteEdgesRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::DeleteEdgesError>>;
        fn deleteVertices_with_rpc_opts(
            &self,
            arg_req: &crate::types::DeleteVerticesRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::DeleteVerticesError>>;
        fn deleteTags_with_rpc_opts(
            &self,
            arg_req: &crate::types::DeleteTagsRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::DeleteTagsError>>;
        fn updateVertex_with_rpc_opts(
            &self,
            arg_req: &crate::types::UpdateVertexRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::UpdateResponse, crate::errors::graph_storage_service::UpdateVertexError>>;
        fn updateEdge_with_rpc_opts(
            &self,
            arg_req: &crate::types::UpdateEdgeRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::UpdateResponse, crate::errors::graph_storage_service::UpdateEdgeError>>;
        fn scanVertex_with_rpc_opts(
            &self,
            arg_req: &crate::types::ScanVertexRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ScanVertexResponse, crate::errors::graph_storage_service::ScanVertexError>>;
        fn scanEdge_with_rpc_opts(
            &self,
            arg_req: &crate::types::ScanEdgeRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ScanEdgeResponse, crate::errors::graph_storage_service::ScanEdgeError>>;
        fn getUUID_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetUUIDReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetUUIDResp, crate::errors::graph_storage_service::GetUUIDError>>;
        fn lookupIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::LookupIndexRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::LookupIndexResp, crate::errors::graph_storage_service::LookupIndexError>>;
        fn lookupAndTraverse_with_rpc_opts(
            &self,
            arg_req: &crate::types::LookupAndTraverseRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetNeighborsResponse, crate::errors::graph_storage_service::LookupAndTraverseError>>;
        fn chainUpdateEdge_with_rpc_opts(
            &self,
            arg_req: &crate::types::UpdateEdgeRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::UpdateResponse, crate::errors::graph_storage_service::ChainUpdateEdgeError>>;
        fn chainAddEdges_with_rpc_opts(
            &self,
            arg_req: &crate::types::AddEdgesRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::ChainAddEdgesError>>;
    }

    struct Args_GraphStorageService_getNeighbors<'a> {
        req: &'a crate::types::GetNeighborsRequest,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_GraphStorageService_getNeighbors<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "GraphStorageService.getNeighbors"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_GraphStorageService_getProps<'a> {
        req: &'a crate::types::GetPropRequest,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_GraphStorageService_getProps<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "GraphStorageService.getProps"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_GraphStorageService_addVertices<'a> {
        req: &'a crate::types::AddVerticesRequest,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_GraphStorageService_addVertices<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "GraphStorageService.addVertices"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_GraphStorageService_addEdges<'a> {
        req: &'a crate::types::AddEdgesRequest,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_GraphStorageService_addEdges<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "GraphStorageService.addEdges"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_GraphStorageService_deleteEdges<'a> {
        req: &'a crate::types::DeleteEdgesRequest,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_GraphStorageService_deleteEdges<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "GraphStorageService.deleteEdges"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_GraphStorageService_deleteVertices<'a> {
        req: &'a crate::types::DeleteVerticesRequest,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_GraphStorageService_deleteVertices<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "GraphStorageService.deleteVertices"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_GraphStorageService_deleteTags<'a> {
        req: &'a crate::types::DeleteTagsRequest,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_GraphStorageService_deleteTags<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "GraphStorageService.deleteTags"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_GraphStorageService_updateVertex<'a> {
        req: &'a crate::types::UpdateVertexRequest,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_GraphStorageService_updateVertex<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "GraphStorageService.updateVertex"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_GraphStorageService_updateEdge<'a> {
        req: &'a crate::types::UpdateEdgeRequest,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_GraphStorageService_updateEdge<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "GraphStorageService.updateEdge"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_GraphStorageService_scanVertex<'a> {
        req: &'a crate::types::ScanVertexRequest,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_GraphStorageService_scanVertex<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "GraphStorageService.scanVertex"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_GraphStorageService_scanEdge<'a> {
        req: &'a crate::types::ScanEdgeRequest,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_GraphStorageService_scanEdge<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "GraphStorageService.scanEdge"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_GraphStorageService_getUUID<'a> {
        req: &'a crate::types::GetUUIDReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_GraphStorageService_getUUID<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "GraphStorageService.getUUID"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_GraphStorageService_lookupIndex<'a> {
        req: &'a crate::types::LookupIndexRequest,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_GraphStorageService_lookupIndex<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "GraphStorageService.lookupIndex"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_GraphStorageService_lookupAndTraverse<'a> {
        req: &'a crate::types::LookupAndTraverseRequest,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_GraphStorageService_lookupAndTraverse<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "GraphStorageService.lookupAndTraverse"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_GraphStorageService_chainUpdateEdge<'a> {
        req: &'a crate::types::UpdateEdgeRequest,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_GraphStorageService_chainUpdateEdge<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "GraphStorageService.chainUpdateEdge"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_GraphStorageService_chainAddEdges<'a> {
        req: &'a crate::types::AddEdgesRequest,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_GraphStorageService_chainAddEdges<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "GraphStorageService.chainAddEdges"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P, T, S> GraphStorageService for GraphStorageServiceImpl<P, T, S>
    where
        P: ::fbthrift::Protocol,
        T: ::fbthrift::Transport,
        P::Frame: ::fbthrift::Framing<DecBuf = ::fbthrift::FramingDecoded<T>>,
        ::fbthrift::ProtocolEncoded<P>: ::fbthrift::BufMutExt<Final = ::fbthrift::FramingEncodedFinal<T>>,
        P::Deserializer: ::std::marker::Send,
        S: ::fbthrift::help::Spawner,
    {
        fn getNeighbors(
            &self,
            arg_req: &crate::types::GetNeighborsRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetNeighborsResponse, crate::errors::graph_storage_service::GetNeighborsError>> {
            let rpc_options = T::RpcOptions::default();
            self._getNeighbors_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getProps(
            &self,
            arg_req: &crate::types::GetPropRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetPropResponse, crate::errors::graph_storage_service::GetPropsError>> {
            let rpc_options = T::RpcOptions::default();
            self._getProps_impl(
                arg_req,
                rpc_options,
            )
        }
        fn addVertices(
            &self,
            arg_req: &crate::types::AddVerticesRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::AddVerticesError>> {
            let rpc_options = T::RpcOptions::default();
            self._addVertices_impl(
                arg_req,
                rpc_options,
            )
        }
        fn addEdges(
            &self,
            arg_req: &crate::types::AddEdgesRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::AddEdgesError>> {
            let rpc_options = T::RpcOptions::default();
            self._addEdges_impl(
                arg_req,
                rpc_options,
            )
        }
        fn deleteEdges(
            &self,
            arg_req: &crate::types::DeleteEdgesRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::DeleteEdgesError>> {
            let rpc_options = T::RpcOptions::default();
            self._deleteEdges_impl(
                arg_req,
                rpc_options,
            )
        }
        fn deleteVertices(
            &self,
            arg_req: &crate::types::DeleteVerticesRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::DeleteVerticesError>> {
            let rpc_options = T::RpcOptions::default();
            self._deleteVertices_impl(
                arg_req,
                rpc_options,
            )
        }
        fn deleteTags(
            &self,
            arg_req: &crate::types::DeleteTagsRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::DeleteTagsError>> {
            let rpc_options = T::RpcOptions::default();
            self._deleteTags_impl(
                arg_req,
                rpc_options,
            )
        }
        fn updateVertex(
            &self,
            arg_req: &crate::types::UpdateVertexRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::UpdateResponse, crate::errors::graph_storage_service::UpdateVertexError>> {
            let rpc_options = T::RpcOptions::default();
            self._updateVertex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn updateEdge(
            &self,
            arg_req: &crate::types::UpdateEdgeRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::UpdateResponse, crate::errors::graph_storage_service::UpdateEdgeError>> {
            let rpc_options = T::RpcOptions::default();
            self._updateEdge_impl(
                arg_req,
                rpc_options,
            )
        }
        fn scanVertex(
            &self,
            arg_req: &crate::types::ScanVertexRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ScanVertexResponse, crate::errors::graph_storage_service::ScanVertexError>> {
            let rpc_options = T::RpcOptions::default();
            self._scanVertex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn scanEdge(
            &self,
            arg_req: &crate::types::ScanEdgeRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ScanEdgeResponse, crate::errors::graph_storage_service::ScanEdgeError>> {
            let rpc_options = T::RpcOptions::default();
            self._scanEdge_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getUUID(
            &self,
            arg_req: &crate::types::GetUUIDReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetUUIDResp, crate::errors::graph_storage_service::GetUUIDError>> {
            let rpc_options = T::RpcOptions::default();
            self._getUUID_impl(
                arg_req,
                rpc_options,
            )
        }
        fn lookupIndex(
            &self,
            arg_req: &crate::types::LookupIndexRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::LookupIndexResp, crate::errors::graph_storage_service::LookupIndexError>> {
            let rpc_options = T::RpcOptions::default();
            self._lookupIndex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn lookupAndTraverse(
            &self,
            arg_req: &crate::types::LookupAndTraverseRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetNeighborsResponse, crate::errors::graph_storage_service::LookupAndTraverseError>> {
            let rpc_options = T::RpcOptions::default();
            self._lookupAndTraverse_impl(
                arg_req,
                rpc_options,
            )
        }
        fn chainUpdateEdge(
            &self,
            arg_req: &crate::types::UpdateEdgeRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::UpdateResponse, crate::errors::graph_storage_service::ChainUpdateEdgeError>> {
            let rpc_options = T::RpcOptions::default();
            self._chainUpdateEdge_impl(
                arg_req,
                rpc_options,
            )
        }
        fn chainAddEdges(
            &self,
            arg_req: &crate::types::AddEdgesRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::ChainAddEdgesError>> {
            let rpc_options = T::RpcOptions::default();
            self._chainAddEdges_impl(
                arg_req,
                rpc_options,
            )
        }
    }

    impl<P, T, S> GraphStorageServiceExt<T> for GraphStorageServiceImpl<P, T, S>
    where
        P: ::fbthrift::Protocol,
        T: ::fbthrift::Transport,
        P::Frame: ::fbthrift::Framing<DecBuf = ::fbthrift::FramingDecoded<T>>,
        ::fbthrift::ProtocolEncoded<P>: ::fbthrift::BufMutExt<Final = ::fbthrift::FramingEncodedFinal<T>>,
        P::Deserializer: ::std::marker::Send,
        S: ::fbthrift::help::Spawner,
    {
        fn getNeighbors_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetNeighborsRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetNeighborsResponse, crate::errors::graph_storage_service::GetNeighborsError>> {
            self._getNeighbors_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getProps_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetPropRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetPropResponse, crate::errors::graph_storage_service::GetPropsError>> {
            self._getProps_impl(
                arg_req,
                rpc_options,
            )
        }
        fn addVertices_with_rpc_opts(
            &self,
            arg_req: &crate::types::AddVerticesRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::AddVerticesError>> {
            self._addVertices_impl(
                arg_req,
                rpc_options,
            )
        }
        fn addEdges_with_rpc_opts(
            &self,
            arg_req: &crate::types::AddEdgesRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::AddEdgesError>> {
            self._addEdges_impl(
                arg_req,
                rpc_options,
            )
        }
        fn deleteEdges_with_rpc_opts(
            &self,
            arg_req: &crate::types::DeleteEdgesRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::DeleteEdgesError>> {
            self._deleteEdges_impl(
                arg_req,
                rpc_options,
            )
        }
        fn deleteVertices_with_rpc_opts(
            &self,
            arg_req: &crate::types::DeleteVerticesRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::DeleteVerticesError>> {
            self._deleteVertices_impl(
                arg_req,
                rpc_options,
            )
        }
        fn deleteTags_with_rpc_opts(
            &self,
            arg_req: &crate::types::DeleteTagsRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::DeleteTagsError>> {
            self._deleteTags_impl(
                arg_req,
                rpc_options,
            )
        }
        fn updateVertex_with_rpc_opts(
            &self,
            arg_req: &crate::types::UpdateVertexRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::UpdateResponse, crate::errors::graph_storage_service::UpdateVertexError>> {
            self._updateVertex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn updateEdge_with_rpc_opts(
            &self,
            arg_req: &crate::types::UpdateEdgeRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::UpdateResponse, crate::errors::graph_storage_service::UpdateEdgeError>> {
            self._updateEdge_impl(
                arg_req,
                rpc_options,
            )
        }
        fn scanVertex_with_rpc_opts(
            &self,
            arg_req: &crate::types::ScanVertexRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ScanVertexResponse, crate::errors::graph_storage_service::ScanVertexError>> {
            self._scanVertex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn scanEdge_with_rpc_opts(
            &self,
            arg_req: &crate::types::ScanEdgeRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ScanEdgeResponse, crate::errors::graph_storage_service::ScanEdgeError>> {
            self._scanEdge_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getUUID_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetUUIDReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetUUIDResp, crate::errors::graph_storage_service::GetUUIDError>> {
            self._getUUID_impl(
                arg_req,
                rpc_options,
            )
        }
        fn lookupIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::LookupIndexRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::LookupIndexResp, crate::errors::graph_storage_service::LookupIndexError>> {
            self._lookupIndex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn lookupAndTraverse_with_rpc_opts(
            &self,
            arg_req: &crate::types::LookupAndTraverseRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetNeighborsResponse, crate::errors::graph_storage_service::LookupAndTraverseError>> {
            self._lookupAndTraverse_impl(
                arg_req,
                rpc_options,
            )
        }
        fn chainUpdateEdge_with_rpc_opts(
            &self,
            arg_req: &crate::types::UpdateEdgeRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::UpdateResponse, crate::errors::graph_storage_service::ChainUpdateEdgeError>> {
            self._chainUpdateEdge_impl(
                arg_req,
                rpc_options,
            )
        }
        fn chainAddEdges_with_rpc_opts(
            &self,
            arg_req: &crate::types::AddEdgesRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::ChainAddEdgesError>> {
            self._chainAddEdges_impl(
                arg_req,
                rpc_options,
            )
        }
    }

    impl<'a, S> GraphStorageService for S
    where
        S: ::std::convert::AsRef<dyn GraphStorageService + 'a>,
        S: ::std::marker::Send,
    {
        fn getNeighbors(
            &self,
            arg_req: &crate::types::GetNeighborsRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetNeighborsResponse, crate::errors::graph_storage_service::GetNeighborsError>> {
            self.as_ref().getNeighbors(
                arg_req,
            )
        }
        fn getProps(
            &self,
            arg_req: &crate::types::GetPropRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetPropResponse, crate::errors::graph_storage_service::GetPropsError>> {
            self.as_ref().getProps(
                arg_req,
            )
        }
        fn addVertices(
            &self,
            arg_req: &crate::types::AddVerticesRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::AddVerticesError>> {
            self.as_ref().addVertices(
                arg_req,
            )
        }
        fn addEdges(
            &self,
            arg_req: &crate::types::AddEdgesRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::AddEdgesError>> {
            self.as_ref().addEdges(
                arg_req,
            )
        }
        fn deleteEdges(
            &self,
            arg_req: &crate::types::DeleteEdgesRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::DeleteEdgesError>> {
            self.as_ref().deleteEdges(
                arg_req,
            )
        }
        fn deleteVertices(
            &self,
            arg_req: &crate::types::DeleteVerticesRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::DeleteVerticesError>> {
            self.as_ref().deleteVertices(
                arg_req,
            )
        }
        fn deleteTags(
            &self,
            arg_req: &crate::types::DeleteTagsRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::DeleteTagsError>> {
            self.as_ref().deleteTags(
                arg_req,
            )
        }
        fn updateVertex(
            &self,
            arg_req: &crate::types::UpdateVertexRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::UpdateResponse, crate::errors::graph_storage_service::UpdateVertexError>> {
            self.as_ref().updateVertex(
                arg_req,
            )
        }
        fn updateEdge(
            &self,
            arg_req: &crate::types::UpdateEdgeRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::UpdateResponse, crate::errors::graph_storage_service::UpdateEdgeError>> {
            self.as_ref().updateEdge(
                arg_req,
            )
        }
        fn scanVertex(
            &self,
            arg_req: &crate::types::ScanVertexRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ScanVertexResponse, crate::errors::graph_storage_service::ScanVertexError>> {
            self.as_ref().scanVertex(
                arg_req,
            )
        }
        fn scanEdge(
            &self,
            arg_req: &crate::types::ScanEdgeRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ScanEdgeResponse, crate::errors::graph_storage_service::ScanEdgeError>> {
            self.as_ref().scanEdge(
                arg_req,
            )
        }
        fn getUUID(
            &self,
            arg_req: &crate::types::GetUUIDReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetUUIDResp, crate::errors::graph_storage_service::GetUUIDError>> {
            self.as_ref().getUUID(
                arg_req,
            )
        }
        fn lookupIndex(
            &self,
            arg_req: &crate::types::LookupIndexRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::LookupIndexResp, crate::errors::graph_storage_service::LookupIndexError>> {
            self.as_ref().lookupIndex(
                arg_req,
            )
        }
        fn lookupAndTraverse(
            &self,
            arg_req: &crate::types::LookupAndTraverseRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetNeighborsResponse, crate::errors::graph_storage_service::LookupAndTraverseError>> {
            self.as_ref().lookupAndTraverse(
                arg_req,
            )
        }
        fn chainUpdateEdge(
            &self,
            arg_req: &crate::types::UpdateEdgeRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::UpdateResponse, crate::errors::graph_storage_service::ChainUpdateEdgeError>> {
            self.as_ref().chainUpdateEdge(
                arg_req,
            )
        }
        fn chainAddEdges(
            &self,
            arg_req: &crate::types::AddEdgesRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::ChainAddEdgesError>> {
            self.as_ref().chainAddEdges(
                arg_req,
            )
        }
    }

    impl<'a, S, T> GraphStorageServiceExt<T> for S
    where
        S: ::std::convert::AsRef<dyn GraphStorageService + 'a>,
        S: ::std::convert::AsRef<dyn GraphStorageServiceExt<T> + 'a>,
        S: ::std::marker::Send,
        T: ::fbthrift::Transport,
    {
        fn getNeighbors_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetNeighborsRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetNeighborsResponse, crate::errors::graph_storage_service::GetNeighborsError>> {
            <Self as ::std::convert::AsRef<dyn GraphStorageServiceExt<T>>>::as_ref(self).getNeighbors_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn getProps_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetPropRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetPropResponse, crate::errors::graph_storage_service::GetPropsError>> {
            <Self as ::std::convert::AsRef<dyn GraphStorageServiceExt<T>>>::as_ref(self).getProps_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn addVertices_with_rpc_opts(
            &self,
            arg_req: &crate::types::AddVerticesRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::AddVerticesError>> {
            <Self as ::std::convert::AsRef<dyn GraphStorageServiceExt<T>>>::as_ref(self).addVertices_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn addEdges_with_rpc_opts(
            &self,
            arg_req: &crate::types::AddEdgesRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::AddEdgesError>> {
            <Self as ::std::convert::AsRef<dyn GraphStorageServiceExt<T>>>::as_ref(self).addEdges_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn deleteEdges_with_rpc_opts(
            &self,
            arg_req: &crate::types::DeleteEdgesRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::DeleteEdgesError>> {
            <Self as ::std::convert::AsRef<dyn GraphStorageServiceExt<T>>>::as_ref(self).deleteEdges_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn deleteVertices_with_rpc_opts(
            &self,
            arg_req: &crate::types::DeleteVerticesRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::DeleteVerticesError>> {
            <Self as ::std::convert::AsRef<dyn GraphStorageServiceExt<T>>>::as_ref(self).deleteVertices_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn deleteTags_with_rpc_opts(
            &self,
            arg_req: &crate::types::DeleteTagsRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::DeleteTagsError>> {
            <Self as ::std::convert::AsRef<dyn GraphStorageServiceExt<T>>>::as_ref(self).deleteTags_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn updateVertex_with_rpc_opts(
            &self,
            arg_req: &crate::types::UpdateVertexRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::UpdateResponse, crate::errors::graph_storage_service::UpdateVertexError>> {
            <Self as ::std::convert::AsRef<dyn GraphStorageServiceExt<T>>>::as_ref(self).updateVertex_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn updateEdge_with_rpc_opts(
            &self,
            arg_req: &crate::types::UpdateEdgeRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::UpdateResponse, crate::errors::graph_storage_service::UpdateEdgeError>> {
            <Self as ::std::convert::AsRef<dyn GraphStorageServiceExt<T>>>::as_ref(self).updateEdge_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn scanVertex_with_rpc_opts(
            &self,
            arg_req: &crate::types::ScanVertexRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ScanVertexResponse, crate::errors::graph_storage_service::ScanVertexError>> {
            <Self as ::std::convert::AsRef<dyn GraphStorageServiceExt<T>>>::as_ref(self).scanVertex_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn scanEdge_with_rpc_opts(
            &self,
            arg_req: &crate::types::ScanEdgeRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ScanEdgeResponse, crate::errors::graph_storage_service::ScanEdgeError>> {
            <Self as ::std::convert::AsRef<dyn GraphStorageServiceExt<T>>>::as_ref(self).scanEdge_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn getUUID_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetUUIDReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetUUIDResp, crate::errors::graph_storage_service::GetUUIDError>> {
            <Self as ::std::convert::AsRef<dyn GraphStorageServiceExt<T>>>::as_ref(self).getUUID_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn lookupIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::LookupIndexRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::LookupIndexResp, crate::errors::graph_storage_service::LookupIndexError>> {
            <Self as ::std::convert::AsRef<dyn GraphStorageServiceExt<T>>>::as_ref(self).lookupIndex_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn lookupAndTraverse_with_rpc_opts(
            &self,
            arg_req: &crate::types::LookupAndTraverseRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetNeighborsResponse, crate::errors::graph_storage_service::LookupAndTraverseError>> {
            <Self as ::std::convert::AsRef<dyn GraphStorageServiceExt<T>>>::as_ref(self).lookupAndTraverse_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn chainUpdateEdge_with_rpc_opts(
            &self,
            arg_req: &crate::types::UpdateEdgeRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::UpdateResponse, crate::errors::graph_storage_service::ChainUpdateEdgeError>> {
            <Self as ::std::convert::AsRef<dyn GraphStorageServiceExt<T>>>::as_ref(self).chainUpdateEdge_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn chainAddEdges_with_rpc_opts(
            &self,
            arg_req: &crate::types::AddEdgesRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::ChainAddEdgesError>> {
            <Self as ::std::convert::AsRef<dyn GraphStorageServiceExt<T>>>::as_ref(self).chainAddEdges_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
    }

    #[derive(Clone)]
    pub struct make_GraphStorageService;

    /// To be called by user directly setting up a client. Avoids
    /// needing ClientFactory trait in scope, avoids unidiomatic
    /// make_Trait name.
    ///
    /// ```
    /// # const _: &str = stringify! {
    /// use bgs::client::BuckGraphService;
    ///
    /// let protocol = BinaryProtocol::new();
    /// let transport = HttpClient::new();
    /// let client = <dyn BuckGraphService>::new(protocol, transport);
    /// # };
    /// ```
    impl dyn GraphStorageService {
        pub fn new<P, T>(
            protocol: P,
            transport: T,
        ) -> ::std::sync::Arc<impl GraphStorageService + ::std::marker::Send + ::std::marker::Sync + 'static>
        where
            P: ::fbthrift::Protocol<Frame = T>,
            T: ::fbthrift::Transport,
            P::Deserializer: ::std::marker::Send,
        {
            let spawner = ::fbthrift::help::NoopSpawner;
            Self::with_spawner(protocol, transport, spawner)
        }

        pub fn with_spawner<P, T, S>(
            protocol: P,
            transport: T,
            spawner: S,
        ) -> ::std::sync::Arc<impl GraphStorageService + ::std::marker::Send + ::std::marker::Sync + 'static>
        where
            P: ::fbthrift::Protocol<Frame = T>,
            T: ::fbthrift::Transport,
            P::Deserializer: ::std::marker::Send,
            S: ::fbthrift::help::Spawner,
        {
            let _ = protocol;
            let _ = spawner;
            ::std::sync::Arc::new(GraphStorageServiceImpl::<P, T, S>::new(transport))
        }
    }

    impl<T> dyn GraphStorageServiceExt<T>
    where
        T: ::fbthrift::Transport,
    {
        pub fn new<P>(
            protocol: P,
            transport: T,
        ) -> ::std::sync::Arc<impl GraphStorageServiceExt<T> + ::std::marker::Send + ::std::marker::Sync + 'static>
        where
            P: ::fbthrift::Protocol<Frame = T>,
            P::Deserializer: ::std::marker::Send,
        {
            let spawner = ::fbthrift::help::NoopSpawner;
            Self::with_spawner(protocol, transport, spawner)
        }

        pub fn with_spawner<P, S>(
            protocol: P,
            transport: T,
            spawner: S,
        ) -> ::std::sync::Arc<impl GraphStorageServiceExt<T> + ::std::marker::Send + ::std::marker::Sync + 'static>
        where
            P: ::fbthrift::Protocol<Frame = T>,
            P::Deserializer: ::std::marker::Send,
            S: ::fbthrift::help::Spawner,
        {
            let _ = protocol;
            let _ = spawner;
            ::std::sync::Arc::new(GraphStorageServiceImpl::<P, T, S>::new(transport))
        }
    }

    pub type GraphStorageServiceDynClient = <make_GraphStorageService as ::fbthrift::ClientFactory>::Api;
    pub type GraphStorageServiceClient = ::std::sync::Arc<GraphStorageServiceDynClient>;

    /// The same thing, but to be called from generic contexts where we are
    /// working with a type parameter `C: ClientFactory` to produce clients.
    impl ::fbthrift::ClientFactory for make_GraphStorageService {
        type Api = dyn GraphStorageService + ::std::marker::Send + ::std::marker::Sync + 'static;

        fn with_spawner<P, T, S>(protocol: P, transport: T, spawner: S) -> ::std::sync::Arc<Self::Api>
        where
            P: ::fbthrift::Protocol<Frame = T>,
            T: ::fbthrift::Transport,
            P::Deserializer: ::std::marker::Send,
            S: ::fbthrift::help::Spawner,
        {
            <dyn GraphStorageService>::with_spawner(protocol, transport, spawner)
        }
    }


    pub struct StorageAdminServiceImpl<P, T, S = ::fbthrift::NoopSpawner> {
        transport: T,
        _phantom: ::std::marker::PhantomData<fn() -> (P, S)>,
    }

    impl<P, T, S> StorageAdminServiceImpl<P, T, S>
    where
        P: ::fbthrift::Protocol,
        T: ::fbthrift::Transport,
        P::Frame: ::fbthrift::Framing<DecBuf = ::fbthrift::FramingDecoded<T>>,
        ::fbthrift::ProtocolEncoded<P>: ::fbthrift::BufMutExt<Final = ::fbthrift::FramingEncodedFinal<T>>,
        P::Deserializer: ::std::marker::Send,
        S: ::fbthrift::help::Spawner,
    {
        pub fn new(
            transport: T,
        ) -> Self {
            Self {
                transport,
                _phantom: ::std::marker::PhantomData,
            }
        }

        pub fn transport(&self) -> &T {
            &self.transport
        }


        fn _transLeader_impl(
            &self,
            arg_req: &crate::types::TransLeaderReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::TransLeaderError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageAdminService";
                METHOD_NAME = "StorageAdminService.transLeader";
            }
            let args = self::Args_StorageAdminService_transLeader {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("transLeader", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "StorageAdminService.transLeader"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::storage_admin_service::TransLeaderExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::storage_admin_service::TransLeaderError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("StorageAdminService.transLeader"))
            .boxed()
        }

        fn _addPart_impl(
            &self,
            arg_req: &crate::types::AddPartReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::AddPartError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageAdminService";
                METHOD_NAME = "StorageAdminService.addPart";
            }
            let args = self::Args_StorageAdminService_addPart {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("addPart", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "StorageAdminService.addPart"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::storage_admin_service::AddPartExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::storage_admin_service::AddPartError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("StorageAdminService.addPart"))
            .boxed()
        }

        fn _addLearner_impl(
            &self,
            arg_req: &crate::types::AddLearnerReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::AddLearnerError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageAdminService";
                METHOD_NAME = "StorageAdminService.addLearner";
            }
            let args = self::Args_StorageAdminService_addLearner {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("addLearner", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "StorageAdminService.addLearner"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::storage_admin_service::AddLearnerExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::storage_admin_service::AddLearnerError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("StorageAdminService.addLearner"))
            .boxed()
        }

        fn _removePart_impl(
            &self,
            arg_req: &crate::types::RemovePartReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::RemovePartError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageAdminService";
                METHOD_NAME = "StorageAdminService.removePart";
            }
            let args = self::Args_StorageAdminService_removePart {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("removePart", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "StorageAdminService.removePart"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::storage_admin_service::RemovePartExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::storage_admin_service::RemovePartError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("StorageAdminService.removePart"))
            .boxed()
        }

        fn _memberChange_impl(
            &self,
            arg_req: &crate::types::MemberChangeReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::MemberChangeError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageAdminService";
                METHOD_NAME = "StorageAdminService.memberChange";
            }
            let args = self::Args_StorageAdminService_memberChange {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("memberChange", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "StorageAdminService.memberChange"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::storage_admin_service::MemberChangeExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::storage_admin_service::MemberChangeError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("StorageAdminService.memberChange"))
            .boxed()
        }

        fn _waitingForCatchUpData_impl(
            &self,
            arg_req: &crate::types::CatchUpDataReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::WaitingForCatchUpDataError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageAdminService";
                METHOD_NAME = "StorageAdminService.waitingForCatchUpData";
            }
            let args = self::Args_StorageAdminService_waitingForCatchUpData {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("waitingForCatchUpData", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "StorageAdminService.waitingForCatchUpData"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::storage_admin_service::WaitingForCatchUpDataExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::storage_admin_service::WaitingForCatchUpDataError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("StorageAdminService.waitingForCatchUpData"))
            .boxed()
        }

        fn _createCheckpoint_impl(
            &self,
            arg_req: &crate::types::CreateCPRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::CreateCPResp, crate::errors::storage_admin_service::CreateCheckpointError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageAdminService";
                METHOD_NAME = "StorageAdminService.createCheckpoint";
            }
            let args = self::Args_StorageAdminService_createCheckpoint {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("createCheckpoint", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "StorageAdminService.createCheckpoint"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::storage_admin_service::CreateCheckpointExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::storage_admin_service::CreateCheckpointError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("StorageAdminService.createCheckpoint"))
            .boxed()
        }

        fn _dropCheckpoint_impl(
            &self,
            arg_req: &crate::types::DropCPRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::DropCheckpointError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageAdminService";
                METHOD_NAME = "StorageAdminService.dropCheckpoint";
            }
            let args = self::Args_StorageAdminService_dropCheckpoint {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("dropCheckpoint", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "StorageAdminService.dropCheckpoint"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::storage_admin_service::DropCheckpointExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::storage_admin_service::DropCheckpointError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("StorageAdminService.dropCheckpoint"))
            .boxed()
        }

        fn _blockingWrites_impl(
            &self,
            arg_req: &crate::types::BlockingSignRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::BlockingWritesError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageAdminService";
                METHOD_NAME = "StorageAdminService.blockingWrites";
            }
            let args = self::Args_StorageAdminService_blockingWrites {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("blockingWrites", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "StorageAdminService.blockingWrites"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::storage_admin_service::BlockingWritesExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::storage_admin_service::BlockingWritesError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("StorageAdminService.blockingWrites"))
            .boxed()
        }

        fn _rebuildTagIndex_impl(
            &self,
            arg_req: &crate::types::RebuildIndexRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::RebuildTagIndexError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageAdminService";
                METHOD_NAME = "StorageAdminService.rebuildTagIndex";
            }
            let args = self::Args_StorageAdminService_rebuildTagIndex {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("rebuildTagIndex", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "StorageAdminService.rebuildTagIndex"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::storage_admin_service::RebuildTagIndexExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::storage_admin_service::RebuildTagIndexError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("StorageAdminService.rebuildTagIndex"))
            .boxed()
        }

        fn _rebuildEdgeIndex_impl(
            &self,
            arg_req: &crate::types::RebuildIndexRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::RebuildEdgeIndexError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageAdminService";
                METHOD_NAME = "StorageAdminService.rebuildEdgeIndex";
            }
            let args = self::Args_StorageAdminService_rebuildEdgeIndex {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("rebuildEdgeIndex", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "StorageAdminService.rebuildEdgeIndex"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::storage_admin_service::RebuildEdgeIndexExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::storage_admin_service::RebuildEdgeIndexError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("StorageAdminService.rebuildEdgeIndex"))
            .boxed()
        }

        fn _getLeaderParts_impl(
            &self,
            arg_req: &crate::types::GetLeaderReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetLeaderPartsResp, crate::errors::storage_admin_service::GetLeaderPartsError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageAdminService";
                METHOD_NAME = "StorageAdminService.getLeaderParts";
            }
            let args = self::Args_StorageAdminService_getLeaderParts {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("getLeaderParts", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "StorageAdminService.getLeaderParts"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::storage_admin_service::GetLeaderPartsExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::storage_admin_service::GetLeaderPartsError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("StorageAdminService.getLeaderParts"))
            .boxed()
        }

        fn _checkPeers_impl(
            &self,
            arg_req: &crate::types::CheckPeersReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::CheckPeersError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageAdminService";
                METHOD_NAME = "StorageAdminService.checkPeers";
            }
            let args = self::Args_StorageAdminService_checkPeers {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("checkPeers", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "StorageAdminService.checkPeers"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::storage_admin_service::CheckPeersExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::storage_admin_service::CheckPeersError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("StorageAdminService.checkPeers"))
            .boxed()
        }

        fn _addAdminTask_impl(
            &self,
            arg_req: &crate::types::AddAdminTaskRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::AddAdminTaskError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageAdminService";
                METHOD_NAME = "StorageAdminService.addAdminTask";
            }
            let args = self::Args_StorageAdminService_addAdminTask {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("addAdminTask", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "StorageAdminService.addAdminTask"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::storage_admin_service::AddAdminTaskExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::storage_admin_service::AddAdminTaskError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("StorageAdminService.addAdminTask"))
            .boxed()
        }

        fn _stopAdminTask_impl(
            &self,
            arg_req: &crate::types::StopAdminTaskRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::StopAdminTaskError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageAdminService";
                METHOD_NAME = "StorageAdminService.stopAdminTask";
            }
            let args = self::Args_StorageAdminService_stopAdminTask {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("stopAdminTask", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "StorageAdminService.stopAdminTask"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::storage_admin_service::StopAdminTaskExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::storage_admin_service::StopAdminTaskError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("StorageAdminService.stopAdminTask"))
            .boxed()
        }

        fn _listClusterInfo_impl(
            &self,
            arg_req: &crate::types::ListClusterInfoReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListClusterInfoResp, crate::errors::storage_admin_service::ListClusterInfoError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageAdminService";
                METHOD_NAME = "StorageAdminService.listClusterInfo";
            }
            let args = self::Args_StorageAdminService_listClusterInfo {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("listClusterInfo", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "StorageAdminService.listClusterInfo"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::storage_admin_service::ListClusterInfoExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::storage_admin_service::ListClusterInfoError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("StorageAdminService.listClusterInfo"))
            .boxed()
        }
    }

    pub trait StorageAdminService: ::std::marker::Send {
        fn transLeader(
            &self,
            arg_req: &crate::types::TransLeaderReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::TransLeaderError>>;

        fn addPart(
            &self,
            arg_req: &crate::types::AddPartReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::AddPartError>>;

        fn addLearner(
            &self,
            arg_req: &crate::types::AddLearnerReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::AddLearnerError>>;

        fn removePart(
            &self,
            arg_req: &crate::types::RemovePartReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::RemovePartError>>;

        fn memberChange(
            &self,
            arg_req: &crate::types::MemberChangeReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::MemberChangeError>>;

        fn waitingForCatchUpData(
            &self,
            arg_req: &crate::types::CatchUpDataReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::WaitingForCatchUpDataError>>;

        fn createCheckpoint(
            &self,
            arg_req: &crate::types::CreateCPRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::CreateCPResp, crate::errors::storage_admin_service::CreateCheckpointError>>;

        fn dropCheckpoint(
            &self,
            arg_req: &crate::types::DropCPRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::DropCheckpointError>>;

        fn blockingWrites(
            &self,
            arg_req: &crate::types::BlockingSignRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::BlockingWritesError>>;

        fn rebuildTagIndex(
            &self,
            arg_req: &crate::types::RebuildIndexRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::RebuildTagIndexError>>;

        fn rebuildEdgeIndex(
            &self,
            arg_req: &crate::types::RebuildIndexRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::RebuildEdgeIndexError>>;

        fn getLeaderParts(
            &self,
            arg_req: &crate::types::GetLeaderReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetLeaderPartsResp, crate::errors::storage_admin_service::GetLeaderPartsError>>;

        fn checkPeers(
            &self,
            arg_req: &crate::types::CheckPeersReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::CheckPeersError>>;

        fn addAdminTask(
            &self,
            arg_req: &crate::types::AddAdminTaskRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::AddAdminTaskError>>;

        fn stopAdminTask(
            &self,
            arg_req: &crate::types::StopAdminTaskRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::StopAdminTaskError>>;

        fn listClusterInfo(
            &self,
            arg_req: &crate::types::ListClusterInfoReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListClusterInfoResp, crate::errors::storage_admin_service::ListClusterInfoError>>;
    }

    pub trait StorageAdminServiceExt<T>: StorageAdminService
    where
        T: ::fbthrift::Transport,
    {
        fn transLeader_with_rpc_opts(
            &self,
            arg_req: &crate::types::TransLeaderReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::TransLeaderError>>;
        fn addPart_with_rpc_opts(
            &self,
            arg_req: &crate::types::AddPartReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::AddPartError>>;
        fn addLearner_with_rpc_opts(
            &self,
            arg_req: &crate::types::AddLearnerReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::AddLearnerError>>;
        fn removePart_with_rpc_opts(
            &self,
            arg_req: &crate::types::RemovePartReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::RemovePartError>>;
        fn memberChange_with_rpc_opts(
            &self,
            arg_req: &crate::types::MemberChangeReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::MemberChangeError>>;
        fn waitingForCatchUpData_with_rpc_opts(
            &self,
            arg_req: &crate::types::CatchUpDataReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::WaitingForCatchUpDataError>>;
        fn createCheckpoint_with_rpc_opts(
            &self,
            arg_req: &crate::types::CreateCPRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::CreateCPResp, crate::errors::storage_admin_service::CreateCheckpointError>>;
        fn dropCheckpoint_with_rpc_opts(
            &self,
            arg_req: &crate::types::DropCPRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::DropCheckpointError>>;
        fn blockingWrites_with_rpc_opts(
            &self,
            arg_req: &crate::types::BlockingSignRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::BlockingWritesError>>;
        fn rebuildTagIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::RebuildIndexRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::RebuildTagIndexError>>;
        fn rebuildEdgeIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::RebuildIndexRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::RebuildEdgeIndexError>>;
        fn getLeaderParts_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetLeaderReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetLeaderPartsResp, crate::errors::storage_admin_service::GetLeaderPartsError>>;
        fn checkPeers_with_rpc_opts(
            &self,
            arg_req: &crate::types::CheckPeersReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::CheckPeersError>>;
        fn addAdminTask_with_rpc_opts(
            &self,
            arg_req: &crate::types::AddAdminTaskRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::AddAdminTaskError>>;
        fn stopAdminTask_with_rpc_opts(
            &self,
            arg_req: &crate::types::StopAdminTaskRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::StopAdminTaskError>>;
        fn listClusterInfo_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListClusterInfoReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListClusterInfoResp, crate::errors::storage_admin_service::ListClusterInfoError>>;
    }

    struct Args_StorageAdminService_transLeader<'a> {
        req: &'a crate::types::TransLeaderReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_StorageAdminService_transLeader<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "StorageAdminService.transLeader"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_StorageAdminService_addPart<'a> {
        req: &'a crate::types::AddPartReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_StorageAdminService_addPart<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "StorageAdminService.addPart"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_StorageAdminService_addLearner<'a> {
        req: &'a crate::types::AddLearnerReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_StorageAdminService_addLearner<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "StorageAdminService.addLearner"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_StorageAdminService_removePart<'a> {
        req: &'a crate::types::RemovePartReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_StorageAdminService_removePart<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "StorageAdminService.removePart"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_StorageAdminService_memberChange<'a> {
        req: &'a crate::types::MemberChangeReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_StorageAdminService_memberChange<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "StorageAdminService.memberChange"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_StorageAdminService_waitingForCatchUpData<'a> {
        req: &'a crate::types::CatchUpDataReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_StorageAdminService_waitingForCatchUpData<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "StorageAdminService.waitingForCatchUpData"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_StorageAdminService_createCheckpoint<'a> {
        req: &'a crate::types::CreateCPRequest,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_StorageAdminService_createCheckpoint<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "StorageAdminService.createCheckpoint"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_StorageAdminService_dropCheckpoint<'a> {
        req: &'a crate::types::DropCPRequest,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_StorageAdminService_dropCheckpoint<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "StorageAdminService.dropCheckpoint"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_StorageAdminService_blockingWrites<'a> {
        req: &'a crate::types::BlockingSignRequest,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_StorageAdminService_blockingWrites<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "StorageAdminService.blockingWrites"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_StorageAdminService_rebuildTagIndex<'a> {
        req: &'a crate::types::RebuildIndexRequest,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_StorageAdminService_rebuildTagIndex<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "StorageAdminService.rebuildTagIndex"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_StorageAdminService_rebuildEdgeIndex<'a> {
        req: &'a crate::types::RebuildIndexRequest,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_StorageAdminService_rebuildEdgeIndex<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "StorageAdminService.rebuildEdgeIndex"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_StorageAdminService_getLeaderParts<'a> {
        req: &'a crate::types::GetLeaderReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_StorageAdminService_getLeaderParts<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "StorageAdminService.getLeaderParts"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_StorageAdminService_checkPeers<'a> {
        req: &'a crate::types::CheckPeersReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_StorageAdminService_checkPeers<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "StorageAdminService.checkPeers"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_StorageAdminService_addAdminTask<'a> {
        req: &'a crate::types::AddAdminTaskRequest,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_StorageAdminService_addAdminTask<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "StorageAdminService.addAdminTask"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_StorageAdminService_stopAdminTask<'a> {
        req: &'a crate::types::StopAdminTaskRequest,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_StorageAdminService_stopAdminTask<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "StorageAdminService.stopAdminTask"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_StorageAdminService_listClusterInfo<'a> {
        req: &'a crate::types::ListClusterInfoReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_StorageAdminService_listClusterInfo<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "StorageAdminService.listClusterInfo"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P, T, S> StorageAdminService for StorageAdminServiceImpl<P, T, S>
    where
        P: ::fbthrift::Protocol,
        T: ::fbthrift::Transport,
        P::Frame: ::fbthrift::Framing<DecBuf = ::fbthrift::FramingDecoded<T>>,
        ::fbthrift::ProtocolEncoded<P>: ::fbthrift::BufMutExt<Final = ::fbthrift::FramingEncodedFinal<T>>,
        P::Deserializer: ::std::marker::Send,
        S: ::fbthrift::help::Spawner,
    {
        fn transLeader(
            &self,
            arg_req: &crate::types::TransLeaderReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::TransLeaderError>> {
            let rpc_options = T::RpcOptions::default();
            self._transLeader_impl(
                arg_req,
                rpc_options,
            )
        }
        fn addPart(
            &self,
            arg_req: &crate::types::AddPartReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::AddPartError>> {
            let rpc_options = T::RpcOptions::default();
            self._addPart_impl(
                arg_req,
                rpc_options,
            )
        }
        fn addLearner(
            &self,
            arg_req: &crate::types::AddLearnerReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::AddLearnerError>> {
            let rpc_options = T::RpcOptions::default();
            self._addLearner_impl(
                arg_req,
                rpc_options,
            )
        }
        fn removePart(
            &self,
            arg_req: &crate::types::RemovePartReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::RemovePartError>> {
            let rpc_options = T::RpcOptions::default();
            self._removePart_impl(
                arg_req,
                rpc_options,
            )
        }
        fn memberChange(
            &self,
            arg_req: &crate::types::MemberChangeReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::MemberChangeError>> {
            let rpc_options = T::RpcOptions::default();
            self._memberChange_impl(
                arg_req,
                rpc_options,
            )
        }
        fn waitingForCatchUpData(
            &self,
            arg_req: &crate::types::CatchUpDataReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::WaitingForCatchUpDataError>> {
            let rpc_options = T::RpcOptions::default();
            self._waitingForCatchUpData_impl(
                arg_req,
                rpc_options,
            )
        }
        fn createCheckpoint(
            &self,
            arg_req: &crate::types::CreateCPRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::CreateCPResp, crate::errors::storage_admin_service::CreateCheckpointError>> {
            let rpc_options = T::RpcOptions::default();
            self._createCheckpoint_impl(
                arg_req,
                rpc_options,
            )
        }
        fn dropCheckpoint(
            &self,
            arg_req: &crate::types::DropCPRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::DropCheckpointError>> {
            let rpc_options = T::RpcOptions::default();
            self._dropCheckpoint_impl(
                arg_req,
                rpc_options,
            )
        }
        fn blockingWrites(
            &self,
            arg_req: &crate::types::BlockingSignRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::BlockingWritesError>> {
            let rpc_options = T::RpcOptions::default();
            self._blockingWrites_impl(
                arg_req,
                rpc_options,
            )
        }
        fn rebuildTagIndex(
            &self,
            arg_req: &crate::types::RebuildIndexRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::RebuildTagIndexError>> {
            let rpc_options = T::RpcOptions::default();
            self._rebuildTagIndex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn rebuildEdgeIndex(
            &self,
            arg_req: &crate::types::RebuildIndexRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::RebuildEdgeIndexError>> {
            let rpc_options = T::RpcOptions::default();
            self._rebuildEdgeIndex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getLeaderParts(
            &self,
            arg_req: &crate::types::GetLeaderReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetLeaderPartsResp, crate::errors::storage_admin_service::GetLeaderPartsError>> {
            let rpc_options = T::RpcOptions::default();
            self._getLeaderParts_impl(
                arg_req,
                rpc_options,
            )
        }
        fn checkPeers(
            &self,
            arg_req: &crate::types::CheckPeersReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::CheckPeersError>> {
            let rpc_options = T::RpcOptions::default();
            self._checkPeers_impl(
                arg_req,
                rpc_options,
            )
        }
        fn addAdminTask(
            &self,
            arg_req: &crate::types::AddAdminTaskRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::AddAdminTaskError>> {
            let rpc_options = T::RpcOptions::default();
            self._addAdminTask_impl(
                arg_req,
                rpc_options,
            )
        }
        fn stopAdminTask(
            &self,
            arg_req: &crate::types::StopAdminTaskRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::StopAdminTaskError>> {
            let rpc_options = T::RpcOptions::default();
            self._stopAdminTask_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listClusterInfo(
            &self,
            arg_req: &crate::types::ListClusterInfoReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListClusterInfoResp, crate::errors::storage_admin_service::ListClusterInfoError>> {
            let rpc_options = T::RpcOptions::default();
            self._listClusterInfo_impl(
                arg_req,
                rpc_options,
            )
        }
    }

    impl<P, T, S> StorageAdminServiceExt<T> for StorageAdminServiceImpl<P, T, S>
    where
        P: ::fbthrift::Protocol,
        T: ::fbthrift::Transport,
        P::Frame: ::fbthrift::Framing<DecBuf = ::fbthrift::FramingDecoded<T>>,
        ::fbthrift::ProtocolEncoded<P>: ::fbthrift::BufMutExt<Final = ::fbthrift::FramingEncodedFinal<T>>,
        P::Deserializer: ::std::marker::Send,
        S: ::fbthrift::help::Spawner,
    {
        fn transLeader_with_rpc_opts(
            &self,
            arg_req: &crate::types::TransLeaderReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::TransLeaderError>> {
            self._transLeader_impl(
                arg_req,
                rpc_options,
            )
        }
        fn addPart_with_rpc_opts(
            &self,
            arg_req: &crate::types::AddPartReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::AddPartError>> {
            self._addPart_impl(
                arg_req,
                rpc_options,
            )
        }
        fn addLearner_with_rpc_opts(
            &self,
            arg_req: &crate::types::AddLearnerReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::AddLearnerError>> {
            self._addLearner_impl(
                arg_req,
                rpc_options,
            )
        }
        fn removePart_with_rpc_opts(
            &self,
            arg_req: &crate::types::RemovePartReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::RemovePartError>> {
            self._removePart_impl(
                arg_req,
                rpc_options,
            )
        }
        fn memberChange_with_rpc_opts(
            &self,
            arg_req: &crate::types::MemberChangeReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::MemberChangeError>> {
            self._memberChange_impl(
                arg_req,
                rpc_options,
            )
        }
        fn waitingForCatchUpData_with_rpc_opts(
            &self,
            arg_req: &crate::types::CatchUpDataReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::WaitingForCatchUpDataError>> {
            self._waitingForCatchUpData_impl(
                arg_req,
                rpc_options,
            )
        }
        fn createCheckpoint_with_rpc_opts(
            &self,
            arg_req: &crate::types::CreateCPRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::CreateCPResp, crate::errors::storage_admin_service::CreateCheckpointError>> {
            self._createCheckpoint_impl(
                arg_req,
                rpc_options,
            )
        }
        fn dropCheckpoint_with_rpc_opts(
            &self,
            arg_req: &crate::types::DropCPRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::DropCheckpointError>> {
            self._dropCheckpoint_impl(
                arg_req,
                rpc_options,
            )
        }
        fn blockingWrites_with_rpc_opts(
            &self,
            arg_req: &crate::types::BlockingSignRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::BlockingWritesError>> {
            self._blockingWrites_impl(
                arg_req,
                rpc_options,
            )
        }
        fn rebuildTagIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::RebuildIndexRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::RebuildTagIndexError>> {
            self._rebuildTagIndex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn rebuildEdgeIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::RebuildIndexRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::RebuildEdgeIndexError>> {
            self._rebuildEdgeIndex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getLeaderParts_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetLeaderReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetLeaderPartsResp, crate::errors::storage_admin_service::GetLeaderPartsError>> {
            self._getLeaderParts_impl(
                arg_req,
                rpc_options,
            )
        }
        fn checkPeers_with_rpc_opts(
            &self,
            arg_req: &crate::types::CheckPeersReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::CheckPeersError>> {
            self._checkPeers_impl(
                arg_req,
                rpc_options,
            )
        }
        fn addAdminTask_with_rpc_opts(
            &self,
            arg_req: &crate::types::AddAdminTaskRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::AddAdminTaskError>> {
            self._addAdminTask_impl(
                arg_req,
                rpc_options,
            )
        }
        fn stopAdminTask_with_rpc_opts(
            &self,
            arg_req: &crate::types::StopAdminTaskRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::StopAdminTaskError>> {
            self._stopAdminTask_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listClusterInfo_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListClusterInfoReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListClusterInfoResp, crate::errors::storage_admin_service::ListClusterInfoError>> {
            self._listClusterInfo_impl(
                arg_req,
                rpc_options,
            )
        }
    }

    impl<'a, S> StorageAdminService for S
    where
        S: ::std::convert::AsRef<dyn StorageAdminService + 'a>,
        S: ::std::marker::Send,
    {
        fn transLeader(
            &self,
            arg_req: &crate::types::TransLeaderReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::TransLeaderError>> {
            self.as_ref().transLeader(
                arg_req,
            )
        }
        fn addPart(
            &self,
            arg_req: &crate::types::AddPartReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::AddPartError>> {
            self.as_ref().addPart(
                arg_req,
            )
        }
        fn addLearner(
            &self,
            arg_req: &crate::types::AddLearnerReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::AddLearnerError>> {
            self.as_ref().addLearner(
                arg_req,
            )
        }
        fn removePart(
            &self,
            arg_req: &crate::types::RemovePartReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::RemovePartError>> {
            self.as_ref().removePart(
                arg_req,
            )
        }
        fn memberChange(
            &self,
            arg_req: &crate::types::MemberChangeReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::MemberChangeError>> {
            self.as_ref().memberChange(
                arg_req,
            )
        }
        fn waitingForCatchUpData(
            &self,
            arg_req: &crate::types::CatchUpDataReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::WaitingForCatchUpDataError>> {
            self.as_ref().waitingForCatchUpData(
                arg_req,
            )
        }
        fn createCheckpoint(
            &self,
            arg_req: &crate::types::CreateCPRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::CreateCPResp, crate::errors::storage_admin_service::CreateCheckpointError>> {
            self.as_ref().createCheckpoint(
                arg_req,
            )
        }
        fn dropCheckpoint(
            &self,
            arg_req: &crate::types::DropCPRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::DropCheckpointError>> {
            self.as_ref().dropCheckpoint(
                arg_req,
            )
        }
        fn blockingWrites(
            &self,
            arg_req: &crate::types::BlockingSignRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::BlockingWritesError>> {
            self.as_ref().blockingWrites(
                arg_req,
            )
        }
        fn rebuildTagIndex(
            &self,
            arg_req: &crate::types::RebuildIndexRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::RebuildTagIndexError>> {
            self.as_ref().rebuildTagIndex(
                arg_req,
            )
        }
        fn rebuildEdgeIndex(
            &self,
            arg_req: &crate::types::RebuildIndexRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::RebuildEdgeIndexError>> {
            self.as_ref().rebuildEdgeIndex(
                arg_req,
            )
        }
        fn getLeaderParts(
            &self,
            arg_req: &crate::types::GetLeaderReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetLeaderPartsResp, crate::errors::storage_admin_service::GetLeaderPartsError>> {
            self.as_ref().getLeaderParts(
                arg_req,
            )
        }
        fn checkPeers(
            &self,
            arg_req: &crate::types::CheckPeersReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::CheckPeersError>> {
            self.as_ref().checkPeers(
                arg_req,
            )
        }
        fn addAdminTask(
            &self,
            arg_req: &crate::types::AddAdminTaskRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::AddAdminTaskError>> {
            self.as_ref().addAdminTask(
                arg_req,
            )
        }
        fn stopAdminTask(
            &self,
            arg_req: &crate::types::StopAdminTaskRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::StopAdminTaskError>> {
            self.as_ref().stopAdminTask(
                arg_req,
            )
        }
        fn listClusterInfo(
            &self,
            arg_req: &crate::types::ListClusterInfoReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListClusterInfoResp, crate::errors::storage_admin_service::ListClusterInfoError>> {
            self.as_ref().listClusterInfo(
                arg_req,
            )
        }
    }

    impl<'a, S, T> StorageAdminServiceExt<T> for S
    where
        S: ::std::convert::AsRef<dyn StorageAdminService + 'a>,
        S: ::std::convert::AsRef<dyn StorageAdminServiceExt<T> + 'a>,
        S: ::std::marker::Send,
        T: ::fbthrift::Transport,
    {
        fn transLeader_with_rpc_opts(
            &self,
            arg_req: &crate::types::TransLeaderReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::TransLeaderError>> {
            <Self as ::std::convert::AsRef<dyn StorageAdminServiceExt<T>>>::as_ref(self).transLeader_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn addPart_with_rpc_opts(
            &self,
            arg_req: &crate::types::AddPartReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::AddPartError>> {
            <Self as ::std::convert::AsRef<dyn StorageAdminServiceExt<T>>>::as_ref(self).addPart_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn addLearner_with_rpc_opts(
            &self,
            arg_req: &crate::types::AddLearnerReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::AddLearnerError>> {
            <Self as ::std::convert::AsRef<dyn StorageAdminServiceExt<T>>>::as_ref(self).addLearner_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn removePart_with_rpc_opts(
            &self,
            arg_req: &crate::types::RemovePartReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::RemovePartError>> {
            <Self as ::std::convert::AsRef<dyn StorageAdminServiceExt<T>>>::as_ref(self).removePart_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn memberChange_with_rpc_opts(
            &self,
            arg_req: &crate::types::MemberChangeReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::MemberChangeError>> {
            <Self as ::std::convert::AsRef<dyn StorageAdminServiceExt<T>>>::as_ref(self).memberChange_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn waitingForCatchUpData_with_rpc_opts(
            &self,
            arg_req: &crate::types::CatchUpDataReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::WaitingForCatchUpDataError>> {
            <Self as ::std::convert::AsRef<dyn StorageAdminServiceExt<T>>>::as_ref(self).waitingForCatchUpData_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn createCheckpoint_with_rpc_opts(
            &self,
            arg_req: &crate::types::CreateCPRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::CreateCPResp, crate::errors::storage_admin_service::CreateCheckpointError>> {
            <Self as ::std::convert::AsRef<dyn StorageAdminServiceExt<T>>>::as_ref(self).createCheckpoint_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn dropCheckpoint_with_rpc_opts(
            &self,
            arg_req: &crate::types::DropCPRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::DropCheckpointError>> {
            <Self as ::std::convert::AsRef<dyn StorageAdminServiceExt<T>>>::as_ref(self).dropCheckpoint_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn blockingWrites_with_rpc_opts(
            &self,
            arg_req: &crate::types::BlockingSignRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::BlockingWritesError>> {
            <Self as ::std::convert::AsRef<dyn StorageAdminServiceExt<T>>>::as_ref(self).blockingWrites_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn rebuildTagIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::RebuildIndexRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::RebuildTagIndexError>> {
            <Self as ::std::convert::AsRef<dyn StorageAdminServiceExt<T>>>::as_ref(self).rebuildTagIndex_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn rebuildEdgeIndex_with_rpc_opts(
            &self,
            arg_req: &crate::types::RebuildIndexRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::RebuildEdgeIndexError>> {
            <Self as ::std::convert::AsRef<dyn StorageAdminServiceExt<T>>>::as_ref(self).rebuildEdgeIndex_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn getLeaderParts_with_rpc_opts(
            &self,
            arg_req: &crate::types::GetLeaderReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetLeaderPartsResp, crate::errors::storage_admin_service::GetLeaderPartsError>> {
            <Self as ::std::convert::AsRef<dyn StorageAdminServiceExt<T>>>::as_ref(self).getLeaderParts_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn checkPeers_with_rpc_opts(
            &self,
            arg_req: &crate::types::CheckPeersReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::CheckPeersError>> {
            <Self as ::std::convert::AsRef<dyn StorageAdminServiceExt<T>>>::as_ref(self).checkPeers_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn addAdminTask_with_rpc_opts(
            &self,
            arg_req: &crate::types::AddAdminTaskRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::AddAdminTaskError>> {
            <Self as ::std::convert::AsRef<dyn StorageAdminServiceExt<T>>>::as_ref(self).addAdminTask_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn stopAdminTask_with_rpc_opts(
            &self,
            arg_req: &crate::types::StopAdminTaskRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::StopAdminTaskError>> {
            <Self as ::std::convert::AsRef<dyn StorageAdminServiceExt<T>>>::as_ref(self).stopAdminTask_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn listClusterInfo_with_rpc_opts(
            &self,
            arg_req: &crate::types::ListClusterInfoReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListClusterInfoResp, crate::errors::storage_admin_service::ListClusterInfoError>> {
            <Self as ::std::convert::AsRef<dyn StorageAdminServiceExt<T>>>::as_ref(self).listClusterInfo_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
    }

    #[derive(Clone)]
    pub struct make_StorageAdminService;

    /// To be called by user directly setting up a client. Avoids
    /// needing ClientFactory trait in scope, avoids unidiomatic
    /// make_Trait name.
    ///
    /// ```
    /// # const _: &str = stringify! {
    /// use bgs::client::BuckGraphService;
    ///
    /// let protocol = BinaryProtocol::new();
    /// let transport = HttpClient::new();
    /// let client = <dyn BuckGraphService>::new(protocol, transport);
    /// # };
    /// ```
    impl dyn StorageAdminService {
        pub fn new<P, T>(
            protocol: P,
            transport: T,
        ) -> ::std::sync::Arc<impl StorageAdminService + ::std::marker::Send + ::std::marker::Sync + 'static>
        where
            P: ::fbthrift::Protocol<Frame = T>,
            T: ::fbthrift::Transport,
            P::Deserializer: ::std::marker::Send,
        {
            let spawner = ::fbthrift::help::NoopSpawner;
            Self::with_spawner(protocol, transport, spawner)
        }

        pub fn with_spawner<P, T, S>(
            protocol: P,
            transport: T,
            spawner: S,
        ) -> ::std::sync::Arc<impl StorageAdminService + ::std::marker::Send + ::std::marker::Sync + 'static>
        where
            P: ::fbthrift::Protocol<Frame = T>,
            T: ::fbthrift::Transport,
            P::Deserializer: ::std::marker::Send,
            S: ::fbthrift::help::Spawner,
        {
            let _ = protocol;
            let _ = spawner;
            ::std::sync::Arc::new(StorageAdminServiceImpl::<P, T, S>::new(transport))
        }
    }

    impl<T> dyn StorageAdminServiceExt<T>
    where
        T: ::fbthrift::Transport,
    {
        pub fn new<P>(
            protocol: P,
            transport: T,
        ) -> ::std::sync::Arc<impl StorageAdminServiceExt<T> + ::std::marker::Send + ::std::marker::Sync + 'static>
        where
            P: ::fbthrift::Protocol<Frame = T>,
            P::Deserializer: ::std::marker::Send,
        {
            let spawner = ::fbthrift::help::NoopSpawner;
            Self::with_spawner(protocol, transport, spawner)
        }

        pub fn with_spawner<P, S>(
            protocol: P,
            transport: T,
            spawner: S,
        ) -> ::std::sync::Arc<impl StorageAdminServiceExt<T> + ::std::marker::Send + ::std::marker::Sync + 'static>
        where
            P: ::fbthrift::Protocol<Frame = T>,
            P::Deserializer: ::std::marker::Send,
            S: ::fbthrift::help::Spawner,
        {
            let _ = protocol;
            let _ = spawner;
            ::std::sync::Arc::new(StorageAdminServiceImpl::<P, T, S>::new(transport))
        }
    }

    pub type StorageAdminServiceDynClient = <make_StorageAdminService as ::fbthrift::ClientFactory>::Api;
    pub type StorageAdminServiceClient = ::std::sync::Arc<StorageAdminServiceDynClient>;

    /// The same thing, but to be called from generic contexts where we are
    /// working with a type parameter `C: ClientFactory` to produce clients.
    impl ::fbthrift::ClientFactory for make_StorageAdminService {
        type Api = dyn StorageAdminService + ::std::marker::Send + ::std::marker::Sync + 'static;

        fn with_spawner<P, T, S>(protocol: P, transport: T, spawner: S) -> ::std::sync::Arc<Self::Api>
        where
            P: ::fbthrift::Protocol<Frame = T>,
            T: ::fbthrift::Transport,
            P::Deserializer: ::std::marker::Send,
            S: ::fbthrift::help::Spawner,
        {
            <dyn StorageAdminService>::with_spawner(protocol, transport, spawner)
        }
    }


    pub struct GeneralStorageServiceImpl<P, T, S = ::fbthrift::NoopSpawner> {
        transport: T,
        _phantom: ::std::marker::PhantomData<fn() -> (P, S)>,
    }

    impl<P, T, S> GeneralStorageServiceImpl<P, T, S>
    where
        P: ::fbthrift::Protocol,
        T: ::fbthrift::Transport,
        P::Frame: ::fbthrift::Framing<DecBuf = ::fbthrift::FramingDecoded<T>>,
        ::fbthrift::ProtocolEncoded<P>: ::fbthrift::BufMutExt<Final = ::fbthrift::FramingEncodedFinal<T>>,
        P::Deserializer: ::std::marker::Send,
        S: ::fbthrift::help::Spawner,
    {
        pub fn new(
            transport: T,
        ) -> Self {
            Self {
                transport,
                _phantom: ::std::marker::PhantomData,
            }
        }

        pub fn transport(&self) -> &T {
            &self.transport
        }


        fn _get_impl(
            &self,
            arg_req: &crate::types::KVGetRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::KVGetResponse, crate::errors::general_storage_service::GetError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "GeneralStorageService";
                METHOD_NAME = "GeneralStorageService.get";
            }
            let args = self::Args_GeneralStorageService_get {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("get", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "GeneralStorageService.get"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::general_storage_service::GetExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::general_storage_service::GetError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("GeneralStorageService.get"))
            .boxed()
        }

        fn _put_impl(
            &self,
            arg_req: &crate::types::KVPutRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::general_storage_service::PutError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "GeneralStorageService";
                METHOD_NAME = "GeneralStorageService.put";
            }
            let args = self::Args_GeneralStorageService_put {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("put", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "GeneralStorageService.put"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::general_storage_service::PutExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::general_storage_service::PutError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("GeneralStorageService.put"))
            .boxed()
        }

        fn _remove_impl(
            &self,
            arg_req: &crate::types::KVRemoveRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::general_storage_service::RemoveError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "GeneralStorageService";
                METHOD_NAME = "GeneralStorageService.remove";
            }
            let args = self::Args_GeneralStorageService_remove {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("remove", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "GeneralStorageService.remove"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::general_storage_service::RemoveExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::general_storage_service::RemoveError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("GeneralStorageService.remove"))
            .boxed()
        }
    }

    pub trait GeneralStorageService: ::std::marker::Send {
        fn get(
            &self,
            arg_req: &crate::types::KVGetRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::KVGetResponse, crate::errors::general_storage_service::GetError>>;

        fn put(
            &self,
            arg_req: &crate::types::KVPutRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::general_storage_service::PutError>>;

        fn remove(
            &self,
            arg_req: &crate::types::KVRemoveRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::general_storage_service::RemoveError>>;
    }

    pub trait GeneralStorageServiceExt<T>: GeneralStorageService
    where
        T: ::fbthrift::Transport,
    {
        fn get_with_rpc_opts(
            &self,
            arg_req: &crate::types::KVGetRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::KVGetResponse, crate::errors::general_storage_service::GetError>>;
        fn put_with_rpc_opts(
            &self,
            arg_req: &crate::types::KVPutRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::general_storage_service::PutError>>;
        fn remove_with_rpc_opts(
            &self,
            arg_req: &crate::types::KVRemoveRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::general_storage_service::RemoveError>>;
    }

    struct Args_GeneralStorageService_get<'a> {
        req: &'a crate::types::KVGetRequest,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_GeneralStorageService_get<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "GeneralStorageService.get"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_GeneralStorageService_put<'a> {
        req: &'a crate::types::KVPutRequest,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_GeneralStorageService_put<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "GeneralStorageService.put"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_GeneralStorageService_remove<'a> {
        req: &'a crate::types::KVRemoveRequest,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_GeneralStorageService_remove<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "GeneralStorageService.remove"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P, T, S> GeneralStorageService for GeneralStorageServiceImpl<P, T, S>
    where
        P: ::fbthrift::Protocol,
        T: ::fbthrift::Transport,
        P::Frame: ::fbthrift::Framing<DecBuf = ::fbthrift::FramingDecoded<T>>,
        ::fbthrift::ProtocolEncoded<P>: ::fbthrift::BufMutExt<Final = ::fbthrift::FramingEncodedFinal<T>>,
        P::Deserializer: ::std::marker::Send,
        S: ::fbthrift::help::Spawner,
    {
        fn get(
            &self,
            arg_req: &crate::types::KVGetRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::KVGetResponse, crate::errors::general_storage_service::GetError>> {
            let rpc_options = T::RpcOptions::default();
            self._get_impl(
                arg_req,
                rpc_options,
            )
        }
        fn put(
            &self,
            arg_req: &crate::types::KVPutRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::general_storage_service::PutError>> {
            let rpc_options = T::RpcOptions::default();
            self._put_impl(
                arg_req,
                rpc_options,
            )
        }
        fn remove(
            &self,
            arg_req: &crate::types::KVRemoveRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::general_storage_service::RemoveError>> {
            let rpc_options = T::RpcOptions::default();
            self._remove_impl(
                arg_req,
                rpc_options,
            )
        }
    }

    impl<P, T, S> GeneralStorageServiceExt<T> for GeneralStorageServiceImpl<P, T, S>
    where
        P: ::fbthrift::Protocol,
        T: ::fbthrift::Transport,
        P::Frame: ::fbthrift::Framing<DecBuf = ::fbthrift::FramingDecoded<T>>,
        ::fbthrift::ProtocolEncoded<P>: ::fbthrift::BufMutExt<Final = ::fbthrift::FramingEncodedFinal<T>>,
        P::Deserializer: ::std::marker::Send,
        S: ::fbthrift::help::Spawner,
    {
        fn get_with_rpc_opts(
            &self,
            arg_req: &crate::types::KVGetRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::KVGetResponse, crate::errors::general_storage_service::GetError>> {
            self._get_impl(
                arg_req,
                rpc_options,
            )
        }
        fn put_with_rpc_opts(
            &self,
            arg_req: &crate::types::KVPutRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::general_storage_service::PutError>> {
            self._put_impl(
                arg_req,
                rpc_options,
            )
        }
        fn remove_with_rpc_opts(
            &self,
            arg_req: &crate::types::KVRemoveRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::general_storage_service::RemoveError>> {
            self._remove_impl(
                arg_req,
                rpc_options,
            )
        }
    }

    impl<'a, S> GeneralStorageService for S
    where
        S: ::std::convert::AsRef<dyn GeneralStorageService + 'a>,
        S: ::std::marker::Send,
    {
        fn get(
            &self,
            arg_req: &crate::types::KVGetRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::KVGetResponse, crate::errors::general_storage_service::GetError>> {
            self.as_ref().get(
                arg_req,
            )
        }
        fn put(
            &self,
            arg_req: &crate::types::KVPutRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::general_storage_service::PutError>> {
            self.as_ref().put(
                arg_req,
            )
        }
        fn remove(
            &self,
            arg_req: &crate::types::KVRemoveRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::general_storage_service::RemoveError>> {
            self.as_ref().remove(
                arg_req,
            )
        }
    }

    impl<'a, S, T> GeneralStorageServiceExt<T> for S
    where
        S: ::std::convert::AsRef<dyn GeneralStorageService + 'a>,
        S: ::std::convert::AsRef<dyn GeneralStorageServiceExt<T> + 'a>,
        S: ::std::marker::Send,
        T: ::fbthrift::Transport,
    {
        fn get_with_rpc_opts(
            &self,
            arg_req: &crate::types::KVGetRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::KVGetResponse, crate::errors::general_storage_service::GetError>> {
            <Self as ::std::convert::AsRef<dyn GeneralStorageServiceExt<T>>>::as_ref(self).get_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn put_with_rpc_opts(
            &self,
            arg_req: &crate::types::KVPutRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::general_storage_service::PutError>> {
            <Self as ::std::convert::AsRef<dyn GeneralStorageServiceExt<T>>>::as_ref(self).put_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn remove_with_rpc_opts(
            &self,
            arg_req: &crate::types::KVRemoveRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::general_storage_service::RemoveError>> {
            <Self as ::std::convert::AsRef<dyn GeneralStorageServiceExt<T>>>::as_ref(self).remove_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
    }

    #[derive(Clone)]
    pub struct make_GeneralStorageService;

    /// To be called by user directly setting up a client. Avoids
    /// needing ClientFactory trait in scope, avoids unidiomatic
    /// make_Trait name.
    ///
    /// ```
    /// # const _: &str = stringify! {
    /// use bgs::client::BuckGraphService;
    ///
    /// let protocol = BinaryProtocol::new();
    /// let transport = HttpClient::new();
    /// let client = <dyn BuckGraphService>::new(protocol, transport);
    /// # };
    /// ```
    impl dyn GeneralStorageService {
        pub fn new<P, T>(
            protocol: P,
            transport: T,
        ) -> ::std::sync::Arc<impl GeneralStorageService + ::std::marker::Send + ::std::marker::Sync + 'static>
        where
            P: ::fbthrift::Protocol<Frame = T>,
            T: ::fbthrift::Transport,
            P::Deserializer: ::std::marker::Send,
        {
            let spawner = ::fbthrift::help::NoopSpawner;
            Self::with_spawner(protocol, transport, spawner)
        }

        pub fn with_spawner<P, T, S>(
            protocol: P,
            transport: T,
            spawner: S,
        ) -> ::std::sync::Arc<impl GeneralStorageService + ::std::marker::Send + ::std::marker::Sync + 'static>
        where
            P: ::fbthrift::Protocol<Frame = T>,
            T: ::fbthrift::Transport,
            P::Deserializer: ::std::marker::Send,
            S: ::fbthrift::help::Spawner,
        {
            let _ = protocol;
            let _ = spawner;
            ::std::sync::Arc::new(GeneralStorageServiceImpl::<P, T, S>::new(transport))
        }
    }

    impl<T> dyn GeneralStorageServiceExt<T>
    where
        T: ::fbthrift::Transport,
    {
        pub fn new<P>(
            protocol: P,
            transport: T,
        ) -> ::std::sync::Arc<impl GeneralStorageServiceExt<T> + ::std::marker::Send + ::std::marker::Sync + 'static>
        where
            P: ::fbthrift::Protocol<Frame = T>,
            P::Deserializer: ::std::marker::Send,
        {
            let spawner = ::fbthrift::help::NoopSpawner;
            Self::with_spawner(protocol, transport, spawner)
        }

        pub fn with_spawner<P, S>(
            protocol: P,
            transport: T,
            spawner: S,
        ) -> ::std::sync::Arc<impl GeneralStorageServiceExt<T> + ::std::marker::Send + ::std::marker::Sync + 'static>
        where
            P: ::fbthrift::Protocol<Frame = T>,
            P::Deserializer: ::std::marker::Send,
            S: ::fbthrift::help::Spawner,
        {
            let _ = protocol;
            let _ = spawner;
            ::std::sync::Arc::new(GeneralStorageServiceImpl::<P, T, S>::new(transport))
        }
    }

    pub type GeneralStorageServiceDynClient = <make_GeneralStorageService as ::fbthrift::ClientFactory>::Api;
    pub type GeneralStorageServiceClient = ::std::sync::Arc<GeneralStorageServiceDynClient>;

    /// The same thing, but to be called from generic contexts where we are
    /// working with a type parameter `C: ClientFactory` to produce clients.
    impl ::fbthrift::ClientFactory for make_GeneralStorageService {
        type Api = dyn GeneralStorageService + ::std::marker::Send + ::std::marker::Sync + 'static;

        fn with_spawner<P, T, S>(protocol: P, transport: T, spawner: S) -> ::std::sync::Arc<Self::Api>
        where
            P: ::fbthrift::Protocol<Frame = T>,
            T: ::fbthrift::Transport,
            P::Deserializer: ::std::marker::Send,
            S: ::fbthrift::help::Spawner,
        {
            <dyn GeneralStorageService>::with_spawner(protocol, transport, spawner)
        }
    }


    pub struct InternalStorageServiceImpl<P, T, S = ::fbthrift::NoopSpawner> {
        transport: T,
        _phantom: ::std::marker::PhantomData<fn() -> (P, S)>,
    }

    impl<P, T, S> InternalStorageServiceImpl<P, T, S>
    where
        P: ::fbthrift::Protocol,
        T: ::fbthrift::Transport,
        P::Frame: ::fbthrift::Framing<DecBuf = ::fbthrift::FramingDecoded<T>>,
        ::fbthrift::ProtocolEncoded<P>: ::fbthrift::BufMutExt<Final = ::fbthrift::FramingEncodedFinal<T>>,
        P::Deserializer: ::std::marker::Send,
        S: ::fbthrift::help::Spawner,
    {
        pub fn new(
            transport: T,
        ) -> Self {
            Self {
                transport,
                _phantom: ::std::marker::PhantomData,
            }
        }

        pub fn transport(&self) -> &T {
            &self.transport
        }


        fn _chainAddEdges_impl(
            &self,
            arg_req: &crate::types::ChainAddEdgesRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::internal_storage_service::ChainAddEdgesError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "InternalStorageService";
                METHOD_NAME = "InternalStorageService.chainAddEdges";
            }
            let args = self::Args_InternalStorageService_chainAddEdges {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("chainAddEdges", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "InternalStorageService.chainAddEdges"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::internal_storage_service::ChainAddEdgesExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::internal_storage_service::ChainAddEdgesError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("InternalStorageService.chainAddEdges"))
            .boxed()
        }

        fn _chainUpdateEdge_impl(
            &self,
            arg_req: &crate::types::ChainUpdateEdgeRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::UpdateResponse, crate::errors::internal_storage_service::ChainUpdateEdgeError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "InternalStorageService";
                METHOD_NAME = "InternalStorageService.chainUpdateEdge";
            }
            let args = self::Args_InternalStorageService_chainUpdateEdge {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("chainUpdateEdge", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "InternalStorageService.chainUpdateEdge"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::internal_storage_service::ChainUpdateEdgeExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::internal_storage_service::ChainUpdateEdgeError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("InternalStorageService.chainUpdateEdge"))
            .boxed()
        }
    }

    pub trait InternalStorageService: ::std::marker::Send {
        fn chainAddEdges(
            &self,
            arg_req: &crate::types::ChainAddEdgesRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::internal_storage_service::ChainAddEdgesError>>;

        fn chainUpdateEdge(
            &self,
            arg_req: &crate::types::ChainUpdateEdgeRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::UpdateResponse, crate::errors::internal_storage_service::ChainUpdateEdgeError>>;
    }

    pub trait InternalStorageServiceExt<T>: InternalStorageService
    where
        T: ::fbthrift::Transport,
    {
        fn chainAddEdges_with_rpc_opts(
            &self,
            arg_req: &crate::types::ChainAddEdgesRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::internal_storage_service::ChainAddEdgesError>>;
        fn chainUpdateEdge_with_rpc_opts(
            &self,
            arg_req: &crate::types::ChainUpdateEdgeRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::UpdateResponse, crate::errors::internal_storage_service::ChainUpdateEdgeError>>;
    }

    struct Args_InternalStorageService_chainAddEdges<'a> {
        req: &'a crate::types::ChainAddEdgesRequest,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_InternalStorageService_chainAddEdges<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "InternalStorageService.chainAddEdges"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_InternalStorageService_chainUpdateEdge<'a> {
        req: &'a crate::types::ChainUpdateEdgeRequest,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_InternalStorageService_chainUpdateEdge<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "InternalStorageService.chainUpdateEdge"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P, T, S> InternalStorageService for InternalStorageServiceImpl<P, T, S>
    where
        P: ::fbthrift::Protocol,
        T: ::fbthrift::Transport,
        P::Frame: ::fbthrift::Framing<DecBuf = ::fbthrift::FramingDecoded<T>>,
        ::fbthrift::ProtocolEncoded<P>: ::fbthrift::BufMutExt<Final = ::fbthrift::FramingEncodedFinal<T>>,
        P::Deserializer: ::std::marker::Send,
        S: ::fbthrift::help::Spawner,
    {
        fn chainAddEdges(
            &self,
            arg_req: &crate::types::ChainAddEdgesRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::internal_storage_service::ChainAddEdgesError>> {
            let rpc_options = T::RpcOptions::default();
            self._chainAddEdges_impl(
                arg_req,
                rpc_options,
            )
        }
        fn chainUpdateEdge(
            &self,
            arg_req: &crate::types::ChainUpdateEdgeRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::UpdateResponse, crate::errors::internal_storage_service::ChainUpdateEdgeError>> {
            let rpc_options = T::RpcOptions::default();
            self._chainUpdateEdge_impl(
                arg_req,
                rpc_options,
            )
        }
    }

    impl<P, T, S> InternalStorageServiceExt<T> for InternalStorageServiceImpl<P, T, S>
    where
        P: ::fbthrift::Protocol,
        T: ::fbthrift::Transport,
        P::Frame: ::fbthrift::Framing<DecBuf = ::fbthrift::FramingDecoded<T>>,
        ::fbthrift::ProtocolEncoded<P>: ::fbthrift::BufMutExt<Final = ::fbthrift::FramingEncodedFinal<T>>,
        P::Deserializer: ::std::marker::Send,
        S: ::fbthrift::help::Spawner,
    {
        fn chainAddEdges_with_rpc_opts(
            &self,
            arg_req: &crate::types::ChainAddEdgesRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::internal_storage_service::ChainAddEdgesError>> {
            self._chainAddEdges_impl(
                arg_req,
                rpc_options,
            )
        }
        fn chainUpdateEdge_with_rpc_opts(
            &self,
            arg_req: &crate::types::ChainUpdateEdgeRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::UpdateResponse, crate::errors::internal_storage_service::ChainUpdateEdgeError>> {
            self._chainUpdateEdge_impl(
                arg_req,
                rpc_options,
            )
        }
    }

    impl<'a, S> InternalStorageService for S
    where
        S: ::std::convert::AsRef<dyn InternalStorageService + 'a>,
        S: ::std::marker::Send,
    {
        fn chainAddEdges(
            &self,
            arg_req: &crate::types::ChainAddEdgesRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::internal_storage_service::ChainAddEdgesError>> {
            self.as_ref().chainAddEdges(
                arg_req,
            )
        }
        fn chainUpdateEdge(
            &self,
            arg_req: &crate::types::ChainUpdateEdgeRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::UpdateResponse, crate::errors::internal_storage_service::ChainUpdateEdgeError>> {
            self.as_ref().chainUpdateEdge(
                arg_req,
            )
        }
    }

    impl<'a, S, T> InternalStorageServiceExt<T> for S
    where
        S: ::std::convert::AsRef<dyn InternalStorageService + 'a>,
        S: ::std::convert::AsRef<dyn InternalStorageServiceExt<T> + 'a>,
        S: ::std::marker::Send,
        T: ::fbthrift::Transport,
    {
        fn chainAddEdges_with_rpc_opts(
            &self,
            arg_req: &crate::types::ChainAddEdgesRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::internal_storage_service::ChainAddEdgesError>> {
            <Self as ::std::convert::AsRef<dyn InternalStorageServiceExt<T>>>::as_ref(self).chainAddEdges_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn chainUpdateEdge_with_rpc_opts(
            &self,
            arg_req: &crate::types::ChainUpdateEdgeRequest,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::UpdateResponse, crate::errors::internal_storage_service::ChainUpdateEdgeError>> {
            <Self as ::std::convert::AsRef<dyn InternalStorageServiceExt<T>>>::as_ref(self).chainUpdateEdge_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
    }

    #[derive(Clone)]
    pub struct make_InternalStorageService;

    /// To be called by user directly setting up a client. Avoids
    /// needing ClientFactory trait in scope, avoids unidiomatic
    /// make_Trait name.
    ///
    /// ```
    /// # const _: &str = stringify! {
    /// use bgs::client::BuckGraphService;
    ///
    /// let protocol = BinaryProtocol::new();
    /// let transport = HttpClient::new();
    /// let client = <dyn BuckGraphService>::new(protocol, transport);
    /// # };
    /// ```
    impl dyn InternalStorageService {
        pub fn new<P, T>(
            protocol: P,
            transport: T,
        ) -> ::std::sync::Arc<impl InternalStorageService + ::std::marker::Send + ::std::marker::Sync + 'static>
        where
            P: ::fbthrift::Protocol<Frame = T>,
            T: ::fbthrift::Transport,
            P::Deserializer: ::std::marker::Send,
        {
            let spawner = ::fbthrift::help::NoopSpawner;
            Self::with_spawner(protocol, transport, spawner)
        }

        pub fn with_spawner<P, T, S>(
            protocol: P,
            transport: T,
            spawner: S,
        ) -> ::std::sync::Arc<impl InternalStorageService + ::std::marker::Send + ::std::marker::Sync + 'static>
        where
            P: ::fbthrift::Protocol<Frame = T>,
            T: ::fbthrift::Transport,
            P::Deserializer: ::std::marker::Send,
            S: ::fbthrift::help::Spawner,
        {
            let _ = protocol;
            let _ = spawner;
            ::std::sync::Arc::new(InternalStorageServiceImpl::<P, T, S>::new(transport))
        }
    }

    impl<T> dyn InternalStorageServiceExt<T>
    where
        T: ::fbthrift::Transport,
    {
        pub fn new<P>(
            protocol: P,
            transport: T,
        ) -> ::std::sync::Arc<impl InternalStorageServiceExt<T> + ::std::marker::Send + ::std::marker::Sync + 'static>
        where
            P: ::fbthrift::Protocol<Frame = T>,
            P::Deserializer: ::std::marker::Send,
        {
            let spawner = ::fbthrift::help::NoopSpawner;
            Self::with_spawner(protocol, transport, spawner)
        }

        pub fn with_spawner<P, S>(
            protocol: P,
            transport: T,
            spawner: S,
        ) -> ::std::sync::Arc<impl InternalStorageServiceExt<T> + ::std::marker::Send + ::std::marker::Sync + 'static>
        where
            P: ::fbthrift::Protocol<Frame = T>,
            P::Deserializer: ::std::marker::Send,
            S: ::fbthrift::help::Spawner,
        {
            let _ = protocol;
            let _ = spawner;
            ::std::sync::Arc::new(InternalStorageServiceImpl::<P, T, S>::new(transport))
        }
    }

    pub type InternalStorageServiceDynClient = <make_InternalStorageService as ::fbthrift::ClientFactory>::Api;
    pub type InternalStorageServiceClient = ::std::sync::Arc<InternalStorageServiceDynClient>;

    /// The same thing, but to be called from generic contexts where we are
    /// working with a type parameter `C: ClientFactory` to produce clients.
    impl ::fbthrift::ClientFactory for make_InternalStorageService {
        type Api = dyn InternalStorageService + ::std::marker::Send + ::std::marker::Sync + 'static;

        fn with_spawner<P, T, S>(protocol: P, transport: T, spawner: S) -> ::std::sync::Arc<Self::Api>
        where
            P: ::fbthrift::Protocol<Frame = T>,
            T: ::fbthrift::Transport,
            P::Deserializer: ::std::marker::Send,
            S: ::fbthrift::help::Spawner,
        {
            <dyn InternalStorageService>::with_spawner(protocol, transport, spawner)
        }
    }

}

/// Server definitions for `storage`.
pub mod server {
    #[::async_trait::async_trait]
    pub trait GraphStorageService: ::std::marker::Send + ::std::marker::Sync + 'static {
        async fn getNeighbors(
            &self,
            _req: crate::types::GetNeighborsRequest,
        ) -> ::std::result::Result<crate::types::GetNeighborsResponse, crate::services::graph_storage_service::GetNeighborsExn> {
            ::std::result::Result::Err(crate::services::graph_storage_service::GetNeighborsExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "GraphStorageService",
                    "getNeighbors",
                ),
            ))
        }
        async fn getProps(
            &self,
            _req: crate::types::GetPropRequest,
        ) -> ::std::result::Result<crate::types::GetPropResponse, crate::services::graph_storage_service::GetPropsExn> {
            ::std::result::Result::Err(crate::services::graph_storage_service::GetPropsExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "GraphStorageService",
                    "getProps",
                ),
            ))
        }
        async fn addVertices(
            &self,
            _req: crate::types::AddVerticesRequest,
        ) -> ::std::result::Result<crate::types::ExecResponse, crate::services::graph_storage_service::AddVerticesExn> {
            ::std::result::Result::Err(crate::services::graph_storage_service::AddVerticesExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "GraphStorageService",
                    "addVertices",
                ),
            ))
        }
        async fn addEdges(
            &self,
            _req: crate::types::AddEdgesRequest,
        ) -> ::std::result::Result<crate::types::ExecResponse, crate::services::graph_storage_service::AddEdgesExn> {
            ::std::result::Result::Err(crate::services::graph_storage_service::AddEdgesExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "GraphStorageService",
                    "addEdges",
                ),
            ))
        }
        async fn deleteEdges(
            &self,
            _req: crate::types::DeleteEdgesRequest,
        ) -> ::std::result::Result<crate::types::ExecResponse, crate::services::graph_storage_service::DeleteEdgesExn> {
            ::std::result::Result::Err(crate::services::graph_storage_service::DeleteEdgesExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "GraphStorageService",
                    "deleteEdges",
                ),
            ))
        }
        async fn deleteVertices(
            &self,
            _req: crate::types::DeleteVerticesRequest,
        ) -> ::std::result::Result<crate::types::ExecResponse, crate::services::graph_storage_service::DeleteVerticesExn> {
            ::std::result::Result::Err(crate::services::graph_storage_service::DeleteVerticesExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "GraphStorageService",
                    "deleteVertices",
                ),
            ))
        }
        async fn deleteTags(
            &self,
            _req: crate::types::DeleteTagsRequest,
        ) -> ::std::result::Result<crate::types::ExecResponse, crate::services::graph_storage_service::DeleteTagsExn> {
            ::std::result::Result::Err(crate::services::graph_storage_service::DeleteTagsExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "GraphStorageService",
                    "deleteTags",
                ),
            ))
        }
        async fn updateVertex(
            &self,
            _req: crate::types::UpdateVertexRequest,
        ) -> ::std::result::Result<crate::types::UpdateResponse, crate::services::graph_storage_service::UpdateVertexExn> {
            ::std::result::Result::Err(crate::services::graph_storage_service::UpdateVertexExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "GraphStorageService",
                    "updateVertex",
                ),
            ))
        }
        async fn updateEdge(
            &self,
            _req: crate::types::UpdateEdgeRequest,
        ) -> ::std::result::Result<crate::types::UpdateResponse, crate::services::graph_storage_service::UpdateEdgeExn> {
            ::std::result::Result::Err(crate::services::graph_storage_service::UpdateEdgeExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "GraphStorageService",
                    "updateEdge",
                ),
            ))
        }
        async fn scanVertex(
            &self,
            _req: crate::types::ScanVertexRequest,
        ) -> ::std::result::Result<crate::types::ScanVertexResponse, crate::services::graph_storage_service::ScanVertexExn> {
            ::std::result::Result::Err(crate::services::graph_storage_service::ScanVertexExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "GraphStorageService",
                    "scanVertex",
                ),
            ))
        }
        async fn scanEdge(
            &self,
            _req: crate::types::ScanEdgeRequest,
        ) -> ::std::result::Result<crate::types::ScanEdgeResponse, crate::services::graph_storage_service::ScanEdgeExn> {
            ::std::result::Result::Err(crate::services::graph_storage_service::ScanEdgeExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "GraphStorageService",
                    "scanEdge",
                ),
            ))
        }
        async fn getUUID(
            &self,
            _req: crate::types::GetUUIDReq,
        ) -> ::std::result::Result<crate::types::GetUUIDResp, crate::services::graph_storage_service::GetUUIDExn> {
            ::std::result::Result::Err(crate::services::graph_storage_service::GetUUIDExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "GraphStorageService",
                    "getUUID",
                ),
            ))
        }
        async fn lookupIndex(
            &self,
            _req: crate::types::LookupIndexRequest,
        ) -> ::std::result::Result<crate::types::LookupIndexResp, crate::services::graph_storage_service::LookupIndexExn> {
            ::std::result::Result::Err(crate::services::graph_storage_service::LookupIndexExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "GraphStorageService",
                    "lookupIndex",
                ),
            ))
        }
        async fn lookupAndTraverse(
            &self,
            _req: crate::types::LookupAndTraverseRequest,
        ) -> ::std::result::Result<crate::types::GetNeighborsResponse, crate::services::graph_storage_service::LookupAndTraverseExn> {
            ::std::result::Result::Err(crate::services::graph_storage_service::LookupAndTraverseExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "GraphStorageService",
                    "lookupAndTraverse",
                ),
            ))
        }
        async fn chainUpdateEdge(
            &self,
            _req: crate::types::UpdateEdgeRequest,
        ) -> ::std::result::Result<crate::types::UpdateResponse, crate::services::graph_storage_service::ChainUpdateEdgeExn> {
            ::std::result::Result::Err(crate::services::graph_storage_service::ChainUpdateEdgeExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "GraphStorageService",
                    "chainUpdateEdge",
                ),
            ))
        }
        async fn chainAddEdges(
            &self,
            _req: crate::types::AddEdgesRequest,
        ) -> ::std::result::Result<crate::types::ExecResponse, crate::services::graph_storage_service::ChainAddEdgesExn> {
            ::std::result::Result::Err(crate::services::graph_storage_service::ChainAddEdgesExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "GraphStorageService",
                    "chainAddEdges",
                ),
            ))
        }
    }

    #[::async_trait::async_trait]
    impl<T> GraphStorageService for ::std::boxed::Box<T>
    where
        T: GraphStorageService + Send + Sync + ?Sized,
    {
        async fn getNeighbors(
            &self,
            req: crate::types::GetNeighborsRequest,
        ) -> ::std::result::Result<crate::types::GetNeighborsResponse, crate::services::graph_storage_service::GetNeighborsExn> {
            (**self).getNeighbors(
                req,
            ).await
        }
        async fn getProps(
            &self,
            req: crate::types::GetPropRequest,
        ) -> ::std::result::Result<crate::types::GetPropResponse, crate::services::graph_storage_service::GetPropsExn> {
            (**self).getProps(
                req,
            ).await
        }
        async fn addVertices(
            &self,
            req: crate::types::AddVerticesRequest,
        ) -> ::std::result::Result<crate::types::ExecResponse, crate::services::graph_storage_service::AddVerticesExn> {
            (**self).addVertices(
                req,
            ).await
        }
        async fn addEdges(
            &self,
            req: crate::types::AddEdgesRequest,
        ) -> ::std::result::Result<crate::types::ExecResponse, crate::services::graph_storage_service::AddEdgesExn> {
            (**self).addEdges(
                req,
            ).await
        }
        async fn deleteEdges(
            &self,
            req: crate::types::DeleteEdgesRequest,
        ) -> ::std::result::Result<crate::types::ExecResponse, crate::services::graph_storage_service::DeleteEdgesExn> {
            (**self).deleteEdges(
                req,
            ).await
        }
        async fn deleteVertices(
            &self,
            req: crate::types::DeleteVerticesRequest,
        ) -> ::std::result::Result<crate::types::ExecResponse, crate::services::graph_storage_service::DeleteVerticesExn> {
            (**self).deleteVertices(
                req,
            ).await
        }
        async fn deleteTags(
            &self,
            req: crate::types::DeleteTagsRequest,
        ) -> ::std::result::Result<crate::types::ExecResponse, crate::services::graph_storage_service::DeleteTagsExn> {
            (**self).deleteTags(
                req,
            ).await
        }
        async fn updateVertex(
            &self,
            req: crate::types::UpdateVertexRequest,
        ) -> ::std::result::Result<crate::types::UpdateResponse, crate::services::graph_storage_service::UpdateVertexExn> {
            (**self).updateVertex(
                req,
            ).await
        }
        async fn updateEdge(
            &self,
            req: crate::types::UpdateEdgeRequest,
        ) -> ::std::result::Result<crate::types::UpdateResponse, crate::services::graph_storage_service::UpdateEdgeExn> {
            (**self).updateEdge(
                req,
            ).await
        }
        async fn scanVertex(
            &self,
            req: crate::types::ScanVertexRequest,
        ) -> ::std::result::Result<crate::types::ScanVertexResponse, crate::services::graph_storage_service::ScanVertexExn> {
            (**self).scanVertex(
                req,
            ).await
        }
        async fn scanEdge(
            &self,
            req: crate::types::ScanEdgeRequest,
        ) -> ::std::result::Result<crate::types::ScanEdgeResponse, crate::services::graph_storage_service::ScanEdgeExn> {
            (**self).scanEdge(
                req,
            ).await
        }
        async fn getUUID(
            &self,
            req: crate::types::GetUUIDReq,
        ) -> ::std::result::Result<crate::types::GetUUIDResp, crate::services::graph_storage_service::GetUUIDExn> {
            (**self).getUUID(
                req,
            ).await
        }
        async fn lookupIndex(
            &self,
            req: crate::types::LookupIndexRequest,
        ) -> ::std::result::Result<crate::types::LookupIndexResp, crate::services::graph_storage_service::LookupIndexExn> {
            (**self).lookupIndex(
                req,
            ).await
        }
        async fn lookupAndTraverse(
            &self,
            req: crate::types::LookupAndTraverseRequest,
        ) -> ::std::result::Result<crate::types::GetNeighborsResponse, crate::services::graph_storage_service::LookupAndTraverseExn> {
            (**self).lookupAndTraverse(
                req,
            ).await
        }
        async fn chainUpdateEdge(
            &self,
            req: crate::types::UpdateEdgeRequest,
        ) -> ::std::result::Result<crate::types::UpdateResponse, crate::services::graph_storage_service::ChainUpdateEdgeExn> {
            (**self).chainUpdateEdge(
                req,
            ).await
        }
        async fn chainAddEdges(
            &self,
            req: crate::types::AddEdgesRequest,
        ) -> ::std::result::Result<crate::types::ExecResponse, crate::services::graph_storage_service::ChainAddEdgesExn> {
            (**self).chainAddEdges(
                req,
            ).await
        }
    }

    /// Processor for GraphStorageService's methods.
    #[derive(Clone, Debug)]
    pub struct GraphStorageServiceProcessor<P, H, R, RS> {
        service: H,
        supa: ::fbthrift::NullServiceProcessor<P, R, RS>,
        _phantom: ::std::marker::PhantomData<(P, H, R, RS)>,
    }

    struct Args_GraphStorageService_getNeighbors {
        req: crate::types::GetNeighborsRequest,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_GraphStorageService_getNeighbors {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "GraphStorageService.getNeighbors"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "GraphStorageService.getNeighbors", "req"))?,
            })
        }
    }

    struct Args_GraphStorageService_getProps {
        req: crate::types::GetPropRequest,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_GraphStorageService_getProps {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "GraphStorageService.getProps"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "GraphStorageService.getProps", "req"))?,
            })
        }
    }

    struct Args_GraphStorageService_addVertices {
        req: crate::types::AddVerticesRequest,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_GraphStorageService_addVertices {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "GraphStorageService.addVertices"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "GraphStorageService.addVertices", "req"))?,
            })
        }
    }

    struct Args_GraphStorageService_addEdges {
        req: crate::types::AddEdgesRequest,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_GraphStorageService_addEdges {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "GraphStorageService.addEdges"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "GraphStorageService.addEdges", "req"))?,
            })
        }
    }

    struct Args_GraphStorageService_deleteEdges {
        req: crate::types::DeleteEdgesRequest,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_GraphStorageService_deleteEdges {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "GraphStorageService.deleteEdges"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "GraphStorageService.deleteEdges", "req"))?,
            })
        }
    }

    struct Args_GraphStorageService_deleteVertices {
        req: crate::types::DeleteVerticesRequest,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_GraphStorageService_deleteVertices {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "GraphStorageService.deleteVertices"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "GraphStorageService.deleteVertices", "req"))?,
            })
        }
    }

    struct Args_GraphStorageService_deleteTags {
        req: crate::types::DeleteTagsRequest,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_GraphStorageService_deleteTags {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "GraphStorageService.deleteTags"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "GraphStorageService.deleteTags", "req"))?,
            })
        }
    }

    struct Args_GraphStorageService_updateVertex {
        req: crate::types::UpdateVertexRequest,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_GraphStorageService_updateVertex {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "GraphStorageService.updateVertex"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "GraphStorageService.updateVertex", "req"))?,
            })
        }
    }

    struct Args_GraphStorageService_updateEdge {
        req: crate::types::UpdateEdgeRequest,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_GraphStorageService_updateEdge {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "GraphStorageService.updateEdge"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "GraphStorageService.updateEdge", "req"))?,
            })
        }
    }

    struct Args_GraphStorageService_scanVertex {
        req: crate::types::ScanVertexRequest,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_GraphStorageService_scanVertex {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "GraphStorageService.scanVertex"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "GraphStorageService.scanVertex", "req"))?,
            })
        }
    }

    struct Args_GraphStorageService_scanEdge {
        req: crate::types::ScanEdgeRequest,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_GraphStorageService_scanEdge {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "GraphStorageService.scanEdge"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "GraphStorageService.scanEdge", "req"))?,
            })
        }
    }

    struct Args_GraphStorageService_getUUID {
        req: crate::types::GetUUIDReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_GraphStorageService_getUUID {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "GraphStorageService.getUUID"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "GraphStorageService.getUUID", "req"))?,
            })
        }
    }

    struct Args_GraphStorageService_lookupIndex {
        req: crate::types::LookupIndexRequest,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_GraphStorageService_lookupIndex {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "GraphStorageService.lookupIndex"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "GraphStorageService.lookupIndex", "req"))?,
            })
        }
    }

    struct Args_GraphStorageService_lookupAndTraverse {
        req: crate::types::LookupAndTraverseRequest,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_GraphStorageService_lookupAndTraverse {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "GraphStorageService.lookupAndTraverse"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "GraphStorageService.lookupAndTraverse", "req"))?,
            })
        }
    }

    struct Args_GraphStorageService_chainUpdateEdge {
        req: crate::types::UpdateEdgeRequest,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_GraphStorageService_chainUpdateEdge {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "GraphStorageService.chainUpdateEdge"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "GraphStorageService.chainUpdateEdge", "req"))?,
            })
        }
    }

    struct Args_GraphStorageService_chainAddEdges {
        req: crate::types::AddEdgesRequest,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_GraphStorageService_chainAddEdges {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "GraphStorageService.chainAddEdges"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "GraphStorageService.chainAddEdges", "req"))?,
            })
        }
    }


    impl<P, H, R, RS> GraphStorageServiceProcessor<P, H, R, RS>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Frame: ::std::marker::Send + 'static,
        P::Deserializer: ::std::marker::Send,
        H: GraphStorageService,
        R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Buffer = ::fbthrift::ProtocolDecoded<P>>
            + ::std::marker::Send + ::std::marker::Sync,
    {
        pub fn new(service: H) -> Self {
            Self {
                service,
                supa: ::fbthrift::NullServiceProcessor::new(),
                _phantom: ::std::marker::PhantomData,
            }
        }

        pub fn into_inner(self) -> H {
            self.service
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "GraphStorageService.getNeighbors"))]
        async fn handle_getNeighbors<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "GraphStorageService";
                METHOD_NAME = "GraphStorageService.getNeighbors";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_GraphStorageService_getNeighbors = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.getNeighbors(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::graph_storage_service::GetNeighborsExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::graph_storage_service::GetNeighborsExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getNeighbors",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("GraphStorageService.getNeighbors", exn);
                    crate::services::graph_storage_service::GetNeighborsExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "getNeighbors",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "GraphStorageService.getProps"))]
        async fn handle_getProps<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "GraphStorageService";
                METHOD_NAME = "GraphStorageService.getProps";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_GraphStorageService_getProps = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.getProps(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::graph_storage_service::GetPropsExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::graph_storage_service::GetPropsExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getProps",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("GraphStorageService.getProps", exn);
                    crate::services::graph_storage_service::GetPropsExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "getProps",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "GraphStorageService.addVertices"))]
        async fn handle_addVertices<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "GraphStorageService";
                METHOD_NAME = "GraphStorageService.addVertices";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_GraphStorageService_addVertices = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.addVertices(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::graph_storage_service::AddVerticesExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::graph_storage_service::AddVerticesExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "addVertices",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("GraphStorageService.addVertices", exn);
                    crate::services::graph_storage_service::AddVerticesExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "addVertices",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "GraphStorageService.addEdges"))]
        async fn handle_addEdges<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "GraphStorageService";
                METHOD_NAME = "GraphStorageService.addEdges";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_GraphStorageService_addEdges = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.addEdges(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::graph_storage_service::AddEdgesExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::graph_storage_service::AddEdgesExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "addEdges",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("GraphStorageService.addEdges", exn);
                    crate::services::graph_storage_service::AddEdgesExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "addEdges",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "GraphStorageService.deleteEdges"))]
        async fn handle_deleteEdges<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "GraphStorageService";
                METHOD_NAME = "GraphStorageService.deleteEdges";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_GraphStorageService_deleteEdges = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.deleteEdges(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::graph_storage_service::DeleteEdgesExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::graph_storage_service::DeleteEdgesExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "deleteEdges",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("GraphStorageService.deleteEdges", exn);
                    crate::services::graph_storage_service::DeleteEdgesExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "deleteEdges",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "GraphStorageService.deleteVertices"))]
        async fn handle_deleteVertices<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "GraphStorageService";
                METHOD_NAME = "GraphStorageService.deleteVertices";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_GraphStorageService_deleteVertices = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.deleteVertices(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::graph_storage_service::DeleteVerticesExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::graph_storage_service::DeleteVerticesExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "deleteVertices",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("GraphStorageService.deleteVertices", exn);
                    crate::services::graph_storage_service::DeleteVerticesExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "deleteVertices",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "GraphStorageService.deleteTags"))]
        async fn handle_deleteTags<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "GraphStorageService";
                METHOD_NAME = "GraphStorageService.deleteTags";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_GraphStorageService_deleteTags = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.deleteTags(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::graph_storage_service::DeleteTagsExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::graph_storage_service::DeleteTagsExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "deleteTags",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("GraphStorageService.deleteTags", exn);
                    crate::services::graph_storage_service::DeleteTagsExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "deleteTags",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "GraphStorageService.updateVertex"))]
        async fn handle_updateVertex<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "GraphStorageService";
                METHOD_NAME = "GraphStorageService.updateVertex";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_GraphStorageService_updateVertex = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.updateVertex(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::graph_storage_service::UpdateVertexExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::graph_storage_service::UpdateVertexExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "updateVertex",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("GraphStorageService.updateVertex", exn);
                    crate::services::graph_storage_service::UpdateVertexExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "updateVertex",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "GraphStorageService.updateEdge"))]
        async fn handle_updateEdge<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "GraphStorageService";
                METHOD_NAME = "GraphStorageService.updateEdge";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_GraphStorageService_updateEdge = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.updateEdge(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::graph_storage_service::UpdateEdgeExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::graph_storage_service::UpdateEdgeExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "updateEdge",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("GraphStorageService.updateEdge", exn);
                    crate::services::graph_storage_service::UpdateEdgeExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "updateEdge",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "GraphStorageService.scanVertex"))]
        async fn handle_scanVertex<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "GraphStorageService";
                METHOD_NAME = "GraphStorageService.scanVertex";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_GraphStorageService_scanVertex = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.scanVertex(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::graph_storage_service::ScanVertexExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::graph_storage_service::ScanVertexExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "scanVertex",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("GraphStorageService.scanVertex", exn);
                    crate::services::graph_storage_service::ScanVertexExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "scanVertex",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "GraphStorageService.scanEdge"))]
        async fn handle_scanEdge<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "GraphStorageService";
                METHOD_NAME = "GraphStorageService.scanEdge";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_GraphStorageService_scanEdge = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.scanEdge(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::graph_storage_service::ScanEdgeExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::graph_storage_service::ScanEdgeExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "scanEdge",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("GraphStorageService.scanEdge", exn);
                    crate::services::graph_storage_service::ScanEdgeExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "scanEdge",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "GraphStorageService.getUUID"))]
        async fn handle_getUUID<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "GraphStorageService";
                METHOD_NAME = "GraphStorageService.getUUID";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_GraphStorageService_getUUID = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.getUUID(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::graph_storage_service::GetUUIDExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::graph_storage_service::GetUUIDExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getUUID",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("GraphStorageService.getUUID", exn);
                    crate::services::graph_storage_service::GetUUIDExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "getUUID",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "GraphStorageService.lookupIndex"))]
        async fn handle_lookupIndex<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "GraphStorageService";
                METHOD_NAME = "GraphStorageService.lookupIndex";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_GraphStorageService_lookupIndex = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.lookupIndex(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::graph_storage_service::LookupIndexExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::graph_storage_service::LookupIndexExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "lookupIndex",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("GraphStorageService.lookupIndex", exn);
                    crate::services::graph_storage_service::LookupIndexExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "lookupIndex",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "GraphStorageService.lookupAndTraverse"))]
        async fn handle_lookupAndTraverse<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "GraphStorageService";
                METHOD_NAME = "GraphStorageService.lookupAndTraverse";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_GraphStorageService_lookupAndTraverse = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.lookupAndTraverse(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::graph_storage_service::LookupAndTraverseExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::graph_storage_service::LookupAndTraverseExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "lookupAndTraverse",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("GraphStorageService.lookupAndTraverse", exn);
                    crate::services::graph_storage_service::LookupAndTraverseExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "lookupAndTraverse",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "GraphStorageService.chainUpdateEdge"))]
        async fn handle_chainUpdateEdge<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "GraphStorageService";
                METHOD_NAME = "GraphStorageService.chainUpdateEdge";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_GraphStorageService_chainUpdateEdge = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.chainUpdateEdge(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::graph_storage_service::ChainUpdateEdgeExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::graph_storage_service::ChainUpdateEdgeExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "chainUpdateEdge",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("GraphStorageService.chainUpdateEdge", exn);
                    crate::services::graph_storage_service::ChainUpdateEdgeExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "chainUpdateEdge",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "GraphStorageService.chainAddEdges"))]
        async fn handle_chainAddEdges<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "GraphStorageService";
                METHOD_NAME = "GraphStorageService.chainAddEdges";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_GraphStorageService_chainAddEdges = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.chainAddEdges(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::graph_storage_service::ChainAddEdgesExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::graph_storage_service::ChainAddEdgesExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "chainAddEdges",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("GraphStorageService.chainAddEdges", exn);
                    crate::services::graph_storage_service::ChainAddEdgesExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "chainAddEdges",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }
    }

    #[::async_trait::async_trait]
    impl<P, H, R, RS> ::fbthrift::ServiceProcessor<P> for GraphStorageServiceProcessor<P, H, R, RS>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Deserializer: ::std::marker::Send,
        H: GraphStorageService,
        P::Frame: ::std::marker::Send + 'static,
        R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Buffer = ::fbthrift::ProtocolDecoded<P>>
            + ::std::marker::Send + ::std::marker::Sync + 'static,
        RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static
    {
        type RequestContext = R;
        type ReplyState = RS;

        #[inline]
        fn method_idx(&self, name: &[::std::primitive::u8]) -> ::std::result::Result<::std::primitive::usize, ::fbthrift::ApplicationException> {
            match name {
                b"getNeighbors" => ::std::result::Result::Ok(0usize),
                b"getProps" => ::std::result::Result::Ok(1usize),
                b"addVertices" => ::std::result::Result::Ok(2usize),
                b"addEdges" => ::std::result::Result::Ok(3usize),
                b"deleteEdges" => ::std::result::Result::Ok(4usize),
                b"deleteVertices" => ::std::result::Result::Ok(5usize),
                b"deleteTags" => ::std::result::Result::Ok(6usize),
                b"updateVertex" => ::std::result::Result::Ok(7usize),
                b"updateEdge" => ::std::result::Result::Ok(8usize),
                b"scanVertex" => ::std::result::Result::Ok(9usize),
                b"scanEdge" => ::std::result::Result::Ok(10usize),
                b"getUUID" => ::std::result::Result::Ok(11usize),
                b"lookupIndex" => ::std::result::Result::Ok(12usize),
                b"lookupAndTraverse" => ::std::result::Result::Ok(13usize),
                b"chainUpdateEdge" => ::std::result::Result::Ok(14usize),
                b"chainAddEdges" => ::std::result::Result::Ok(15usize),
                _ => ::std::result::Result::Err(::fbthrift::ApplicationException::unknown_method()),
            }
        }

        #[allow(clippy::match_single_binding)]
        async fn handle_method(
            &self,
            idx: ::std::primitive::usize,
            _p: &mut P::Deserializer,
            _r: &R,
            _reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            match idx {
                0usize => {
                    self.handle_getNeighbors(_p, _r, _reply_state, _seqid).await
                }
                1usize => {
                    self.handle_getProps(_p, _r, _reply_state, _seqid).await
                }
                2usize => {
                    self.handle_addVertices(_p, _r, _reply_state, _seqid).await
                }
                3usize => {
                    self.handle_addEdges(_p, _r, _reply_state, _seqid).await
                }
                4usize => {
                    self.handle_deleteEdges(_p, _r, _reply_state, _seqid).await
                }
                5usize => {
                    self.handle_deleteVertices(_p, _r, _reply_state, _seqid).await
                }
                6usize => {
                    self.handle_deleteTags(_p, _r, _reply_state, _seqid).await
                }
                7usize => {
                    self.handle_updateVertex(_p, _r, _reply_state, _seqid).await
                }
                8usize => {
                    self.handle_updateEdge(_p, _r, _reply_state, _seqid).await
                }
                9usize => {
                    self.handle_scanVertex(_p, _r, _reply_state, _seqid).await
                }
                10usize => {
                    self.handle_scanEdge(_p, _r, _reply_state, _seqid).await
                }
                11usize => {
                    self.handle_getUUID(_p, _r, _reply_state, _seqid).await
                }
                12usize => {
                    self.handle_lookupIndex(_p, _r, _reply_state, _seqid).await
                }
                13usize => {
                    self.handle_lookupAndTraverse(_p, _r, _reply_state, _seqid).await
                }
                14usize => {
                    self.handle_chainUpdateEdge(_p, _r, _reply_state, _seqid).await
                }
                15usize => {
                    self.handle_chainAddEdges(_p, _r, _reply_state, _seqid).await
                }
                bad => panic!(
                    "{}: unexpected method idx {}",
                    "GraphStorageServiceProcessor",
                    bad
                ),
            }
        }

        #[allow(clippy::match_single_binding)]
        #[inline]
        fn create_interaction_idx(&self, name: &str) -> ::anyhow::Result<::std::primitive::usize> {
            match name {
                _ => ::anyhow::bail!("Unknown interaction"),
            }
        }

        #[allow(clippy::match_single_binding)]
        fn handle_create_interaction(
            &self,
            idx: ::std::primitive::usize,
        ) -> ::anyhow::Result<
            ::std::sync::Arc<dyn ::fbthrift::ThriftService<P::Frame, Handler = (), RequestContext = Self::RequestContext, ReplyState = Self::ReplyState> + ::std::marker::Send + 'static>
        > {
            match idx {
                bad => panic!(
                    "{}: unexpected method idx {}",
                    "GraphStorageServiceProcessor",
                    bad
                ),
            }
        }
    }

    #[::async_trait::async_trait]
    impl<P, H, R, RS> ::fbthrift::ThriftService<P::Frame> for GraphStorageServiceProcessor<P, H, R, RS>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Deserializer: ::std::marker::Send,
        P::Frame: ::std::marker::Send + 'static,
        H: GraphStorageService,
        R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Buffer = ::fbthrift::ProtocolDecoded<P>>
            + ::std::marker::Send + ::std::marker::Sync + 'static,
        RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static
    {
        type Handler = H;
        type RequestContext = R;
        type ReplyState = RS;

        #[tracing::instrument(level="trace", skip_all, fields(service = "GraphStorageService"))]
        async fn call(
            &self,
            req: ::fbthrift::ProtocolDecoded<P>,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
        ) -> ::anyhow::Result<()> {
            use ::fbthrift::{BufExt as _, ProtocolReader as _, ServiceProcessor as _};
            let mut p = P::deserializer(req);
            let (idx, mty, seqid) = p.read_message_begin(|name| self.method_idx(name))?;
            if mty != ::fbthrift::MessageType::Call {
                return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::InvalidMessageType,
                    format!("message type {:?} not handled", mty)
                )));
            }
            let idx = match idx {
                ::std::result::Result::Ok(idx) => idx,
                ::std::result::Result::Err(_) => {
                    let cur = P::into_buffer(p).reset();
                    return self.supa.call(cur, req_ctxt, reply_state).await;
                }
            };
            self.handle_method(idx, &mut p, req_ctxt, reply_state, seqid).await?;
            p.read_message_end()?;

            Ok(())
        }

        fn create_interaction(
            &self,
            name: &str,
        ) -> ::anyhow::Result<
            ::std::sync::Arc<dyn ::fbthrift::ThriftService<P::Frame, Handler = (), RequestContext = R, ReplyState = RS> + ::std::marker::Send + 'static>
        > {
            use ::fbthrift::{ServiceProcessor as _};
            let idx = self.create_interaction_idx(name);
            let idx = match idx {
                ::anyhow::Result::Ok(idx) => idx,
                ::anyhow::Result::Err(_) => {
                    return self.supa.create_interaction(name);
                }
            };
            self.handle_create_interaction(idx)
        }

        fn get_method_names(&self) -> &'static [&'static str] {
            &[
                // from GraphStorageService
                "getNeighbors",
                "getProps",
                "addVertices",
                "addEdges",
                "deleteEdges",
                "deleteVertices",
                "deleteTags",
                "updateVertex",
                "updateEdge",
                "scanVertex",
                "scanEdge",
                "getUUID",
                "lookupIndex",
                "lookupAndTraverse",
                "chainUpdateEdge",
                "chainAddEdges",
            ]
        }
    }

    /// Construct a new instance of a GraphStorageService service.
    ///
    /// This is called when a new instance of a Thrift service Processor
    /// is needed for a particular Thrift protocol.
    #[::tracing::instrument(level="debug", skip_all, fields(proto = ?proto))]
    pub fn make_GraphStorageService_server<F, H, R, RS>(
        proto: ::fbthrift::ProtocolID,
        handler: H,
    ) -> ::std::result::Result<::std::boxed::Box<dyn ::fbthrift::ThriftService<F, Handler = H, RequestContext = R, ReplyState = RS> + ::std::marker::Send + 'static>, ::fbthrift::ApplicationException>
    where
        F: ::fbthrift::Framing + ::std::marker::Send + ::std::marker::Sync + 'static,
        H: GraphStorageService,
        R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Buffer = F::DecBuf> + ::std::marker::Send + ::std::marker::Sync + 'static,
        RS: ::fbthrift::ReplyState<F, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static
    {
        match proto {
            ::fbthrift::ProtocolID::BinaryProtocol => {
                ::std::result::Result::Ok(::std::boxed::Box::new(GraphStorageServiceProcessor::<::fbthrift::BinaryProtocol<F>, H, R, RS>::new(handler)))
            }
            ::fbthrift::ProtocolID::CompactProtocol => {
                ::std::result::Result::Ok(::std::boxed::Box::new(GraphStorageServiceProcessor::<::fbthrift::CompactProtocol<F>, H, R, RS>::new(handler)))
            }
            bad => {
                ::tracing::error!(method = "GraphStorageService.", invalid_protocol = ?bad);
                ::std::result::Result::Err(::fbthrift::ApplicationException::invalid_protocol(bad))
            }
        }
    }

    #[::async_trait::async_trait]
    pub trait StorageAdminService: ::std::marker::Send + ::std::marker::Sync + 'static {
        async fn transLeader(
            &self,
            _req: crate::types::TransLeaderReq,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_admin_service::TransLeaderExn> {
            ::std::result::Result::Err(crate::services::storage_admin_service::TransLeaderExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageAdminService",
                    "transLeader",
                ),
            ))
        }
        async fn addPart(
            &self,
            _req: crate::types::AddPartReq,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_admin_service::AddPartExn> {
            ::std::result::Result::Err(crate::services::storage_admin_service::AddPartExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageAdminService",
                    "addPart",
                ),
            ))
        }
        async fn addLearner(
            &self,
            _req: crate::types::AddLearnerReq,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_admin_service::AddLearnerExn> {
            ::std::result::Result::Err(crate::services::storage_admin_service::AddLearnerExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageAdminService",
                    "addLearner",
                ),
            ))
        }
        async fn removePart(
            &self,
            _req: crate::types::RemovePartReq,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_admin_service::RemovePartExn> {
            ::std::result::Result::Err(crate::services::storage_admin_service::RemovePartExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageAdminService",
                    "removePart",
                ),
            ))
        }
        async fn memberChange(
            &self,
            _req: crate::types::MemberChangeReq,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_admin_service::MemberChangeExn> {
            ::std::result::Result::Err(crate::services::storage_admin_service::MemberChangeExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageAdminService",
                    "memberChange",
                ),
            ))
        }
        async fn waitingForCatchUpData(
            &self,
            _req: crate::types::CatchUpDataReq,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_admin_service::WaitingForCatchUpDataExn> {
            ::std::result::Result::Err(crate::services::storage_admin_service::WaitingForCatchUpDataExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageAdminService",
                    "waitingForCatchUpData",
                ),
            ))
        }
        async fn createCheckpoint(
            &self,
            _req: crate::types::CreateCPRequest,
        ) -> ::std::result::Result<crate::types::CreateCPResp, crate::services::storage_admin_service::CreateCheckpointExn> {
            ::std::result::Result::Err(crate::services::storage_admin_service::CreateCheckpointExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageAdminService",
                    "createCheckpoint",
                ),
            ))
        }
        async fn dropCheckpoint(
            &self,
            _req: crate::types::DropCPRequest,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_admin_service::DropCheckpointExn> {
            ::std::result::Result::Err(crate::services::storage_admin_service::DropCheckpointExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageAdminService",
                    "dropCheckpoint",
                ),
            ))
        }
        async fn blockingWrites(
            &self,
            _req: crate::types::BlockingSignRequest,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_admin_service::BlockingWritesExn> {
            ::std::result::Result::Err(crate::services::storage_admin_service::BlockingWritesExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageAdminService",
                    "blockingWrites",
                ),
            ))
        }
        async fn rebuildTagIndex(
            &self,
            _req: crate::types::RebuildIndexRequest,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_admin_service::RebuildTagIndexExn> {
            ::std::result::Result::Err(crate::services::storage_admin_service::RebuildTagIndexExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageAdminService",
                    "rebuildTagIndex",
                ),
            ))
        }
        async fn rebuildEdgeIndex(
            &self,
            _req: crate::types::RebuildIndexRequest,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_admin_service::RebuildEdgeIndexExn> {
            ::std::result::Result::Err(crate::services::storage_admin_service::RebuildEdgeIndexExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageAdminService",
                    "rebuildEdgeIndex",
                ),
            ))
        }
        async fn getLeaderParts(
            &self,
            _req: crate::types::GetLeaderReq,
        ) -> ::std::result::Result<crate::types::GetLeaderPartsResp, crate::services::storage_admin_service::GetLeaderPartsExn> {
            ::std::result::Result::Err(crate::services::storage_admin_service::GetLeaderPartsExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageAdminService",
                    "getLeaderParts",
                ),
            ))
        }
        async fn checkPeers(
            &self,
            _req: crate::types::CheckPeersReq,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_admin_service::CheckPeersExn> {
            ::std::result::Result::Err(crate::services::storage_admin_service::CheckPeersExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageAdminService",
                    "checkPeers",
                ),
            ))
        }
        async fn addAdminTask(
            &self,
            _req: crate::types::AddAdminTaskRequest,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_admin_service::AddAdminTaskExn> {
            ::std::result::Result::Err(crate::services::storage_admin_service::AddAdminTaskExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageAdminService",
                    "addAdminTask",
                ),
            ))
        }
        async fn stopAdminTask(
            &self,
            _req: crate::types::StopAdminTaskRequest,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_admin_service::StopAdminTaskExn> {
            ::std::result::Result::Err(crate::services::storage_admin_service::StopAdminTaskExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageAdminService",
                    "stopAdminTask",
                ),
            ))
        }
        async fn listClusterInfo(
            &self,
            _req: crate::types::ListClusterInfoReq,
        ) -> ::std::result::Result<crate::types::ListClusterInfoResp, crate::services::storage_admin_service::ListClusterInfoExn> {
            ::std::result::Result::Err(crate::services::storage_admin_service::ListClusterInfoExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageAdminService",
                    "listClusterInfo",
                ),
            ))
        }
    }

    #[::async_trait::async_trait]
    impl<T> StorageAdminService for ::std::boxed::Box<T>
    where
        T: StorageAdminService + Send + Sync + ?Sized,
    {
        async fn transLeader(
            &self,
            req: crate::types::TransLeaderReq,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_admin_service::TransLeaderExn> {
            (**self).transLeader(
                req,
            ).await
        }
        async fn addPart(
            &self,
            req: crate::types::AddPartReq,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_admin_service::AddPartExn> {
            (**self).addPart(
                req,
            ).await
        }
        async fn addLearner(
            &self,
            req: crate::types::AddLearnerReq,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_admin_service::AddLearnerExn> {
            (**self).addLearner(
                req,
            ).await
        }
        async fn removePart(
            &self,
            req: crate::types::RemovePartReq,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_admin_service::RemovePartExn> {
            (**self).removePart(
                req,
            ).await
        }
        async fn memberChange(
            &self,
            req: crate::types::MemberChangeReq,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_admin_service::MemberChangeExn> {
            (**self).memberChange(
                req,
            ).await
        }
        async fn waitingForCatchUpData(
            &self,
            req: crate::types::CatchUpDataReq,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_admin_service::WaitingForCatchUpDataExn> {
            (**self).waitingForCatchUpData(
                req,
            ).await
        }
        async fn createCheckpoint(
            &self,
            req: crate::types::CreateCPRequest,
        ) -> ::std::result::Result<crate::types::CreateCPResp, crate::services::storage_admin_service::CreateCheckpointExn> {
            (**self).createCheckpoint(
                req,
            ).await
        }
        async fn dropCheckpoint(
            &self,
            req: crate::types::DropCPRequest,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_admin_service::DropCheckpointExn> {
            (**self).dropCheckpoint(
                req,
            ).await
        }
        async fn blockingWrites(
            &self,
            req: crate::types::BlockingSignRequest,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_admin_service::BlockingWritesExn> {
            (**self).blockingWrites(
                req,
            ).await
        }
        async fn rebuildTagIndex(
            &self,
            req: crate::types::RebuildIndexRequest,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_admin_service::RebuildTagIndexExn> {
            (**self).rebuildTagIndex(
                req,
            ).await
        }
        async fn rebuildEdgeIndex(
            &self,
            req: crate::types::RebuildIndexRequest,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_admin_service::RebuildEdgeIndexExn> {
            (**self).rebuildEdgeIndex(
                req,
            ).await
        }
        async fn getLeaderParts(
            &self,
            req: crate::types::GetLeaderReq,
        ) -> ::std::result::Result<crate::types::GetLeaderPartsResp, crate::services::storage_admin_service::GetLeaderPartsExn> {
            (**self).getLeaderParts(
                req,
            ).await
        }
        async fn checkPeers(
            &self,
            req: crate::types::CheckPeersReq,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_admin_service::CheckPeersExn> {
            (**self).checkPeers(
                req,
            ).await
        }
        async fn addAdminTask(
            &self,
            req: crate::types::AddAdminTaskRequest,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_admin_service::AddAdminTaskExn> {
            (**self).addAdminTask(
                req,
            ).await
        }
        async fn stopAdminTask(
            &self,
            req: crate::types::StopAdminTaskRequest,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_admin_service::StopAdminTaskExn> {
            (**self).stopAdminTask(
                req,
            ).await
        }
        async fn listClusterInfo(
            &self,
            req: crate::types::ListClusterInfoReq,
        ) -> ::std::result::Result<crate::types::ListClusterInfoResp, crate::services::storage_admin_service::ListClusterInfoExn> {
            (**self).listClusterInfo(
                req,
            ).await
        }
    }

    /// Processor for StorageAdminService's methods.
    #[derive(Clone, Debug)]
    pub struct StorageAdminServiceProcessor<P, H, R, RS> {
        service: H,
        supa: ::fbthrift::NullServiceProcessor<P, R, RS>,
        _phantom: ::std::marker::PhantomData<(P, H, R, RS)>,
    }

    struct Args_StorageAdminService_transLeader {
        req: crate::types::TransLeaderReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_StorageAdminService_transLeader {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "StorageAdminService.transLeader"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "StorageAdminService.transLeader", "req"))?,
            })
        }
    }

    struct Args_StorageAdminService_addPart {
        req: crate::types::AddPartReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_StorageAdminService_addPart {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "StorageAdminService.addPart"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "StorageAdminService.addPart", "req"))?,
            })
        }
    }

    struct Args_StorageAdminService_addLearner {
        req: crate::types::AddLearnerReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_StorageAdminService_addLearner {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "StorageAdminService.addLearner"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "StorageAdminService.addLearner", "req"))?,
            })
        }
    }

    struct Args_StorageAdminService_removePart {
        req: crate::types::RemovePartReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_StorageAdminService_removePart {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "StorageAdminService.removePart"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "StorageAdminService.removePart", "req"))?,
            })
        }
    }

    struct Args_StorageAdminService_memberChange {
        req: crate::types::MemberChangeReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_StorageAdminService_memberChange {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "StorageAdminService.memberChange"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "StorageAdminService.memberChange", "req"))?,
            })
        }
    }

    struct Args_StorageAdminService_waitingForCatchUpData {
        req: crate::types::CatchUpDataReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_StorageAdminService_waitingForCatchUpData {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "StorageAdminService.waitingForCatchUpData"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "StorageAdminService.waitingForCatchUpData", "req"))?,
            })
        }
    }

    struct Args_StorageAdminService_createCheckpoint {
        req: crate::types::CreateCPRequest,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_StorageAdminService_createCheckpoint {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "StorageAdminService.createCheckpoint"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "StorageAdminService.createCheckpoint", "req"))?,
            })
        }
    }

    struct Args_StorageAdminService_dropCheckpoint {
        req: crate::types::DropCPRequest,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_StorageAdminService_dropCheckpoint {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "StorageAdminService.dropCheckpoint"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "StorageAdminService.dropCheckpoint", "req"))?,
            })
        }
    }

    struct Args_StorageAdminService_blockingWrites {
        req: crate::types::BlockingSignRequest,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_StorageAdminService_blockingWrites {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "StorageAdminService.blockingWrites"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "StorageAdminService.blockingWrites", "req"))?,
            })
        }
    }

    struct Args_StorageAdminService_rebuildTagIndex {
        req: crate::types::RebuildIndexRequest,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_StorageAdminService_rebuildTagIndex {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "StorageAdminService.rebuildTagIndex"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "StorageAdminService.rebuildTagIndex", "req"))?,
            })
        }
    }

    struct Args_StorageAdminService_rebuildEdgeIndex {
        req: crate::types::RebuildIndexRequest,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_StorageAdminService_rebuildEdgeIndex {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "StorageAdminService.rebuildEdgeIndex"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "StorageAdminService.rebuildEdgeIndex", "req"))?,
            })
        }
    }

    struct Args_StorageAdminService_getLeaderParts {
        req: crate::types::GetLeaderReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_StorageAdminService_getLeaderParts {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "StorageAdminService.getLeaderParts"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "StorageAdminService.getLeaderParts", "req"))?,
            })
        }
    }

    struct Args_StorageAdminService_checkPeers {
        req: crate::types::CheckPeersReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_StorageAdminService_checkPeers {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "StorageAdminService.checkPeers"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "StorageAdminService.checkPeers", "req"))?,
            })
        }
    }

    struct Args_StorageAdminService_addAdminTask {
        req: crate::types::AddAdminTaskRequest,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_StorageAdminService_addAdminTask {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "StorageAdminService.addAdminTask"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "StorageAdminService.addAdminTask", "req"))?,
            })
        }
    }

    struct Args_StorageAdminService_stopAdminTask {
        req: crate::types::StopAdminTaskRequest,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_StorageAdminService_stopAdminTask {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "StorageAdminService.stopAdminTask"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "StorageAdminService.stopAdminTask", "req"))?,
            })
        }
    }

    struct Args_StorageAdminService_listClusterInfo {
        req: crate::types::ListClusterInfoReq,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_StorageAdminService_listClusterInfo {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "StorageAdminService.listClusterInfo"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "StorageAdminService.listClusterInfo", "req"))?,
            })
        }
    }


    impl<P, H, R, RS> StorageAdminServiceProcessor<P, H, R, RS>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Frame: ::std::marker::Send + 'static,
        P::Deserializer: ::std::marker::Send,
        H: StorageAdminService,
        R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Buffer = ::fbthrift::ProtocolDecoded<P>>
            + ::std::marker::Send + ::std::marker::Sync,
    {
        pub fn new(service: H) -> Self {
            Self {
                service,
                supa: ::fbthrift::NullServiceProcessor::new(),
                _phantom: ::std::marker::PhantomData,
            }
        }

        pub fn into_inner(self) -> H {
            self.service
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "StorageAdminService.transLeader"))]
        async fn handle_transLeader<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageAdminService";
                METHOD_NAME = "StorageAdminService.transLeader";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_StorageAdminService_transLeader = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.transLeader(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::storage_admin_service::TransLeaderExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::storage_admin_service::TransLeaderExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "transLeader",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("StorageAdminService.transLeader", exn);
                    crate::services::storage_admin_service::TransLeaderExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "transLeader",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "StorageAdminService.addPart"))]
        async fn handle_addPart<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageAdminService";
                METHOD_NAME = "StorageAdminService.addPart";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_StorageAdminService_addPart = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.addPart(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::storage_admin_service::AddPartExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::storage_admin_service::AddPartExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "addPart",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("StorageAdminService.addPart", exn);
                    crate::services::storage_admin_service::AddPartExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "addPart",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "StorageAdminService.addLearner"))]
        async fn handle_addLearner<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageAdminService";
                METHOD_NAME = "StorageAdminService.addLearner";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_StorageAdminService_addLearner = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.addLearner(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::storage_admin_service::AddLearnerExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::storage_admin_service::AddLearnerExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "addLearner",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("StorageAdminService.addLearner", exn);
                    crate::services::storage_admin_service::AddLearnerExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "addLearner",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "StorageAdminService.removePart"))]
        async fn handle_removePart<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageAdminService";
                METHOD_NAME = "StorageAdminService.removePart";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_StorageAdminService_removePart = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.removePart(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::storage_admin_service::RemovePartExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::storage_admin_service::RemovePartExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "removePart",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("StorageAdminService.removePart", exn);
                    crate::services::storage_admin_service::RemovePartExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "removePart",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "StorageAdminService.memberChange"))]
        async fn handle_memberChange<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageAdminService";
                METHOD_NAME = "StorageAdminService.memberChange";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_StorageAdminService_memberChange = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.memberChange(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::storage_admin_service::MemberChangeExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::storage_admin_service::MemberChangeExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "memberChange",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("StorageAdminService.memberChange", exn);
                    crate::services::storage_admin_service::MemberChangeExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "memberChange",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "StorageAdminService.waitingForCatchUpData"))]
        async fn handle_waitingForCatchUpData<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageAdminService";
                METHOD_NAME = "StorageAdminService.waitingForCatchUpData";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_StorageAdminService_waitingForCatchUpData = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.waitingForCatchUpData(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::storage_admin_service::WaitingForCatchUpDataExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::storage_admin_service::WaitingForCatchUpDataExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "waitingForCatchUpData",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("StorageAdminService.waitingForCatchUpData", exn);
                    crate::services::storage_admin_service::WaitingForCatchUpDataExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "waitingForCatchUpData",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "StorageAdminService.createCheckpoint"))]
        async fn handle_createCheckpoint<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageAdminService";
                METHOD_NAME = "StorageAdminService.createCheckpoint";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_StorageAdminService_createCheckpoint = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.createCheckpoint(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::storage_admin_service::CreateCheckpointExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::storage_admin_service::CreateCheckpointExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "createCheckpoint",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("StorageAdminService.createCheckpoint", exn);
                    crate::services::storage_admin_service::CreateCheckpointExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "createCheckpoint",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "StorageAdminService.dropCheckpoint"))]
        async fn handle_dropCheckpoint<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageAdminService";
                METHOD_NAME = "StorageAdminService.dropCheckpoint";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_StorageAdminService_dropCheckpoint = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.dropCheckpoint(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::storage_admin_service::DropCheckpointExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::storage_admin_service::DropCheckpointExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "dropCheckpoint",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("StorageAdminService.dropCheckpoint", exn);
                    crate::services::storage_admin_service::DropCheckpointExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "dropCheckpoint",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "StorageAdminService.blockingWrites"))]
        async fn handle_blockingWrites<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageAdminService";
                METHOD_NAME = "StorageAdminService.blockingWrites";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_StorageAdminService_blockingWrites = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.blockingWrites(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::storage_admin_service::BlockingWritesExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::storage_admin_service::BlockingWritesExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "blockingWrites",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("StorageAdminService.blockingWrites", exn);
                    crate::services::storage_admin_service::BlockingWritesExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "blockingWrites",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "StorageAdminService.rebuildTagIndex"))]
        async fn handle_rebuildTagIndex<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageAdminService";
                METHOD_NAME = "StorageAdminService.rebuildTagIndex";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_StorageAdminService_rebuildTagIndex = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.rebuildTagIndex(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::storage_admin_service::RebuildTagIndexExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::storage_admin_service::RebuildTagIndexExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "rebuildTagIndex",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("StorageAdminService.rebuildTagIndex", exn);
                    crate::services::storage_admin_service::RebuildTagIndexExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "rebuildTagIndex",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "StorageAdminService.rebuildEdgeIndex"))]
        async fn handle_rebuildEdgeIndex<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageAdminService";
                METHOD_NAME = "StorageAdminService.rebuildEdgeIndex";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_StorageAdminService_rebuildEdgeIndex = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.rebuildEdgeIndex(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::storage_admin_service::RebuildEdgeIndexExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::storage_admin_service::RebuildEdgeIndexExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "rebuildEdgeIndex",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("StorageAdminService.rebuildEdgeIndex", exn);
                    crate::services::storage_admin_service::RebuildEdgeIndexExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "rebuildEdgeIndex",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "StorageAdminService.getLeaderParts"))]
        async fn handle_getLeaderParts<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageAdminService";
                METHOD_NAME = "StorageAdminService.getLeaderParts";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_StorageAdminService_getLeaderParts = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.getLeaderParts(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::storage_admin_service::GetLeaderPartsExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::storage_admin_service::GetLeaderPartsExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getLeaderParts",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("StorageAdminService.getLeaderParts", exn);
                    crate::services::storage_admin_service::GetLeaderPartsExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "getLeaderParts",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "StorageAdminService.checkPeers"))]
        async fn handle_checkPeers<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageAdminService";
                METHOD_NAME = "StorageAdminService.checkPeers";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_StorageAdminService_checkPeers = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.checkPeers(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::storage_admin_service::CheckPeersExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::storage_admin_service::CheckPeersExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "checkPeers",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("StorageAdminService.checkPeers", exn);
                    crate::services::storage_admin_service::CheckPeersExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "checkPeers",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "StorageAdminService.addAdminTask"))]
        async fn handle_addAdminTask<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageAdminService";
                METHOD_NAME = "StorageAdminService.addAdminTask";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_StorageAdminService_addAdminTask = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.addAdminTask(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::storage_admin_service::AddAdminTaskExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::storage_admin_service::AddAdminTaskExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "addAdminTask",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("StorageAdminService.addAdminTask", exn);
                    crate::services::storage_admin_service::AddAdminTaskExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "addAdminTask",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "StorageAdminService.stopAdminTask"))]
        async fn handle_stopAdminTask<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageAdminService";
                METHOD_NAME = "StorageAdminService.stopAdminTask";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_StorageAdminService_stopAdminTask = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.stopAdminTask(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::storage_admin_service::StopAdminTaskExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::storage_admin_service::StopAdminTaskExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "stopAdminTask",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("StorageAdminService.stopAdminTask", exn);
                    crate::services::storage_admin_service::StopAdminTaskExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "stopAdminTask",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "StorageAdminService.listClusterInfo"))]
        async fn handle_listClusterInfo<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "StorageAdminService";
                METHOD_NAME = "StorageAdminService.listClusterInfo";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_StorageAdminService_listClusterInfo = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.listClusterInfo(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::storage_admin_service::ListClusterInfoExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::storage_admin_service::ListClusterInfoExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listClusterInfo",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("StorageAdminService.listClusterInfo", exn);
                    crate::services::storage_admin_service::ListClusterInfoExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "listClusterInfo",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }
    }

    #[::async_trait::async_trait]
    impl<P, H, R, RS> ::fbthrift::ServiceProcessor<P> for StorageAdminServiceProcessor<P, H, R, RS>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Deserializer: ::std::marker::Send,
        H: StorageAdminService,
        P::Frame: ::std::marker::Send + 'static,
        R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Buffer = ::fbthrift::ProtocolDecoded<P>>
            + ::std::marker::Send + ::std::marker::Sync + 'static,
        RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static
    {
        type RequestContext = R;
        type ReplyState = RS;

        #[inline]
        fn method_idx(&self, name: &[::std::primitive::u8]) -> ::std::result::Result<::std::primitive::usize, ::fbthrift::ApplicationException> {
            match name {
                b"transLeader" => ::std::result::Result::Ok(0usize),
                b"addPart" => ::std::result::Result::Ok(1usize),
                b"addLearner" => ::std::result::Result::Ok(2usize),
                b"removePart" => ::std::result::Result::Ok(3usize),
                b"memberChange" => ::std::result::Result::Ok(4usize),
                b"waitingForCatchUpData" => ::std::result::Result::Ok(5usize),
                b"createCheckpoint" => ::std::result::Result::Ok(6usize),
                b"dropCheckpoint" => ::std::result::Result::Ok(7usize),
                b"blockingWrites" => ::std::result::Result::Ok(8usize),
                b"rebuildTagIndex" => ::std::result::Result::Ok(9usize),
                b"rebuildEdgeIndex" => ::std::result::Result::Ok(10usize),
                b"getLeaderParts" => ::std::result::Result::Ok(11usize),
                b"checkPeers" => ::std::result::Result::Ok(12usize),
                b"addAdminTask" => ::std::result::Result::Ok(13usize),
                b"stopAdminTask" => ::std::result::Result::Ok(14usize),
                b"listClusterInfo" => ::std::result::Result::Ok(15usize),
                _ => ::std::result::Result::Err(::fbthrift::ApplicationException::unknown_method()),
            }
        }

        #[allow(clippy::match_single_binding)]
        async fn handle_method(
            &self,
            idx: ::std::primitive::usize,
            _p: &mut P::Deserializer,
            _r: &R,
            _reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            match idx {
                0usize => {
                    self.handle_transLeader(_p, _r, _reply_state, _seqid).await
                }
                1usize => {
                    self.handle_addPart(_p, _r, _reply_state, _seqid).await
                }
                2usize => {
                    self.handle_addLearner(_p, _r, _reply_state, _seqid).await
                }
                3usize => {
                    self.handle_removePart(_p, _r, _reply_state, _seqid).await
                }
                4usize => {
                    self.handle_memberChange(_p, _r, _reply_state, _seqid).await
                }
                5usize => {
                    self.handle_waitingForCatchUpData(_p, _r, _reply_state, _seqid).await
                }
                6usize => {
                    self.handle_createCheckpoint(_p, _r, _reply_state, _seqid).await
                }
                7usize => {
                    self.handle_dropCheckpoint(_p, _r, _reply_state, _seqid).await
                }
                8usize => {
                    self.handle_blockingWrites(_p, _r, _reply_state, _seqid).await
                }
                9usize => {
                    self.handle_rebuildTagIndex(_p, _r, _reply_state, _seqid).await
                }
                10usize => {
                    self.handle_rebuildEdgeIndex(_p, _r, _reply_state, _seqid).await
                }
                11usize => {
                    self.handle_getLeaderParts(_p, _r, _reply_state, _seqid).await
                }
                12usize => {
                    self.handle_checkPeers(_p, _r, _reply_state, _seqid).await
                }
                13usize => {
                    self.handle_addAdminTask(_p, _r, _reply_state, _seqid).await
                }
                14usize => {
                    self.handle_stopAdminTask(_p, _r, _reply_state, _seqid).await
                }
                15usize => {
                    self.handle_listClusterInfo(_p, _r, _reply_state, _seqid).await
                }
                bad => panic!(
                    "{}: unexpected method idx {}",
                    "StorageAdminServiceProcessor",
                    bad
                ),
            }
        }

        #[allow(clippy::match_single_binding)]
        #[inline]
        fn create_interaction_idx(&self, name: &str) -> ::anyhow::Result<::std::primitive::usize> {
            match name {
                _ => ::anyhow::bail!("Unknown interaction"),
            }
        }

        #[allow(clippy::match_single_binding)]
        fn handle_create_interaction(
            &self,
            idx: ::std::primitive::usize,
        ) -> ::anyhow::Result<
            ::std::sync::Arc<dyn ::fbthrift::ThriftService<P::Frame, Handler = (), RequestContext = Self::RequestContext, ReplyState = Self::ReplyState> + ::std::marker::Send + 'static>
        > {
            match idx {
                bad => panic!(
                    "{}: unexpected method idx {}",
                    "StorageAdminServiceProcessor",
                    bad
                ),
            }
        }
    }

    #[::async_trait::async_trait]
    impl<P, H, R, RS> ::fbthrift::ThriftService<P::Frame> for StorageAdminServiceProcessor<P, H, R, RS>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Deserializer: ::std::marker::Send,
        P::Frame: ::std::marker::Send + 'static,
        H: StorageAdminService,
        R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Buffer = ::fbthrift::ProtocolDecoded<P>>
            + ::std::marker::Send + ::std::marker::Sync + 'static,
        RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static
    {
        type Handler = H;
        type RequestContext = R;
        type ReplyState = RS;

        #[tracing::instrument(level="trace", skip_all, fields(service = "StorageAdminService"))]
        async fn call(
            &self,
            req: ::fbthrift::ProtocolDecoded<P>,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
        ) -> ::anyhow::Result<()> {
            use ::fbthrift::{BufExt as _, ProtocolReader as _, ServiceProcessor as _};
            let mut p = P::deserializer(req);
            let (idx, mty, seqid) = p.read_message_begin(|name| self.method_idx(name))?;
            if mty != ::fbthrift::MessageType::Call {
                return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::InvalidMessageType,
                    format!("message type {:?} not handled", mty)
                )));
            }
            let idx = match idx {
                ::std::result::Result::Ok(idx) => idx,
                ::std::result::Result::Err(_) => {
                    let cur = P::into_buffer(p).reset();
                    return self.supa.call(cur, req_ctxt, reply_state).await;
                }
            };
            self.handle_method(idx, &mut p, req_ctxt, reply_state, seqid).await?;
            p.read_message_end()?;

            Ok(())
        }

        fn create_interaction(
            &self,
            name: &str,
        ) -> ::anyhow::Result<
            ::std::sync::Arc<dyn ::fbthrift::ThriftService<P::Frame, Handler = (), RequestContext = R, ReplyState = RS> + ::std::marker::Send + 'static>
        > {
            use ::fbthrift::{ServiceProcessor as _};
            let idx = self.create_interaction_idx(name);
            let idx = match idx {
                ::anyhow::Result::Ok(idx) => idx,
                ::anyhow::Result::Err(_) => {
                    return self.supa.create_interaction(name);
                }
            };
            self.handle_create_interaction(idx)
        }

        fn get_method_names(&self) -> &'static [&'static str] {
            &[
                // from StorageAdminService
                "transLeader",
                "addPart",
                "addLearner",
                "removePart",
                "memberChange",
                "waitingForCatchUpData",
                "createCheckpoint",
                "dropCheckpoint",
                "blockingWrites",
                "rebuildTagIndex",
                "rebuildEdgeIndex",
                "getLeaderParts",
                "checkPeers",
                "addAdminTask",
                "stopAdminTask",
                "listClusterInfo",
            ]
        }
    }

    /// Construct a new instance of a StorageAdminService service.
    ///
    /// This is called when a new instance of a Thrift service Processor
    /// is needed for a particular Thrift protocol.
    #[::tracing::instrument(level="debug", skip_all, fields(proto = ?proto))]
    pub fn make_StorageAdminService_server<F, H, R, RS>(
        proto: ::fbthrift::ProtocolID,
        handler: H,
    ) -> ::std::result::Result<::std::boxed::Box<dyn ::fbthrift::ThriftService<F, Handler = H, RequestContext = R, ReplyState = RS> + ::std::marker::Send + 'static>, ::fbthrift::ApplicationException>
    where
        F: ::fbthrift::Framing + ::std::marker::Send + ::std::marker::Sync + 'static,
        H: StorageAdminService,
        R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Buffer = F::DecBuf> + ::std::marker::Send + ::std::marker::Sync + 'static,
        RS: ::fbthrift::ReplyState<F, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static
    {
        match proto {
            ::fbthrift::ProtocolID::BinaryProtocol => {
                ::std::result::Result::Ok(::std::boxed::Box::new(StorageAdminServiceProcessor::<::fbthrift::BinaryProtocol<F>, H, R, RS>::new(handler)))
            }
            ::fbthrift::ProtocolID::CompactProtocol => {
                ::std::result::Result::Ok(::std::boxed::Box::new(StorageAdminServiceProcessor::<::fbthrift::CompactProtocol<F>, H, R, RS>::new(handler)))
            }
            bad => {
                ::tracing::error!(method = "StorageAdminService.", invalid_protocol = ?bad);
                ::std::result::Result::Err(::fbthrift::ApplicationException::invalid_protocol(bad))
            }
        }
    }

    #[::async_trait::async_trait]
    pub trait GeneralStorageService: ::std::marker::Send + ::std::marker::Sync + 'static {
        async fn get(
            &self,
            _req: crate::types::KVGetRequest,
        ) -> ::std::result::Result<crate::types::KVGetResponse, crate::services::general_storage_service::GetExn> {
            ::std::result::Result::Err(crate::services::general_storage_service::GetExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "GeneralStorageService",
                    "get",
                ),
            ))
        }
        async fn put(
            &self,
            _req: crate::types::KVPutRequest,
        ) -> ::std::result::Result<crate::types::ExecResponse, crate::services::general_storage_service::PutExn> {
            ::std::result::Result::Err(crate::services::general_storage_service::PutExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "GeneralStorageService",
                    "put",
                ),
            ))
        }
        async fn remove(
            &self,
            _req: crate::types::KVRemoveRequest,
        ) -> ::std::result::Result<crate::types::ExecResponse, crate::services::general_storage_service::RemoveExn> {
            ::std::result::Result::Err(crate::services::general_storage_service::RemoveExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "GeneralStorageService",
                    "remove",
                ),
            ))
        }
    }

    #[::async_trait::async_trait]
    impl<T> GeneralStorageService for ::std::boxed::Box<T>
    where
        T: GeneralStorageService + Send + Sync + ?Sized,
    {
        async fn get(
            &self,
            req: crate::types::KVGetRequest,
        ) -> ::std::result::Result<crate::types::KVGetResponse, crate::services::general_storage_service::GetExn> {
            (**self).get(
                req,
            ).await
        }
        async fn put(
            &self,
            req: crate::types::KVPutRequest,
        ) -> ::std::result::Result<crate::types::ExecResponse, crate::services::general_storage_service::PutExn> {
            (**self).put(
                req,
            ).await
        }
        async fn remove(
            &self,
            req: crate::types::KVRemoveRequest,
        ) -> ::std::result::Result<crate::types::ExecResponse, crate::services::general_storage_service::RemoveExn> {
            (**self).remove(
                req,
            ).await
        }
    }

    /// Processor for GeneralStorageService's methods.
    #[derive(Clone, Debug)]
    pub struct GeneralStorageServiceProcessor<P, H, R, RS> {
        service: H,
        supa: ::fbthrift::NullServiceProcessor<P, R, RS>,
        _phantom: ::std::marker::PhantomData<(P, H, R, RS)>,
    }

    struct Args_GeneralStorageService_get {
        req: crate::types::KVGetRequest,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_GeneralStorageService_get {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "GeneralStorageService.get"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "GeneralStorageService.get", "req"))?,
            })
        }
    }

    struct Args_GeneralStorageService_put {
        req: crate::types::KVPutRequest,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_GeneralStorageService_put {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "GeneralStorageService.put"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "GeneralStorageService.put", "req"))?,
            })
        }
    }

    struct Args_GeneralStorageService_remove {
        req: crate::types::KVRemoveRequest,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_GeneralStorageService_remove {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "GeneralStorageService.remove"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "GeneralStorageService.remove", "req"))?,
            })
        }
    }


    impl<P, H, R, RS> GeneralStorageServiceProcessor<P, H, R, RS>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Frame: ::std::marker::Send + 'static,
        P::Deserializer: ::std::marker::Send,
        H: GeneralStorageService,
        R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Buffer = ::fbthrift::ProtocolDecoded<P>>
            + ::std::marker::Send + ::std::marker::Sync,
    {
        pub fn new(service: H) -> Self {
            Self {
                service,
                supa: ::fbthrift::NullServiceProcessor::new(),
                _phantom: ::std::marker::PhantomData,
            }
        }

        pub fn into_inner(self) -> H {
            self.service
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "GeneralStorageService.get"))]
        async fn handle_get<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "GeneralStorageService";
                METHOD_NAME = "GeneralStorageService.get";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_GeneralStorageService_get = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.get(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::general_storage_service::GetExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::general_storage_service::GetExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "get",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("GeneralStorageService.get", exn);
                    crate::services::general_storage_service::GetExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "get",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "GeneralStorageService.put"))]
        async fn handle_put<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "GeneralStorageService";
                METHOD_NAME = "GeneralStorageService.put";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_GeneralStorageService_put = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.put(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::general_storage_service::PutExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::general_storage_service::PutExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "put",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("GeneralStorageService.put", exn);
                    crate::services::general_storage_service::PutExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "put",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "GeneralStorageService.remove"))]
        async fn handle_remove<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "GeneralStorageService";
                METHOD_NAME = "GeneralStorageService.remove";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_GeneralStorageService_remove = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.remove(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::general_storage_service::RemoveExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::general_storage_service::RemoveExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "remove",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("GeneralStorageService.remove", exn);
                    crate::services::general_storage_service::RemoveExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "remove",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }
    }

    #[::async_trait::async_trait]
    impl<P, H, R, RS> ::fbthrift::ServiceProcessor<P> for GeneralStorageServiceProcessor<P, H, R, RS>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Deserializer: ::std::marker::Send,
        H: GeneralStorageService,
        P::Frame: ::std::marker::Send + 'static,
        R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Buffer = ::fbthrift::ProtocolDecoded<P>>
            + ::std::marker::Send + ::std::marker::Sync + 'static,
        RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static
    {
        type RequestContext = R;
        type ReplyState = RS;

        #[inline]
        fn method_idx(&self, name: &[::std::primitive::u8]) -> ::std::result::Result<::std::primitive::usize, ::fbthrift::ApplicationException> {
            match name {
                b"get" => ::std::result::Result::Ok(0usize),
                b"put" => ::std::result::Result::Ok(1usize),
                b"remove" => ::std::result::Result::Ok(2usize),
                _ => ::std::result::Result::Err(::fbthrift::ApplicationException::unknown_method()),
            }
        }

        #[allow(clippy::match_single_binding)]
        async fn handle_method(
            &self,
            idx: ::std::primitive::usize,
            _p: &mut P::Deserializer,
            _r: &R,
            _reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            match idx {
                0usize => {
                    self.handle_get(_p, _r, _reply_state, _seqid).await
                }
                1usize => {
                    self.handle_put(_p, _r, _reply_state, _seqid).await
                }
                2usize => {
                    self.handle_remove(_p, _r, _reply_state, _seqid).await
                }
                bad => panic!(
                    "{}: unexpected method idx {}",
                    "GeneralStorageServiceProcessor",
                    bad
                ),
            }
        }

        #[allow(clippy::match_single_binding)]
        #[inline]
        fn create_interaction_idx(&self, name: &str) -> ::anyhow::Result<::std::primitive::usize> {
            match name {
                _ => ::anyhow::bail!("Unknown interaction"),
            }
        }

        #[allow(clippy::match_single_binding)]
        fn handle_create_interaction(
            &self,
            idx: ::std::primitive::usize,
        ) -> ::anyhow::Result<
            ::std::sync::Arc<dyn ::fbthrift::ThriftService<P::Frame, Handler = (), RequestContext = Self::RequestContext, ReplyState = Self::ReplyState> + ::std::marker::Send + 'static>
        > {
            match idx {
                bad => panic!(
                    "{}: unexpected method idx {}",
                    "GeneralStorageServiceProcessor",
                    bad
                ),
            }
        }
    }

    #[::async_trait::async_trait]
    impl<P, H, R, RS> ::fbthrift::ThriftService<P::Frame> for GeneralStorageServiceProcessor<P, H, R, RS>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Deserializer: ::std::marker::Send,
        P::Frame: ::std::marker::Send + 'static,
        H: GeneralStorageService,
        R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Buffer = ::fbthrift::ProtocolDecoded<P>>
            + ::std::marker::Send + ::std::marker::Sync + 'static,
        RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static
    {
        type Handler = H;
        type RequestContext = R;
        type ReplyState = RS;

        #[tracing::instrument(level="trace", skip_all, fields(service = "GeneralStorageService"))]
        async fn call(
            &self,
            req: ::fbthrift::ProtocolDecoded<P>,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
        ) -> ::anyhow::Result<()> {
            use ::fbthrift::{BufExt as _, ProtocolReader as _, ServiceProcessor as _};
            let mut p = P::deserializer(req);
            let (idx, mty, seqid) = p.read_message_begin(|name| self.method_idx(name))?;
            if mty != ::fbthrift::MessageType::Call {
                return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::InvalidMessageType,
                    format!("message type {:?} not handled", mty)
                )));
            }
            let idx = match idx {
                ::std::result::Result::Ok(idx) => idx,
                ::std::result::Result::Err(_) => {
                    let cur = P::into_buffer(p).reset();
                    return self.supa.call(cur, req_ctxt, reply_state).await;
                }
            };
            self.handle_method(idx, &mut p, req_ctxt, reply_state, seqid).await?;
            p.read_message_end()?;

            Ok(())
        }

        fn create_interaction(
            &self,
            name: &str,
        ) -> ::anyhow::Result<
            ::std::sync::Arc<dyn ::fbthrift::ThriftService<P::Frame, Handler = (), RequestContext = R, ReplyState = RS> + ::std::marker::Send + 'static>
        > {
            use ::fbthrift::{ServiceProcessor as _};
            let idx = self.create_interaction_idx(name);
            let idx = match idx {
                ::anyhow::Result::Ok(idx) => idx,
                ::anyhow::Result::Err(_) => {
                    return self.supa.create_interaction(name);
                }
            };
            self.handle_create_interaction(idx)
        }

        fn get_method_names(&self) -> &'static [&'static str] {
            &[
                // from GeneralStorageService
                "get",
                "put",
                "remove",
            ]
        }
    }

    /// Construct a new instance of a GeneralStorageService service.
    ///
    /// This is called when a new instance of a Thrift service Processor
    /// is needed for a particular Thrift protocol.
    #[::tracing::instrument(level="debug", skip_all, fields(proto = ?proto))]
    pub fn make_GeneralStorageService_server<F, H, R, RS>(
        proto: ::fbthrift::ProtocolID,
        handler: H,
    ) -> ::std::result::Result<::std::boxed::Box<dyn ::fbthrift::ThriftService<F, Handler = H, RequestContext = R, ReplyState = RS> + ::std::marker::Send + 'static>, ::fbthrift::ApplicationException>
    where
        F: ::fbthrift::Framing + ::std::marker::Send + ::std::marker::Sync + 'static,
        H: GeneralStorageService,
        R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Buffer = F::DecBuf> + ::std::marker::Send + ::std::marker::Sync + 'static,
        RS: ::fbthrift::ReplyState<F, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static
    {
        match proto {
            ::fbthrift::ProtocolID::BinaryProtocol => {
                ::std::result::Result::Ok(::std::boxed::Box::new(GeneralStorageServiceProcessor::<::fbthrift::BinaryProtocol<F>, H, R, RS>::new(handler)))
            }
            ::fbthrift::ProtocolID::CompactProtocol => {
                ::std::result::Result::Ok(::std::boxed::Box::new(GeneralStorageServiceProcessor::<::fbthrift::CompactProtocol<F>, H, R, RS>::new(handler)))
            }
            bad => {
                ::tracing::error!(method = "GeneralStorageService.", invalid_protocol = ?bad);
                ::std::result::Result::Err(::fbthrift::ApplicationException::invalid_protocol(bad))
            }
        }
    }

    #[::async_trait::async_trait]
    pub trait InternalStorageService: ::std::marker::Send + ::std::marker::Sync + 'static {
        async fn chainAddEdges(
            &self,
            _req: crate::types::ChainAddEdgesRequest,
        ) -> ::std::result::Result<crate::types::ExecResponse, crate::services::internal_storage_service::ChainAddEdgesExn> {
            ::std::result::Result::Err(crate::services::internal_storage_service::ChainAddEdgesExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "InternalStorageService",
                    "chainAddEdges",
                ),
            ))
        }
        async fn chainUpdateEdge(
            &self,
            _req: crate::types::ChainUpdateEdgeRequest,
        ) -> ::std::result::Result<crate::types::UpdateResponse, crate::services::internal_storage_service::ChainUpdateEdgeExn> {
            ::std::result::Result::Err(crate::services::internal_storage_service::ChainUpdateEdgeExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "InternalStorageService",
                    "chainUpdateEdge",
                ),
            ))
        }
    }

    #[::async_trait::async_trait]
    impl<T> InternalStorageService for ::std::boxed::Box<T>
    where
        T: InternalStorageService + Send + Sync + ?Sized,
    {
        async fn chainAddEdges(
            &self,
            req: crate::types::ChainAddEdgesRequest,
        ) -> ::std::result::Result<crate::types::ExecResponse, crate::services::internal_storage_service::ChainAddEdgesExn> {
            (**self).chainAddEdges(
                req,
            ).await
        }
        async fn chainUpdateEdge(
            &self,
            req: crate::types::ChainUpdateEdgeRequest,
        ) -> ::std::result::Result<crate::types::UpdateResponse, crate::services::internal_storage_service::ChainUpdateEdgeExn> {
            (**self).chainUpdateEdge(
                req,
            ).await
        }
    }

    /// Processor for InternalStorageService's methods.
    #[derive(Clone, Debug)]
    pub struct InternalStorageServiceProcessor<P, H, R, RS> {
        service: H,
        supa: ::fbthrift::NullServiceProcessor<P, R, RS>,
        _phantom: ::std::marker::PhantomData<(P, H, R, RS)>,
    }

    struct Args_InternalStorageService_chainAddEdges {
        req: crate::types::ChainAddEdgesRequest,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_InternalStorageService_chainAddEdges {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "InternalStorageService.chainAddEdges"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "InternalStorageService.chainAddEdges", "req"))?,
            })
        }
    }

    struct Args_InternalStorageService_chainUpdateEdge {
        req: crate::types::ChainUpdateEdgeRequest,
    }
    impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_InternalStorageService_chainUpdateEdge {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "InternalStorageService.chainUpdateEdge"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "InternalStorageService.chainUpdateEdge", "req"))?,
            })
        }
    }


    impl<P, H, R, RS> InternalStorageServiceProcessor<P, H, R, RS>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Frame: ::std::marker::Send + 'static,
        P::Deserializer: ::std::marker::Send,
        H: InternalStorageService,
        R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Buffer = ::fbthrift::ProtocolDecoded<P>>
            + ::std::marker::Send + ::std::marker::Sync,
    {
        pub fn new(service: H) -> Self {
            Self {
                service,
                supa: ::fbthrift::NullServiceProcessor::new(),
                _phantom: ::std::marker::PhantomData,
            }
        }

        pub fn into_inner(self) -> H {
            self.service
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "InternalStorageService.chainAddEdges"))]
        async fn handle_chainAddEdges<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "InternalStorageService";
                METHOD_NAME = "InternalStorageService.chainAddEdges";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_InternalStorageService_chainAddEdges = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.chainAddEdges(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::internal_storage_service::ChainAddEdgesExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::internal_storage_service::ChainAddEdgesExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "chainAddEdges",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("InternalStorageService.chainAddEdges", exn);
                    crate::services::internal_storage_service::ChainAddEdgesExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "chainAddEdges",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "InternalStorageService.chainUpdateEdge"))]
        async fn handle_chainUpdateEdge<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "InternalStorageService";
                METHOD_NAME = "InternalStorageService.chainUpdateEdge";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_InternalStorageService_chainUpdateEdge = ::fbthrift::Deserialize::read(p)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.chainUpdateEdge(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::services::internal_storage_service::ChainUpdateEdgeExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::internal_storage_service::ChainUpdateEdgeExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "chainUpdateEdge",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("InternalStorageService.chainUpdateEdge", exn);
                    crate::services::internal_storage_service::ChainUpdateEdgeExn::ApplicationException(aexn)
                }
            };

            let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "chainUpdateEdge",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }
    }

    #[::async_trait::async_trait]
    impl<P, H, R, RS> ::fbthrift::ServiceProcessor<P> for InternalStorageServiceProcessor<P, H, R, RS>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Deserializer: ::std::marker::Send,
        H: InternalStorageService,
        P::Frame: ::std::marker::Send + 'static,
        R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Buffer = ::fbthrift::ProtocolDecoded<P>>
            + ::std::marker::Send + ::std::marker::Sync + 'static,
        RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static
    {
        type RequestContext = R;
        type ReplyState = RS;

        #[inline]
        fn method_idx(&self, name: &[::std::primitive::u8]) -> ::std::result::Result<::std::primitive::usize, ::fbthrift::ApplicationException> {
            match name {
                b"chainAddEdges" => ::std::result::Result::Ok(0usize),
                b"chainUpdateEdge" => ::std::result::Result::Ok(1usize),
                _ => ::std::result::Result::Err(::fbthrift::ApplicationException::unknown_method()),
            }
        }

        #[allow(clippy::match_single_binding)]
        async fn handle_method(
            &self,
            idx: ::std::primitive::usize,
            _p: &mut P::Deserializer,
            _r: &R,
            _reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            match idx {
                0usize => {
                    self.handle_chainAddEdges(_p, _r, _reply_state, _seqid).await
                }
                1usize => {
                    self.handle_chainUpdateEdge(_p, _r, _reply_state, _seqid).await
                }
                bad => panic!(
                    "{}: unexpected method idx {}",
                    "InternalStorageServiceProcessor",
                    bad
                ),
            }
        }

        #[allow(clippy::match_single_binding)]
        #[inline]
        fn create_interaction_idx(&self, name: &str) -> ::anyhow::Result<::std::primitive::usize> {
            match name {
                _ => ::anyhow::bail!("Unknown interaction"),
            }
        }

        #[allow(clippy::match_single_binding)]
        fn handle_create_interaction(
            &self,
            idx: ::std::primitive::usize,
        ) -> ::anyhow::Result<
            ::std::sync::Arc<dyn ::fbthrift::ThriftService<P::Frame, Handler = (), RequestContext = Self::RequestContext, ReplyState = Self::ReplyState> + ::std::marker::Send + 'static>
        > {
            match idx {
                bad => panic!(
                    "{}: unexpected method idx {}",
                    "InternalStorageServiceProcessor",
                    bad
                ),
            }
        }
    }

    #[::async_trait::async_trait]
    impl<P, H, R, RS> ::fbthrift::ThriftService<P::Frame> for InternalStorageServiceProcessor<P, H, R, RS>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Deserializer: ::std::marker::Send,
        P::Frame: ::std::marker::Send + 'static,
        H: InternalStorageService,
        R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Buffer = ::fbthrift::ProtocolDecoded<P>>
            + ::std::marker::Send + ::std::marker::Sync + 'static,
        RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static
    {
        type Handler = H;
        type RequestContext = R;
        type ReplyState = RS;

        #[tracing::instrument(level="trace", skip_all, fields(service = "InternalStorageService"))]
        async fn call(
            &self,
            req: ::fbthrift::ProtocolDecoded<P>,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
        ) -> ::anyhow::Result<()> {
            use ::fbthrift::{BufExt as _, ProtocolReader as _, ServiceProcessor as _};
            let mut p = P::deserializer(req);
            let (idx, mty, seqid) = p.read_message_begin(|name| self.method_idx(name))?;
            if mty != ::fbthrift::MessageType::Call {
                return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::InvalidMessageType,
                    format!("message type {:?} not handled", mty)
                )));
            }
            let idx = match idx {
                ::std::result::Result::Ok(idx) => idx,
                ::std::result::Result::Err(_) => {
                    let cur = P::into_buffer(p).reset();
                    return self.supa.call(cur, req_ctxt, reply_state).await;
                }
            };
            self.handle_method(idx, &mut p, req_ctxt, reply_state, seqid).await?;
            p.read_message_end()?;

            Ok(())
        }

        fn create_interaction(
            &self,
            name: &str,
        ) -> ::anyhow::Result<
            ::std::sync::Arc<dyn ::fbthrift::ThriftService<P::Frame, Handler = (), RequestContext = R, ReplyState = RS> + ::std::marker::Send + 'static>
        > {
            use ::fbthrift::{ServiceProcessor as _};
            let idx = self.create_interaction_idx(name);
            let idx = match idx {
                ::anyhow::Result::Ok(idx) => idx,
                ::anyhow::Result::Err(_) => {
                    return self.supa.create_interaction(name);
                }
            };
            self.handle_create_interaction(idx)
        }

        fn get_method_names(&self) -> &'static [&'static str] {
            &[
                // from InternalStorageService
                "chainAddEdges",
                "chainUpdateEdge",
            ]
        }
    }

    /// Construct a new instance of a InternalStorageService service.
    ///
    /// This is called when a new instance of a Thrift service Processor
    /// is needed for a particular Thrift protocol.
    #[::tracing::instrument(level="debug", skip_all, fields(proto = ?proto))]
    pub fn make_InternalStorageService_server<F, H, R, RS>(
        proto: ::fbthrift::ProtocolID,
        handler: H,
    ) -> ::std::result::Result<::std::boxed::Box<dyn ::fbthrift::ThriftService<F, Handler = H, RequestContext = R, ReplyState = RS> + ::std::marker::Send + 'static>, ::fbthrift::ApplicationException>
    where
        F: ::fbthrift::Framing + ::std::marker::Send + ::std::marker::Sync + 'static,
        H: InternalStorageService,
        R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Buffer = F::DecBuf> + ::std::marker::Send + ::std::marker::Sync + 'static,
        RS: ::fbthrift::ReplyState<F, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static
    {
        match proto {
            ::fbthrift::ProtocolID::BinaryProtocol => {
                ::std::result::Result::Ok(::std::boxed::Box::new(InternalStorageServiceProcessor::<::fbthrift::BinaryProtocol<F>, H, R, RS>::new(handler)))
            }
            ::fbthrift::ProtocolID::CompactProtocol => {
                ::std::result::Result::Ok(::std::boxed::Box::new(InternalStorageServiceProcessor::<::fbthrift::CompactProtocol<F>, H, R, RS>::new(handler)))
            }
            bad => {
                ::tracing::error!(method = "InternalStorageService.", invalid_protocol = ?bad);
                ::std::result::Result::Err(::fbthrift::ApplicationException::invalid_protocol(bad))
            }
        }
    }
}

/// Client mocks. For every service, a struct mock::TheService that implements
/// client::TheService.
///
/// As an example of the generated API, for the following thrift service:
///
/// ```thrift
/// service MyService {
///     FunctionResponse myFunction(
///         1: FunctionRequest request,
///     ) throws {
///         1: StorageException s,
///         2: NotFoundException n,
///     ),
///
///     // other functions
/// }
/// ```
///
/// we would end up with this mock object under crate::mock::MyService:
///
/// ```
/// # const _: &str = stringify! {
/// impl crate::client::MyService for MyService<'mock> {...}
///
/// pub struct MyService<'mock> {
///     pub myFunction: myFunction<'mock>,
///     // ...
/// }
///
/// impl dyn crate::client::MyService {
///     pub fn mock<'mock>() -> MyService<'mock>;
/// }
///
/// impl myFunction<'mock> {
///     // directly return the given success response
///     pub fn ret(&self, value: FunctionResponse);
///
///     // invoke closure to compute success response
///     pub fn mock(
///         &self,
///         mock: impl FnMut(FunctionRequest) -> FunctionResponse + Send + Sync + 'mock,
///     );
///
///     // invoke closure to compute response
///     pub fn mock_result(
///         &self,
///         mock: impl FnMut(FunctionRequest) -> Result<FunctionResponse, crate::services::MyService::MyFunctionExn> + Send + Sync + 'mock,
///     );
///
///     // return one of the function's declared exceptions
///     pub fn throw<E>(&self, exception: E)
///     where
///         E: Clone + Into<crate::services::MyService::MyFunctionExn> + Send + Sync + 'mock;
/// }
///
/// impl From<StorageException> for MyFunctionExn {...}
/// impl From<NotFoundException> for MyFunctionExn {...}
/// # };
/// ```
///
/// The intended usage from a test would be:
///
/// ```
/// # const _: &str = stringify! {
/// use std::sync::Arc;
/// use thrift_if::client::MyService;
///
/// #[test]
/// fn test_my_client() {
///     let mock = Arc::new(<dyn MyService>::mock());
///
///     // directly return a success response
///     let resp = FunctionResponse {...};
///     mock.myFunction.ret(resp);
///
///     // or give a closure to compute the success response
///     mock.myFunction.mock(|request| FunctionResponse {...});
///
///     // or throw one of the function's exceptions
///     mock.myFunction.throw(StorageException::ItFailed);
///
///     // or compute a Result (useful if your exceptions aren't Clone)
///     mock.myFunction.mock_result(|request| Err(...));
///
///     let out = do_the_thing(mock).wait().unwrap();
///     assert!(out.what_i_expected());
/// }
///
/// fn do_the_thing(
///     client: Arc<dyn MyService + Send + Sync + 'static>,
/// ) -> impl Future<Item = Out> {...}
/// # };
/// ```
pub mod mock {
    pub struct GraphStorageService<'mock> {
        pub getNeighbors: r#impl::graph_storage_service::getNeighbors<'mock>,
        pub getProps: r#impl::graph_storage_service::getProps<'mock>,
        pub addVertices: r#impl::graph_storage_service::addVertices<'mock>,
        pub addEdges: r#impl::graph_storage_service::addEdges<'mock>,
        pub deleteEdges: r#impl::graph_storage_service::deleteEdges<'mock>,
        pub deleteVertices: r#impl::graph_storage_service::deleteVertices<'mock>,
        pub deleteTags: r#impl::graph_storage_service::deleteTags<'mock>,
        pub updateVertex: r#impl::graph_storage_service::updateVertex<'mock>,
        pub updateEdge: r#impl::graph_storage_service::updateEdge<'mock>,
        pub scanVertex: r#impl::graph_storage_service::scanVertex<'mock>,
        pub scanEdge: r#impl::graph_storage_service::scanEdge<'mock>,
        pub getUUID: r#impl::graph_storage_service::getUUID<'mock>,
        pub lookupIndex: r#impl::graph_storage_service::lookupIndex<'mock>,
        pub lookupAndTraverse: r#impl::graph_storage_service::lookupAndTraverse<'mock>,
        pub chainUpdateEdge: r#impl::graph_storage_service::chainUpdateEdge<'mock>,
        pub chainAddEdges: r#impl::graph_storage_service::chainAddEdges<'mock>,
        _marker: ::std::marker::PhantomData<&'mock ()>,
    }

    impl dyn super::client::GraphStorageService {
        pub fn mock<'mock>() -> GraphStorageService<'mock> {
            GraphStorageService {
                getNeighbors: r#impl::graph_storage_service::getNeighbors::unimplemented(),
                getProps: r#impl::graph_storage_service::getProps::unimplemented(),
                addVertices: r#impl::graph_storage_service::addVertices::unimplemented(),
                addEdges: r#impl::graph_storage_service::addEdges::unimplemented(),
                deleteEdges: r#impl::graph_storage_service::deleteEdges::unimplemented(),
                deleteVertices: r#impl::graph_storage_service::deleteVertices::unimplemented(),
                deleteTags: r#impl::graph_storage_service::deleteTags::unimplemented(),
                updateVertex: r#impl::graph_storage_service::updateVertex::unimplemented(),
                updateEdge: r#impl::graph_storage_service::updateEdge::unimplemented(),
                scanVertex: r#impl::graph_storage_service::scanVertex::unimplemented(),
                scanEdge: r#impl::graph_storage_service::scanEdge::unimplemented(),
                getUUID: r#impl::graph_storage_service::getUUID::unimplemented(),
                lookupIndex: r#impl::graph_storage_service::lookupIndex::unimplemented(),
                lookupAndTraverse: r#impl::graph_storage_service::lookupAndTraverse::unimplemented(),
                chainUpdateEdge: r#impl::graph_storage_service::chainUpdateEdge::unimplemented(),
                chainAddEdges: r#impl::graph_storage_service::chainAddEdges::unimplemented(),
                _marker: ::std::marker::PhantomData,
            }
        }
    }

    impl<'mock> super::client::GraphStorageService for GraphStorageService<'mock> {
        fn getNeighbors(
            &self,
            arg_req: &crate::types::GetNeighborsRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetNeighborsResponse, crate::errors::graph_storage_service::GetNeighborsError>> {
            let mut closure = self.getNeighbors.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GetNeighborsRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn getProps(
            &self,
            arg_req: &crate::types::GetPropRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetPropResponse, crate::errors::graph_storage_service::GetPropsError>> {
            let mut closure = self.getProps.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GetPropRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn addVertices(
            &self,
            arg_req: &crate::types::AddVerticesRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::AddVerticesError>> {
            let mut closure = self.addVertices.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::AddVerticesRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn addEdges(
            &self,
            arg_req: &crate::types::AddEdgesRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::AddEdgesError>> {
            let mut closure = self.addEdges.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::AddEdgesRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn deleteEdges(
            &self,
            arg_req: &crate::types::DeleteEdgesRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::DeleteEdgesError>> {
            let mut closure = self.deleteEdges.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::DeleteEdgesRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn deleteVertices(
            &self,
            arg_req: &crate::types::DeleteVerticesRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::DeleteVerticesError>> {
            let mut closure = self.deleteVertices.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::DeleteVerticesRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn deleteTags(
            &self,
            arg_req: &crate::types::DeleteTagsRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::DeleteTagsError>> {
            let mut closure = self.deleteTags.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::DeleteTagsRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn updateVertex(
            &self,
            arg_req: &crate::types::UpdateVertexRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::UpdateResponse, crate::errors::graph_storage_service::UpdateVertexError>> {
            let mut closure = self.updateVertex.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::UpdateVertexRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn updateEdge(
            &self,
            arg_req: &crate::types::UpdateEdgeRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::UpdateResponse, crate::errors::graph_storage_service::UpdateEdgeError>> {
            let mut closure = self.updateEdge.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::UpdateEdgeRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn scanVertex(
            &self,
            arg_req: &crate::types::ScanVertexRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ScanVertexResponse, crate::errors::graph_storage_service::ScanVertexError>> {
            let mut closure = self.scanVertex.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ScanVertexRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn scanEdge(
            &self,
            arg_req: &crate::types::ScanEdgeRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ScanEdgeResponse, crate::errors::graph_storage_service::ScanEdgeError>> {
            let mut closure = self.scanEdge.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ScanEdgeRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn getUUID(
            &self,
            arg_req: &crate::types::GetUUIDReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetUUIDResp, crate::errors::graph_storage_service::GetUUIDError>> {
            let mut closure = self.getUUID.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GetUUIDReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn lookupIndex(
            &self,
            arg_req: &crate::types::LookupIndexRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::LookupIndexResp, crate::errors::graph_storage_service::LookupIndexError>> {
            let mut closure = self.lookupIndex.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::LookupIndexRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn lookupAndTraverse(
            &self,
            arg_req: &crate::types::LookupAndTraverseRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetNeighborsResponse, crate::errors::graph_storage_service::LookupAndTraverseError>> {
            let mut closure = self.lookupAndTraverse.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::LookupAndTraverseRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn chainUpdateEdge(
            &self,
            arg_req: &crate::types::UpdateEdgeRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::UpdateResponse, crate::errors::graph_storage_service::ChainUpdateEdgeError>> {
            let mut closure = self.chainUpdateEdge.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::UpdateEdgeRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn chainAddEdges(
            &self,
            arg_req: &crate::types::AddEdgesRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::ChainAddEdgesError>> {
            let mut closure = self.chainAddEdges.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::AddEdgesRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
    }


    pub struct StorageAdminService<'mock> {
        pub transLeader: r#impl::storage_admin_service::transLeader<'mock>,
        pub addPart: r#impl::storage_admin_service::addPart<'mock>,
        pub addLearner: r#impl::storage_admin_service::addLearner<'mock>,
        pub removePart: r#impl::storage_admin_service::removePart<'mock>,
        pub memberChange: r#impl::storage_admin_service::memberChange<'mock>,
        pub waitingForCatchUpData: r#impl::storage_admin_service::waitingForCatchUpData<'mock>,
        pub createCheckpoint: r#impl::storage_admin_service::createCheckpoint<'mock>,
        pub dropCheckpoint: r#impl::storage_admin_service::dropCheckpoint<'mock>,
        pub blockingWrites: r#impl::storage_admin_service::blockingWrites<'mock>,
        pub rebuildTagIndex: r#impl::storage_admin_service::rebuildTagIndex<'mock>,
        pub rebuildEdgeIndex: r#impl::storage_admin_service::rebuildEdgeIndex<'mock>,
        pub getLeaderParts: r#impl::storage_admin_service::getLeaderParts<'mock>,
        pub checkPeers: r#impl::storage_admin_service::checkPeers<'mock>,
        pub addAdminTask: r#impl::storage_admin_service::addAdminTask<'mock>,
        pub stopAdminTask: r#impl::storage_admin_service::stopAdminTask<'mock>,
        pub listClusterInfo: r#impl::storage_admin_service::listClusterInfo<'mock>,
        _marker: ::std::marker::PhantomData<&'mock ()>,
    }

    impl dyn super::client::StorageAdminService {
        pub fn mock<'mock>() -> StorageAdminService<'mock> {
            StorageAdminService {
                transLeader: r#impl::storage_admin_service::transLeader::unimplemented(),
                addPart: r#impl::storage_admin_service::addPart::unimplemented(),
                addLearner: r#impl::storage_admin_service::addLearner::unimplemented(),
                removePart: r#impl::storage_admin_service::removePart::unimplemented(),
                memberChange: r#impl::storage_admin_service::memberChange::unimplemented(),
                waitingForCatchUpData: r#impl::storage_admin_service::waitingForCatchUpData::unimplemented(),
                createCheckpoint: r#impl::storage_admin_service::createCheckpoint::unimplemented(),
                dropCheckpoint: r#impl::storage_admin_service::dropCheckpoint::unimplemented(),
                blockingWrites: r#impl::storage_admin_service::blockingWrites::unimplemented(),
                rebuildTagIndex: r#impl::storage_admin_service::rebuildTagIndex::unimplemented(),
                rebuildEdgeIndex: r#impl::storage_admin_service::rebuildEdgeIndex::unimplemented(),
                getLeaderParts: r#impl::storage_admin_service::getLeaderParts::unimplemented(),
                checkPeers: r#impl::storage_admin_service::checkPeers::unimplemented(),
                addAdminTask: r#impl::storage_admin_service::addAdminTask::unimplemented(),
                stopAdminTask: r#impl::storage_admin_service::stopAdminTask::unimplemented(),
                listClusterInfo: r#impl::storage_admin_service::listClusterInfo::unimplemented(),
                _marker: ::std::marker::PhantomData,
            }
        }
    }

    impl<'mock> super::client::StorageAdminService for StorageAdminService<'mock> {
        fn transLeader(
            &self,
            arg_req: &crate::types::TransLeaderReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::TransLeaderError>> {
            let mut closure = self.transLeader.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::TransLeaderReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn addPart(
            &self,
            arg_req: &crate::types::AddPartReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::AddPartError>> {
            let mut closure = self.addPart.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::AddPartReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn addLearner(
            &self,
            arg_req: &crate::types::AddLearnerReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::AddLearnerError>> {
            let mut closure = self.addLearner.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::AddLearnerReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn removePart(
            &self,
            arg_req: &crate::types::RemovePartReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::RemovePartError>> {
            let mut closure = self.removePart.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::RemovePartReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn memberChange(
            &self,
            arg_req: &crate::types::MemberChangeReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::MemberChangeError>> {
            let mut closure = self.memberChange.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::MemberChangeReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn waitingForCatchUpData(
            &self,
            arg_req: &crate::types::CatchUpDataReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::WaitingForCatchUpDataError>> {
            let mut closure = self.waitingForCatchUpData.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::CatchUpDataReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn createCheckpoint(
            &self,
            arg_req: &crate::types::CreateCPRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::CreateCPResp, crate::errors::storage_admin_service::CreateCheckpointError>> {
            let mut closure = self.createCheckpoint.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::CreateCPRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn dropCheckpoint(
            &self,
            arg_req: &crate::types::DropCPRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::DropCheckpointError>> {
            let mut closure = self.dropCheckpoint.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::DropCPRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn blockingWrites(
            &self,
            arg_req: &crate::types::BlockingSignRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::BlockingWritesError>> {
            let mut closure = self.blockingWrites.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::BlockingSignRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn rebuildTagIndex(
            &self,
            arg_req: &crate::types::RebuildIndexRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::RebuildTagIndexError>> {
            let mut closure = self.rebuildTagIndex.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::RebuildIndexRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn rebuildEdgeIndex(
            &self,
            arg_req: &crate::types::RebuildIndexRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::RebuildEdgeIndexError>> {
            let mut closure = self.rebuildEdgeIndex.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::RebuildIndexRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn getLeaderParts(
            &self,
            arg_req: &crate::types::GetLeaderReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::GetLeaderPartsResp, crate::errors::storage_admin_service::GetLeaderPartsError>> {
            let mut closure = self.getLeaderParts.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GetLeaderReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn checkPeers(
            &self,
            arg_req: &crate::types::CheckPeersReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::CheckPeersError>> {
            let mut closure = self.checkPeers.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::CheckPeersReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn addAdminTask(
            &self,
            arg_req: &crate::types::AddAdminTaskRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::AddAdminTaskError>> {
            let mut closure = self.addAdminTask.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::AddAdminTaskRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn stopAdminTask(
            &self,
            arg_req: &crate::types::StopAdminTaskRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::StopAdminTaskError>> {
            let mut closure = self.stopAdminTask.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::StopAdminTaskRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listClusterInfo(
            &self,
            arg_req: &crate::types::ListClusterInfoReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ListClusterInfoResp, crate::errors::storage_admin_service::ListClusterInfoError>> {
            let mut closure = self.listClusterInfo.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ListClusterInfoReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
    }


    pub struct GeneralStorageService<'mock> {
        pub get: r#impl::general_storage_service::get<'mock>,
        pub put: r#impl::general_storage_service::put<'mock>,
        pub remove: r#impl::general_storage_service::remove<'mock>,
        _marker: ::std::marker::PhantomData<&'mock ()>,
    }

    impl dyn super::client::GeneralStorageService {
        pub fn mock<'mock>() -> GeneralStorageService<'mock> {
            GeneralStorageService {
                get: r#impl::general_storage_service::get::unimplemented(),
                put: r#impl::general_storage_service::put::unimplemented(),
                remove: r#impl::general_storage_service::remove::unimplemented(),
                _marker: ::std::marker::PhantomData,
            }
        }
    }

    impl<'mock> super::client::GeneralStorageService for GeneralStorageService<'mock> {
        fn get(
            &self,
            arg_req: &crate::types::KVGetRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::KVGetResponse, crate::errors::general_storage_service::GetError>> {
            let mut closure = self.get.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::KVGetRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn put(
            &self,
            arg_req: &crate::types::KVPutRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::general_storage_service::PutError>> {
            let mut closure = self.put.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::KVPutRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn remove(
            &self,
            arg_req: &crate::types::KVRemoveRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::general_storage_service::RemoveError>> {
            let mut closure = self.remove.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::KVRemoveRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
    }


    pub struct InternalStorageService<'mock> {
        pub chainAddEdges: r#impl::internal_storage_service::chainAddEdges<'mock>,
        pub chainUpdateEdge: r#impl::internal_storage_service::chainUpdateEdge<'mock>,
        _marker: ::std::marker::PhantomData<&'mock ()>,
    }

    impl dyn super::client::InternalStorageService {
        pub fn mock<'mock>() -> InternalStorageService<'mock> {
            InternalStorageService {
                chainAddEdges: r#impl::internal_storage_service::chainAddEdges::unimplemented(),
                chainUpdateEdge: r#impl::internal_storage_service::chainUpdateEdge::unimplemented(),
                _marker: ::std::marker::PhantomData,
            }
        }
    }

    impl<'mock> super::client::InternalStorageService for InternalStorageService<'mock> {
        fn chainAddEdges(
            &self,
            arg_req: &crate::types::ChainAddEdgesRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::ExecResponse, crate::errors::internal_storage_service::ChainAddEdgesError>> {
            let mut closure = self.chainAddEdges.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ChainAddEdgesRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn chainUpdateEdge(
            &self,
            arg_req: &crate::types::ChainUpdateEdgeRequest,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::types::UpdateResponse, crate::errors::internal_storage_service::ChainUpdateEdgeError>> {
            let mut closure = self.chainUpdateEdge.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::ChainUpdateEdgeRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
    }

    mod r#impl {
        pub mod graph_storage_service {

            pub struct getNeighbors<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GetNeighborsRequest) -> ::std::result::Result<
                        crate::types::GetNeighborsResponse,
                        crate::errors::graph_storage_service::GetNeighborsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> getNeighbors<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GetNeighborsRequest| panic!(
                            "{}::{} is not mocked",
                            "GraphStorageService",
                            "getNeighbors",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::GetNeighborsResponse) {
                    self.mock(move |_: crate::types::GetNeighborsRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetNeighborsRequest) -> crate::types::GetNeighborsResponse + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetNeighborsRequest) -> ::std::result::Result<crate::types::GetNeighborsResponse, crate::errors::graph_storage_service::GetNeighborsError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::graph_storage_service::GetNeighborsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GetNeighborsRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getProps<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GetPropRequest) -> ::std::result::Result<
                        crate::types::GetPropResponse,
                        crate::errors::graph_storage_service::GetPropsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> getProps<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GetPropRequest| panic!(
                            "{}::{} is not mocked",
                            "GraphStorageService",
                            "getProps",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::GetPropResponse) {
                    self.mock(move |_: crate::types::GetPropRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetPropRequest) -> crate::types::GetPropResponse + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetPropRequest) -> ::std::result::Result<crate::types::GetPropResponse, crate::errors::graph_storage_service::GetPropsError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::graph_storage_service::GetPropsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GetPropRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct addVertices<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::AddVerticesRequest) -> ::std::result::Result<
                        crate::types::ExecResponse,
                        crate::errors::graph_storage_service::AddVerticesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> addVertices<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::AddVerticesRequest| panic!(
                            "{}::{} is not mocked",
                            "GraphStorageService",
                            "addVertices",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResponse) {
                    self.mock(move |_: crate::types::AddVerticesRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::AddVerticesRequest) -> crate::types::ExecResponse + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::AddVerticesRequest) -> ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::AddVerticesError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::graph_storage_service::AddVerticesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::AddVerticesRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct addEdges<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::AddEdgesRequest) -> ::std::result::Result<
                        crate::types::ExecResponse,
                        crate::errors::graph_storage_service::AddEdgesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> addEdges<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::AddEdgesRequest| panic!(
                            "{}::{} is not mocked",
                            "GraphStorageService",
                            "addEdges",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResponse) {
                    self.mock(move |_: crate::types::AddEdgesRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::AddEdgesRequest) -> crate::types::ExecResponse + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::AddEdgesRequest) -> ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::AddEdgesError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::graph_storage_service::AddEdgesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::AddEdgesRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct deleteEdges<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::DeleteEdgesRequest) -> ::std::result::Result<
                        crate::types::ExecResponse,
                        crate::errors::graph_storage_service::DeleteEdgesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> deleteEdges<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::DeleteEdgesRequest| panic!(
                            "{}::{} is not mocked",
                            "GraphStorageService",
                            "deleteEdges",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResponse) {
                    self.mock(move |_: crate::types::DeleteEdgesRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::DeleteEdgesRequest) -> crate::types::ExecResponse + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::DeleteEdgesRequest) -> ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::DeleteEdgesError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::graph_storage_service::DeleteEdgesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::DeleteEdgesRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct deleteVertices<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::DeleteVerticesRequest) -> ::std::result::Result<
                        crate::types::ExecResponse,
                        crate::errors::graph_storage_service::DeleteVerticesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> deleteVertices<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::DeleteVerticesRequest| panic!(
                            "{}::{} is not mocked",
                            "GraphStorageService",
                            "deleteVertices",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResponse) {
                    self.mock(move |_: crate::types::DeleteVerticesRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::DeleteVerticesRequest) -> crate::types::ExecResponse + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::DeleteVerticesRequest) -> ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::DeleteVerticesError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::graph_storage_service::DeleteVerticesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::DeleteVerticesRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct deleteTags<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::DeleteTagsRequest) -> ::std::result::Result<
                        crate::types::ExecResponse,
                        crate::errors::graph_storage_service::DeleteTagsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> deleteTags<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::DeleteTagsRequest| panic!(
                            "{}::{} is not mocked",
                            "GraphStorageService",
                            "deleteTags",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResponse) {
                    self.mock(move |_: crate::types::DeleteTagsRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::DeleteTagsRequest) -> crate::types::ExecResponse + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::DeleteTagsRequest) -> ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::DeleteTagsError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::graph_storage_service::DeleteTagsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::DeleteTagsRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct updateVertex<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::UpdateVertexRequest) -> ::std::result::Result<
                        crate::types::UpdateResponse,
                        crate::errors::graph_storage_service::UpdateVertexError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> updateVertex<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::UpdateVertexRequest| panic!(
                            "{}::{} is not mocked",
                            "GraphStorageService",
                            "updateVertex",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::UpdateResponse) {
                    self.mock(move |_: crate::types::UpdateVertexRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::UpdateVertexRequest) -> crate::types::UpdateResponse + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::UpdateVertexRequest) -> ::std::result::Result<crate::types::UpdateResponse, crate::errors::graph_storage_service::UpdateVertexError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::graph_storage_service::UpdateVertexError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::UpdateVertexRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct updateEdge<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::UpdateEdgeRequest) -> ::std::result::Result<
                        crate::types::UpdateResponse,
                        crate::errors::graph_storage_service::UpdateEdgeError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> updateEdge<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::UpdateEdgeRequest| panic!(
                            "{}::{} is not mocked",
                            "GraphStorageService",
                            "updateEdge",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::UpdateResponse) {
                    self.mock(move |_: crate::types::UpdateEdgeRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::UpdateEdgeRequest) -> crate::types::UpdateResponse + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::UpdateEdgeRequest) -> ::std::result::Result<crate::types::UpdateResponse, crate::errors::graph_storage_service::UpdateEdgeError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::graph_storage_service::UpdateEdgeError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::UpdateEdgeRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct scanVertex<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ScanVertexRequest) -> ::std::result::Result<
                        crate::types::ScanVertexResponse,
                        crate::errors::graph_storage_service::ScanVertexError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> scanVertex<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ScanVertexRequest| panic!(
                            "{}::{} is not mocked",
                            "GraphStorageService",
                            "scanVertex",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ScanVertexResponse) {
                    self.mock(move |_: crate::types::ScanVertexRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ScanVertexRequest) -> crate::types::ScanVertexResponse + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ScanVertexRequest) -> ::std::result::Result<crate::types::ScanVertexResponse, crate::errors::graph_storage_service::ScanVertexError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::graph_storage_service::ScanVertexError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ScanVertexRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct scanEdge<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ScanEdgeRequest) -> ::std::result::Result<
                        crate::types::ScanEdgeResponse,
                        crate::errors::graph_storage_service::ScanEdgeError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> scanEdge<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ScanEdgeRequest| panic!(
                            "{}::{} is not mocked",
                            "GraphStorageService",
                            "scanEdge",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ScanEdgeResponse) {
                    self.mock(move |_: crate::types::ScanEdgeRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ScanEdgeRequest) -> crate::types::ScanEdgeResponse + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ScanEdgeRequest) -> ::std::result::Result<crate::types::ScanEdgeResponse, crate::errors::graph_storage_service::ScanEdgeError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::graph_storage_service::ScanEdgeError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ScanEdgeRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getUUID<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GetUUIDReq) -> ::std::result::Result<
                        crate::types::GetUUIDResp,
                        crate::errors::graph_storage_service::GetUUIDError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> getUUID<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GetUUIDReq| panic!(
                            "{}::{} is not mocked",
                            "GraphStorageService",
                            "getUUID",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::GetUUIDResp) {
                    self.mock(move |_: crate::types::GetUUIDReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetUUIDReq) -> crate::types::GetUUIDResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetUUIDReq) -> ::std::result::Result<crate::types::GetUUIDResp, crate::errors::graph_storage_service::GetUUIDError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::graph_storage_service::GetUUIDError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GetUUIDReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct lookupIndex<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::LookupIndexRequest) -> ::std::result::Result<
                        crate::types::LookupIndexResp,
                        crate::errors::graph_storage_service::LookupIndexError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> lookupIndex<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::LookupIndexRequest| panic!(
                            "{}::{} is not mocked",
                            "GraphStorageService",
                            "lookupIndex",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::LookupIndexResp) {
                    self.mock(move |_: crate::types::LookupIndexRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::LookupIndexRequest) -> crate::types::LookupIndexResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::LookupIndexRequest) -> ::std::result::Result<crate::types::LookupIndexResp, crate::errors::graph_storage_service::LookupIndexError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::graph_storage_service::LookupIndexError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::LookupIndexRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct lookupAndTraverse<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::LookupAndTraverseRequest) -> ::std::result::Result<
                        crate::types::GetNeighborsResponse,
                        crate::errors::graph_storage_service::LookupAndTraverseError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> lookupAndTraverse<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::LookupAndTraverseRequest| panic!(
                            "{}::{} is not mocked",
                            "GraphStorageService",
                            "lookupAndTraverse",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::GetNeighborsResponse) {
                    self.mock(move |_: crate::types::LookupAndTraverseRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::LookupAndTraverseRequest) -> crate::types::GetNeighborsResponse + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::LookupAndTraverseRequest) -> ::std::result::Result<crate::types::GetNeighborsResponse, crate::errors::graph_storage_service::LookupAndTraverseError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::graph_storage_service::LookupAndTraverseError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::LookupAndTraverseRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct chainUpdateEdge<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::UpdateEdgeRequest) -> ::std::result::Result<
                        crate::types::UpdateResponse,
                        crate::errors::graph_storage_service::ChainUpdateEdgeError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> chainUpdateEdge<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::UpdateEdgeRequest| panic!(
                            "{}::{} is not mocked",
                            "GraphStorageService",
                            "chainUpdateEdge",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::UpdateResponse) {
                    self.mock(move |_: crate::types::UpdateEdgeRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::UpdateEdgeRequest) -> crate::types::UpdateResponse + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::UpdateEdgeRequest) -> ::std::result::Result<crate::types::UpdateResponse, crate::errors::graph_storage_service::ChainUpdateEdgeError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::graph_storage_service::ChainUpdateEdgeError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::UpdateEdgeRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct chainAddEdges<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::AddEdgesRequest) -> ::std::result::Result<
                        crate::types::ExecResponse,
                        crate::errors::graph_storage_service::ChainAddEdgesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> chainAddEdges<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::AddEdgesRequest| panic!(
                            "{}::{} is not mocked",
                            "GraphStorageService",
                            "chainAddEdges",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResponse) {
                    self.mock(move |_: crate::types::AddEdgesRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::AddEdgesRequest) -> crate::types::ExecResponse + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::AddEdgesRequest) -> ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::ChainAddEdgesError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::graph_storage_service::ChainAddEdgesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::AddEdgesRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }
        }
        pub mod storage_admin_service {

            pub struct transLeader<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::TransLeaderReq) -> ::std::result::Result<
                        crate::types::AdminExecResp,
                        crate::errors::storage_admin_service::TransLeaderError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> transLeader<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::TransLeaderReq| panic!(
                            "{}::{} is not mocked",
                            "StorageAdminService",
                            "transLeader",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::AdminExecResp) {
                    self.mock(move |_: crate::types::TransLeaderReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::TransLeaderReq) -> crate::types::AdminExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::TransLeaderReq) -> ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::TransLeaderError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_admin_service::TransLeaderError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::TransLeaderReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct addPart<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::AddPartReq) -> ::std::result::Result<
                        crate::types::AdminExecResp,
                        crate::errors::storage_admin_service::AddPartError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> addPart<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::AddPartReq| panic!(
                            "{}::{} is not mocked",
                            "StorageAdminService",
                            "addPart",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::AdminExecResp) {
                    self.mock(move |_: crate::types::AddPartReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::AddPartReq) -> crate::types::AdminExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::AddPartReq) -> ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::AddPartError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_admin_service::AddPartError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::AddPartReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct addLearner<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::AddLearnerReq) -> ::std::result::Result<
                        crate::types::AdminExecResp,
                        crate::errors::storage_admin_service::AddLearnerError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> addLearner<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::AddLearnerReq| panic!(
                            "{}::{} is not mocked",
                            "StorageAdminService",
                            "addLearner",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::AdminExecResp) {
                    self.mock(move |_: crate::types::AddLearnerReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::AddLearnerReq) -> crate::types::AdminExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::AddLearnerReq) -> ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::AddLearnerError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_admin_service::AddLearnerError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::AddLearnerReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct removePart<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::RemovePartReq) -> ::std::result::Result<
                        crate::types::AdminExecResp,
                        crate::errors::storage_admin_service::RemovePartError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> removePart<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::RemovePartReq| panic!(
                            "{}::{} is not mocked",
                            "StorageAdminService",
                            "removePart",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::AdminExecResp) {
                    self.mock(move |_: crate::types::RemovePartReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::RemovePartReq) -> crate::types::AdminExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::RemovePartReq) -> ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::RemovePartError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_admin_service::RemovePartError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::RemovePartReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct memberChange<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::MemberChangeReq) -> ::std::result::Result<
                        crate::types::AdminExecResp,
                        crate::errors::storage_admin_service::MemberChangeError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> memberChange<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::MemberChangeReq| panic!(
                            "{}::{} is not mocked",
                            "StorageAdminService",
                            "memberChange",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::AdminExecResp) {
                    self.mock(move |_: crate::types::MemberChangeReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::MemberChangeReq) -> crate::types::AdminExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::MemberChangeReq) -> ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::MemberChangeError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_admin_service::MemberChangeError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::MemberChangeReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct waitingForCatchUpData<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::CatchUpDataReq) -> ::std::result::Result<
                        crate::types::AdminExecResp,
                        crate::errors::storage_admin_service::WaitingForCatchUpDataError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> waitingForCatchUpData<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::CatchUpDataReq| panic!(
                            "{}::{} is not mocked",
                            "StorageAdminService",
                            "waitingForCatchUpData",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::AdminExecResp) {
                    self.mock(move |_: crate::types::CatchUpDataReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::CatchUpDataReq) -> crate::types::AdminExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::CatchUpDataReq) -> ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::WaitingForCatchUpDataError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_admin_service::WaitingForCatchUpDataError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::CatchUpDataReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct createCheckpoint<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::CreateCPRequest) -> ::std::result::Result<
                        crate::types::CreateCPResp,
                        crate::errors::storage_admin_service::CreateCheckpointError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> createCheckpoint<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::CreateCPRequest| panic!(
                            "{}::{} is not mocked",
                            "StorageAdminService",
                            "createCheckpoint",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::CreateCPResp) {
                    self.mock(move |_: crate::types::CreateCPRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateCPRequest) -> crate::types::CreateCPResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateCPRequest) -> ::std::result::Result<crate::types::CreateCPResp, crate::errors::storage_admin_service::CreateCheckpointError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_admin_service::CreateCheckpointError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::CreateCPRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct dropCheckpoint<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::DropCPRequest) -> ::std::result::Result<
                        crate::types::AdminExecResp,
                        crate::errors::storage_admin_service::DropCheckpointError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> dropCheckpoint<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::DropCPRequest| panic!(
                            "{}::{} is not mocked",
                            "StorageAdminService",
                            "dropCheckpoint",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::AdminExecResp) {
                    self.mock(move |_: crate::types::DropCPRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropCPRequest) -> crate::types::AdminExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropCPRequest) -> ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::DropCheckpointError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_admin_service::DropCheckpointError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::DropCPRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct blockingWrites<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::BlockingSignRequest) -> ::std::result::Result<
                        crate::types::AdminExecResp,
                        crate::errors::storage_admin_service::BlockingWritesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> blockingWrites<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::BlockingSignRequest| panic!(
                            "{}::{} is not mocked",
                            "StorageAdminService",
                            "blockingWrites",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::AdminExecResp) {
                    self.mock(move |_: crate::types::BlockingSignRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::BlockingSignRequest) -> crate::types::AdminExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::BlockingSignRequest) -> ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::BlockingWritesError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_admin_service::BlockingWritesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::BlockingSignRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct rebuildTagIndex<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::RebuildIndexRequest) -> ::std::result::Result<
                        crate::types::AdminExecResp,
                        crate::errors::storage_admin_service::RebuildTagIndexError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> rebuildTagIndex<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::RebuildIndexRequest| panic!(
                            "{}::{} is not mocked",
                            "StorageAdminService",
                            "rebuildTagIndex",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::AdminExecResp) {
                    self.mock(move |_: crate::types::RebuildIndexRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::RebuildIndexRequest) -> crate::types::AdminExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::RebuildIndexRequest) -> ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::RebuildTagIndexError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_admin_service::RebuildTagIndexError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::RebuildIndexRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct rebuildEdgeIndex<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::RebuildIndexRequest) -> ::std::result::Result<
                        crate::types::AdminExecResp,
                        crate::errors::storage_admin_service::RebuildEdgeIndexError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> rebuildEdgeIndex<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::RebuildIndexRequest| panic!(
                            "{}::{} is not mocked",
                            "StorageAdminService",
                            "rebuildEdgeIndex",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::AdminExecResp) {
                    self.mock(move |_: crate::types::RebuildIndexRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::RebuildIndexRequest) -> crate::types::AdminExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::RebuildIndexRequest) -> ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::RebuildEdgeIndexError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_admin_service::RebuildEdgeIndexError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::RebuildIndexRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getLeaderParts<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GetLeaderReq) -> ::std::result::Result<
                        crate::types::GetLeaderPartsResp,
                        crate::errors::storage_admin_service::GetLeaderPartsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> getLeaderParts<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GetLeaderReq| panic!(
                            "{}::{} is not mocked",
                            "StorageAdminService",
                            "getLeaderParts",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::GetLeaderPartsResp) {
                    self.mock(move |_: crate::types::GetLeaderReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetLeaderReq) -> crate::types::GetLeaderPartsResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetLeaderReq) -> ::std::result::Result<crate::types::GetLeaderPartsResp, crate::errors::storage_admin_service::GetLeaderPartsError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_admin_service::GetLeaderPartsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GetLeaderReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct checkPeers<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::CheckPeersReq) -> ::std::result::Result<
                        crate::types::AdminExecResp,
                        crate::errors::storage_admin_service::CheckPeersError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> checkPeers<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::CheckPeersReq| panic!(
                            "{}::{} is not mocked",
                            "StorageAdminService",
                            "checkPeers",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::AdminExecResp) {
                    self.mock(move |_: crate::types::CheckPeersReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::CheckPeersReq) -> crate::types::AdminExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::CheckPeersReq) -> ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::CheckPeersError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_admin_service::CheckPeersError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::CheckPeersReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct addAdminTask<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::AddAdminTaskRequest) -> ::std::result::Result<
                        crate::types::AdminExecResp,
                        crate::errors::storage_admin_service::AddAdminTaskError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> addAdminTask<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::AddAdminTaskRequest| panic!(
                            "{}::{} is not mocked",
                            "StorageAdminService",
                            "addAdminTask",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::AdminExecResp) {
                    self.mock(move |_: crate::types::AddAdminTaskRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::AddAdminTaskRequest) -> crate::types::AdminExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::AddAdminTaskRequest) -> ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::AddAdminTaskError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_admin_service::AddAdminTaskError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::AddAdminTaskRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct stopAdminTask<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::StopAdminTaskRequest) -> ::std::result::Result<
                        crate::types::AdminExecResp,
                        crate::errors::storage_admin_service::StopAdminTaskError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> stopAdminTask<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::StopAdminTaskRequest| panic!(
                            "{}::{} is not mocked",
                            "StorageAdminService",
                            "stopAdminTask",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::AdminExecResp) {
                    self.mock(move |_: crate::types::StopAdminTaskRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::StopAdminTaskRequest) -> crate::types::AdminExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::StopAdminTaskRequest) -> ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::StopAdminTaskError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_admin_service::StopAdminTaskError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::StopAdminTaskRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listClusterInfo<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ListClusterInfoReq) -> ::std::result::Result<
                        crate::types::ListClusterInfoResp,
                        crate::errors::storage_admin_service::ListClusterInfoError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> listClusterInfo<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ListClusterInfoReq| panic!(
                            "{}::{} is not mocked",
                            "StorageAdminService",
                            "listClusterInfo",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ListClusterInfoResp) {
                    self.mock(move |_: crate::types::ListClusterInfoReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListClusterInfoReq) -> crate::types::ListClusterInfoResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ListClusterInfoReq) -> ::std::result::Result<crate::types::ListClusterInfoResp, crate::errors::storage_admin_service::ListClusterInfoError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_admin_service::ListClusterInfoError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ListClusterInfoReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }
        }
        pub mod general_storage_service {

            pub struct get<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::KVGetRequest) -> ::std::result::Result<
                        crate::types::KVGetResponse,
                        crate::errors::general_storage_service::GetError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> get<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::KVGetRequest| panic!(
                            "{}::{} is not mocked",
                            "GeneralStorageService",
                            "get",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::KVGetResponse) {
                    self.mock(move |_: crate::types::KVGetRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::KVGetRequest) -> crate::types::KVGetResponse + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::KVGetRequest) -> ::std::result::Result<crate::types::KVGetResponse, crate::errors::general_storage_service::GetError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::general_storage_service::GetError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::KVGetRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct put<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::KVPutRequest) -> ::std::result::Result<
                        crate::types::ExecResponse,
                        crate::errors::general_storage_service::PutError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> put<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::KVPutRequest| panic!(
                            "{}::{} is not mocked",
                            "GeneralStorageService",
                            "put",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResponse) {
                    self.mock(move |_: crate::types::KVPutRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::KVPutRequest) -> crate::types::ExecResponse + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::KVPutRequest) -> ::std::result::Result<crate::types::ExecResponse, crate::errors::general_storage_service::PutError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::general_storage_service::PutError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::KVPutRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct remove<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::KVRemoveRequest) -> ::std::result::Result<
                        crate::types::ExecResponse,
                        crate::errors::general_storage_service::RemoveError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> remove<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::KVRemoveRequest| panic!(
                            "{}::{} is not mocked",
                            "GeneralStorageService",
                            "remove",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResponse) {
                    self.mock(move |_: crate::types::KVRemoveRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::KVRemoveRequest) -> crate::types::ExecResponse + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::KVRemoveRequest) -> ::std::result::Result<crate::types::ExecResponse, crate::errors::general_storage_service::RemoveError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::general_storage_service::RemoveError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::KVRemoveRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }
        }
        pub mod internal_storage_service {

            pub struct chainAddEdges<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ChainAddEdgesRequest) -> ::std::result::Result<
                        crate::types::ExecResponse,
                        crate::errors::internal_storage_service::ChainAddEdgesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> chainAddEdges<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ChainAddEdgesRequest| panic!(
                            "{}::{} is not mocked",
                            "InternalStorageService",
                            "chainAddEdges",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResponse) {
                    self.mock(move |_: crate::types::ChainAddEdgesRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ChainAddEdgesRequest) -> crate::types::ExecResponse + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ChainAddEdgesRequest) -> ::std::result::Result<crate::types::ExecResponse, crate::errors::internal_storage_service::ChainAddEdgesError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::internal_storage_service::ChainAddEdgesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ChainAddEdgesRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct chainUpdateEdge<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::ChainUpdateEdgeRequest) -> ::std::result::Result<
                        crate::types::UpdateResponse,
                        crate::errors::internal_storage_service::ChainUpdateEdgeError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> chainUpdateEdge<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::ChainUpdateEdgeRequest| panic!(
                            "{}::{} is not mocked",
                            "InternalStorageService",
                            "chainUpdateEdge",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::UpdateResponse) {
                    self.mock(move |_: crate::types::ChainUpdateEdgeRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::ChainUpdateEdgeRequest) -> crate::types::UpdateResponse + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::ChainUpdateEdgeRequest) -> ::std::result::Result<crate::types::UpdateResponse, crate::errors::internal_storage_service::ChainUpdateEdgeError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::internal_storage_service::ChainUpdateEdgeError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::ChainUpdateEdgeRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }
        }
    }
}

/// Error return types.
pub mod errors {
    /// Errors for GraphStorageService functions.
    pub mod graph_storage_service {

        pub type GetNeighborsError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::graph_storage_service::GetNeighborsExn> for
            ::std::result::Result<crate::types::GetNeighborsResponse, GetNeighborsError>
        {
            fn from(e: crate::services::graph_storage_service::GetNeighborsExn) -> Self {
                match e {
                    crate::services::graph_storage_service::GetNeighborsExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::graph_storage_service::GetNeighborsExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetNeighborsError::ApplicationException(aexn)),
                }
            }
        }

        pub type GetPropsError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::graph_storage_service::GetPropsExn> for
            ::std::result::Result<crate::types::GetPropResponse, GetPropsError>
        {
            fn from(e: crate::services::graph_storage_service::GetPropsExn) -> Self {
                match e {
                    crate::services::graph_storage_service::GetPropsExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::graph_storage_service::GetPropsExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetPropsError::ApplicationException(aexn)),
                }
            }
        }

        pub type AddVerticesError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::graph_storage_service::AddVerticesExn> for
            ::std::result::Result<crate::types::ExecResponse, AddVerticesError>
        {
            fn from(e: crate::services::graph_storage_service::AddVerticesExn) -> Self {
                match e {
                    crate::services::graph_storage_service::AddVerticesExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::graph_storage_service::AddVerticesExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(AddVerticesError::ApplicationException(aexn)),
                }
            }
        }

        pub type AddEdgesError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::graph_storage_service::AddEdgesExn> for
            ::std::result::Result<crate::types::ExecResponse, AddEdgesError>
        {
            fn from(e: crate::services::graph_storage_service::AddEdgesExn) -> Self {
                match e {
                    crate::services::graph_storage_service::AddEdgesExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::graph_storage_service::AddEdgesExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(AddEdgesError::ApplicationException(aexn)),
                }
            }
        }

        pub type DeleteEdgesError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::graph_storage_service::DeleteEdgesExn> for
            ::std::result::Result<crate::types::ExecResponse, DeleteEdgesError>
        {
            fn from(e: crate::services::graph_storage_service::DeleteEdgesExn) -> Self {
                match e {
                    crate::services::graph_storage_service::DeleteEdgesExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::graph_storage_service::DeleteEdgesExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(DeleteEdgesError::ApplicationException(aexn)),
                }
            }
        }

        pub type DeleteVerticesError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::graph_storage_service::DeleteVerticesExn> for
            ::std::result::Result<crate::types::ExecResponse, DeleteVerticesError>
        {
            fn from(e: crate::services::graph_storage_service::DeleteVerticesExn) -> Self {
                match e {
                    crate::services::graph_storage_service::DeleteVerticesExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::graph_storage_service::DeleteVerticesExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(DeleteVerticesError::ApplicationException(aexn)),
                }
            }
        }

        pub type DeleteTagsError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::graph_storage_service::DeleteTagsExn> for
            ::std::result::Result<crate::types::ExecResponse, DeleteTagsError>
        {
            fn from(e: crate::services::graph_storage_service::DeleteTagsExn) -> Self {
                match e {
                    crate::services::graph_storage_service::DeleteTagsExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::graph_storage_service::DeleteTagsExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(DeleteTagsError::ApplicationException(aexn)),
                }
            }
        }

        pub type UpdateVertexError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::graph_storage_service::UpdateVertexExn> for
            ::std::result::Result<crate::types::UpdateResponse, UpdateVertexError>
        {
            fn from(e: crate::services::graph_storage_service::UpdateVertexExn) -> Self {
                match e {
                    crate::services::graph_storage_service::UpdateVertexExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::graph_storage_service::UpdateVertexExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(UpdateVertexError::ApplicationException(aexn)),
                }
            }
        }

        pub type UpdateEdgeError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::graph_storage_service::UpdateEdgeExn> for
            ::std::result::Result<crate::types::UpdateResponse, UpdateEdgeError>
        {
            fn from(e: crate::services::graph_storage_service::UpdateEdgeExn) -> Self {
                match e {
                    crate::services::graph_storage_service::UpdateEdgeExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::graph_storage_service::UpdateEdgeExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(UpdateEdgeError::ApplicationException(aexn)),
                }
            }
        }

        pub type ScanVertexError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::graph_storage_service::ScanVertexExn> for
            ::std::result::Result<crate::types::ScanVertexResponse, ScanVertexError>
        {
            fn from(e: crate::services::graph_storage_service::ScanVertexExn) -> Self {
                match e {
                    crate::services::graph_storage_service::ScanVertexExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::graph_storage_service::ScanVertexExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ScanVertexError::ApplicationException(aexn)),
                }
            }
        }

        pub type ScanEdgeError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::graph_storage_service::ScanEdgeExn> for
            ::std::result::Result<crate::types::ScanEdgeResponse, ScanEdgeError>
        {
            fn from(e: crate::services::graph_storage_service::ScanEdgeExn) -> Self {
                match e {
                    crate::services::graph_storage_service::ScanEdgeExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::graph_storage_service::ScanEdgeExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ScanEdgeError::ApplicationException(aexn)),
                }
            }
        }

        pub type GetUUIDError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::graph_storage_service::GetUUIDExn> for
            ::std::result::Result<crate::types::GetUUIDResp, GetUUIDError>
        {
            fn from(e: crate::services::graph_storage_service::GetUUIDExn) -> Self {
                match e {
                    crate::services::graph_storage_service::GetUUIDExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::graph_storage_service::GetUUIDExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetUUIDError::ApplicationException(aexn)),
                }
            }
        }

        pub type LookupIndexError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::graph_storage_service::LookupIndexExn> for
            ::std::result::Result<crate::types::LookupIndexResp, LookupIndexError>
        {
            fn from(e: crate::services::graph_storage_service::LookupIndexExn) -> Self {
                match e {
                    crate::services::graph_storage_service::LookupIndexExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::graph_storage_service::LookupIndexExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(LookupIndexError::ApplicationException(aexn)),
                }
            }
        }

        pub type LookupAndTraverseError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::graph_storage_service::LookupAndTraverseExn> for
            ::std::result::Result<crate::types::GetNeighborsResponse, LookupAndTraverseError>
        {
            fn from(e: crate::services::graph_storage_service::LookupAndTraverseExn) -> Self {
                match e {
                    crate::services::graph_storage_service::LookupAndTraverseExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::graph_storage_service::LookupAndTraverseExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(LookupAndTraverseError::ApplicationException(aexn)),
                }
            }
        }

        pub type ChainUpdateEdgeError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::graph_storage_service::ChainUpdateEdgeExn> for
            ::std::result::Result<crate::types::UpdateResponse, ChainUpdateEdgeError>
        {
            fn from(e: crate::services::graph_storage_service::ChainUpdateEdgeExn) -> Self {
                match e {
                    crate::services::graph_storage_service::ChainUpdateEdgeExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::graph_storage_service::ChainUpdateEdgeExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ChainUpdateEdgeError::ApplicationException(aexn)),
                }
            }
        }

        pub type ChainAddEdgesError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::graph_storage_service::ChainAddEdgesExn> for
            ::std::result::Result<crate::types::ExecResponse, ChainAddEdgesError>
        {
            fn from(e: crate::services::graph_storage_service::ChainAddEdgesExn) -> Self {
                match e {
                    crate::services::graph_storage_service::ChainAddEdgesExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::graph_storage_service::ChainAddEdgesExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ChainAddEdgesError::ApplicationException(aexn)),
                }
            }
        }

    }

    /// Errors for StorageAdminService functions.
    pub mod storage_admin_service {

        pub type TransLeaderError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::storage_admin_service::TransLeaderExn> for
            ::std::result::Result<crate::types::AdminExecResp, TransLeaderError>
        {
            fn from(e: crate::services::storage_admin_service::TransLeaderExn) -> Self {
                match e {
                    crate::services::storage_admin_service::TransLeaderExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::storage_admin_service::TransLeaderExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(TransLeaderError::ApplicationException(aexn)),
                }
            }
        }

        pub type AddPartError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::storage_admin_service::AddPartExn> for
            ::std::result::Result<crate::types::AdminExecResp, AddPartError>
        {
            fn from(e: crate::services::storage_admin_service::AddPartExn) -> Self {
                match e {
                    crate::services::storage_admin_service::AddPartExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::storage_admin_service::AddPartExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(AddPartError::ApplicationException(aexn)),
                }
            }
        }

        pub type AddLearnerError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::storage_admin_service::AddLearnerExn> for
            ::std::result::Result<crate::types::AdminExecResp, AddLearnerError>
        {
            fn from(e: crate::services::storage_admin_service::AddLearnerExn) -> Self {
                match e {
                    crate::services::storage_admin_service::AddLearnerExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::storage_admin_service::AddLearnerExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(AddLearnerError::ApplicationException(aexn)),
                }
            }
        }

        pub type RemovePartError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::storage_admin_service::RemovePartExn> for
            ::std::result::Result<crate::types::AdminExecResp, RemovePartError>
        {
            fn from(e: crate::services::storage_admin_service::RemovePartExn) -> Self {
                match e {
                    crate::services::storage_admin_service::RemovePartExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::storage_admin_service::RemovePartExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(RemovePartError::ApplicationException(aexn)),
                }
            }
        }

        pub type MemberChangeError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::storage_admin_service::MemberChangeExn> for
            ::std::result::Result<crate::types::AdminExecResp, MemberChangeError>
        {
            fn from(e: crate::services::storage_admin_service::MemberChangeExn) -> Self {
                match e {
                    crate::services::storage_admin_service::MemberChangeExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::storage_admin_service::MemberChangeExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(MemberChangeError::ApplicationException(aexn)),
                }
            }
        }

        pub type WaitingForCatchUpDataError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::storage_admin_service::WaitingForCatchUpDataExn> for
            ::std::result::Result<crate::types::AdminExecResp, WaitingForCatchUpDataError>
        {
            fn from(e: crate::services::storage_admin_service::WaitingForCatchUpDataExn) -> Self {
                match e {
                    crate::services::storage_admin_service::WaitingForCatchUpDataExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::storage_admin_service::WaitingForCatchUpDataExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(WaitingForCatchUpDataError::ApplicationException(aexn)),
                }
            }
        }

        pub type CreateCheckpointError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::storage_admin_service::CreateCheckpointExn> for
            ::std::result::Result<crate::types::CreateCPResp, CreateCheckpointError>
        {
            fn from(e: crate::services::storage_admin_service::CreateCheckpointExn) -> Self {
                match e {
                    crate::services::storage_admin_service::CreateCheckpointExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::storage_admin_service::CreateCheckpointExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(CreateCheckpointError::ApplicationException(aexn)),
                }
            }
        }

        pub type DropCheckpointError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::storage_admin_service::DropCheckpointExn> for
            ::std::result::Result<crate::types::AdminExecResp, DropCheckpointError>
        {
            fn from(e: crate::services::storage_admin_service::DropCheckpointExn) -> Self {
                match e {
                    crate::services::storage_admin_service::DropCheckpointExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::storage_admin_service::DropCheckpointExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(DropCheckpointError::ApplicationException(aexn)),
                }
            }
        }

        pub type BlockingWritesError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::storage_admin_service::BlockingWritesExn> for
            ::std::result::Result<crate::types::AdminExecResp, BlockingWritesError>
        {
            fn from(e: crate::services::storage_admin_service::BlockingWritesExn) -> Self {
                match e {
                    crate::services::storage_admin_service::BlockingWritesExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::storage_admin_service::BlockingWritesExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(BlockingWritesError::ApplicationException(aexn)),
                }
            }
        }

        pub type RebuildTagIndexError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::storage_admin_service::RebuildTagIndexExn> for
            ::std::result::Result<crate::types::AdminExecResp, RebuildTagIndexError>
        {
            fn from(e: crate::services::storage_admin_service::RebuildTagIndexExn) -> Self {
                match e {
                    crate::services::storage_admin_service::RebuildTagIndexExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::storage_admin_service::RebuildTagIndexExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(RebuildTagIndexError::ApplicationException(aexn)),
                }
            }
        }

        pub type RebuildEdgeIndexError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::storage_admin_service::RebuildEdgeIndexExn> for
            ::std::result::Result<crate::types::AdminExecResp, RebuildEdgeIndexError>
        {
            fn from(e: crate::services::storage_admin_service::RebuildEdgeIndexExn) -> Self {
                match e {
                    crate::services::storage_admin_service::RebuildEdgeIndexExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::storage_admin_service::RebuildEdgeIndexExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(RebuildEdgeIndexError::ApplicationException(aexn)),
                }
            }
        }

        pub type GetLeaderPartsError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::storage_admin_service::GetLeaderPartsExn> for
            ::std::result::Result<crate::types::GetLeaderPartsResp, GetLeaderPartsError>
        {
            fn from(e: crate::services::storage_admin_service::GetLeaderPartsExn) -> Self {
                match e {
                    crate::services::storage_admin_service::GetLeaderPartsExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::storage_admin_service::GetLeaderPartsExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetLeaderPartsError::ApplicationException(aexn)),
                }
            }
        }

        pub type CheckPeersError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::storage_admin_service::CheckPeersExn> for
            ::std::result::Result<crate::types::AdminExecResp, CheckPeersError>
        {
            fn from(e: crate::services::storage_admin_service::CheckPeersExn) -> Self {
                match e {
                    crate::services::storage_admin_service::CheckPeersExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::storage_admin_service::CheckPeersExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(CheckPeersError::ApplicationException(aexn)),
                }
            }
        }

        pub type AddAdminTaskError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::storage_admin_service::AddAdminTaskExn> for
            ::std::result::Result<crate::types::AdminExecResp, AddAdminTaskError>
        {
            fn from(e: crate::services::storage_admin_service::AddAdminTaskExn) -> Self {
                match e {
                    crate::services::storage_admin_service::AddAdminTaskExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::storage_admin_service::AddAdminTaskExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(AddAdminTaskError::ApplicationException(aexn)),
                }
            }
        }

        pub type StopAdminTaskError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::storage_admin_service::StopAdminTaskExn> for
            ::std::result::Result<crate::types::AdminExecResp, StopAdminTaskError>
        {
            fn from(e: crate::services::storage_admin_service::StopAdminTaskExn) -> Self {
                match e {
                    crate::services::storage_admin_service::StopAdminTaskExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::storage_admin_service::StopAdminTaskExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(StopAdminTaskError::ApplicationException(aexn)),
                }
            }
        }

        pub type ListClusterInfoError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::storage_admin_service::ListClusterInfoExn> for
            ::std::result::Result<crate::types::ListClusterInfoResp, ListClusterInfoError>
        {
            fn from(e: crate::services::storage_admin_service::ListClusterInfoExn) -> Self {
                match e {
                    crate::services::storage_admin_service::ListClusterInfoExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::storage_admin_service::ListClusterInfoExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ListClusterInfoError::ApplicationException(aexn)),
                }
            }
        }

    }

    /// Errors for GeneralStorageService functions.
    pub mod general_storage_service {

        pub type GetError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::general_storage_service::GetExn> for
            ::std::result::Result<crate::types::KVGetResponse, GetError>
        {
            fn from(e: crate::services::general_storage_service::GetExn) -> Self {
                match e {
                    crate::services::general_storage_service::GetExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::general_storage_service::GetExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetError::ApplicationException(aexn)),
                }
            }
        }

        pub type PutError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::general_storage_service::PutExn> for
            ::std::result::Result<crate::types::ExecResponse, PutError>
        {
            fn from(e: crate::services::general_storage_service::PutExn) -> Self {
                match e {
                    crate::services::general_storage_service::PutExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::general_storage_service::PutExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(PutError::ApplicationException(aexn)),
                }
            }
        }

        pub type RemoveError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::general_storage_service::RemoveExn> for
            ::std::result::Result<crate::types::ExecResponse, RemoveError>
        {
            fn from(e: crate::services::general_storage_service::RemoveExn) -> Self {
                match e {
                    crate::services::general_storage_service::RemoveExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::general_storage_service::RemoveExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(RemoveError::ApplicationException(aexn)),
                }
            }
        }

    }

    /// Errors for InternalStorageService functions.
    pub mod internal_storage_service {

        pub type ChainAddEdgesError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::internal_storage_service::ChainAddEdgesExn> for
            ::std::result::Result<crate::types::ExecResponse, ChainAddEdgesError>
        {
            fn from(e: crate::services::internal_storage_service::ChainAddEdgesExn) -> Self {
                match e {
                    crate::services::internal_storage_service::ChainAddEdgesExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::internal_storage_service::ChainAddEdgesExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ChainAddEdgesError::ApplicationException(aexn)),
                }
            }
        }

        pub type ChainUpdateEdgeError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::internal_storage_service::ChainUpdateEdgeExn> for
            ::std::result::Result<crate::types::UpdateResponse, ChainUpdateEdgeError>
        {
            fn from(e: crate::services::internal_storage_service::ChainUpdateEdgeExn) -> Self {
                match e {
                    crate::services::internal_storage_service::ChainUpdateEdgeExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::services::internal_storage_service::ChainUpdateEdgeExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ChainUpdateEdgeError::ApplicationException(aexn)),
                }
            }
        }

    }

}
